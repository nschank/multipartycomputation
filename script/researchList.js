var researchInfo = [
	{authors:["Rashid Sheikh", "Beerendra Kumar", "Durgesh Kumar Mishra"], title:"A Distributed k-Secure Sum Protocol for Secure Multi-Party Computation", year:2010, id:1, tags:["Unsorted","Protocols","Specific Problems","Cheating"], length:5, abstractText:"Secure sum computation of private data inputs is an interesting example of Secure Multiparty Computation (SMC), whichhas attracted many researchers to devise secure protocols with lower probability of data leakage. In this paper, we provide a novel protocol to compute the sum of individual data inputs with zero probability of data leakage when two neighbor parties collude to know the data of a middle party. We break the data block of each party into a number of segments and redistribute the segments among parties before the computation. These entire steps create a scenario in which it becomes impossible to semi-honest parties to know the private data of some other party."},
	{authors:["Rashid Sheikh", "Beerendra Kumar", "Durgesh Kumar Mishra"], title:"A Modified ck-Secure Sum Protocol for Multi-Party Computation", year:2010, id:2, tags:["Unsorted","Protocols","Specific Problems","Cheating"], length:5,abstractText:"Secure Multi-Party Computation (SMC) allows multiple parties to compute some function of their inputs without disclosing the actual inputs to one another. Secure sum computation is an easily understood example and the component of the various SMC solutions. Secure sum computation allows parties to compute the sum of their individual inputs without disclosing the inputs to one another. In this paper, we propose a modified version of our ck-Secure Sum protocol with more security when a group of the computing parties conspire to know the data of some party."},
	{authors:["Durgesh Kumar Mishra", "Neha Koria", "Nikhil Kapoor", "Ravish Bahety"], title:"A Secure Multi-Party Computation Protocol for Malicious Computation Prevention for preserving privacy during Data Mining", year:2009, id:3, tags:["Unsorted","Protocols","Data Mining"], length:6, abstractText:"Secure Multi-Party Computation (SMC) allows parties with similar background to compute results upon their private data, minimizing the threat of disclosure. The exponential increase in sensitive data that needs to be passed upon networked computers and the stupendous growth of internet has precipitated vast opportunities for cooperative computation, where parties come together to facilitate computations and draw out conclusions that are mutually beneficial; at the same time aspiring to keep their private data secure. These computations are generally required to be done between competitors, who are obviously wary of each-others intentions. SMC caters not only to the needs of such parties but also provides plausible solutions to individual organizations for problems like privacy-preserving database query, privacy-preserving scientific computations, privacy-preserving intrusion detection and privacy-preserving data mining. This paper is the second version of a previously proposed protocol Extended_Encrypto_Random, which itself was an extension of the initial work Encrypto_Random. The former endeavors presented a plain sailing yet effective approach to SMC and also laid forward an aptly crafted architecture, whereby such efficient protocols, involving the parties that have come forward for joint-computations and the third party who undertakes such computations, can be developed. Through this succeeding work an attempt has been made to further strengthen the existing protocols, thus paving the way for a more secure multi-party computational process."},
	{authors:["Tal Geula Malkin"], title:"A Study of Secure Database Access and General Two-Party Computation", year:2000, id:4, tags:["Unsorted","Two-Party Computation","Databases","Theses","Information Theoretic Security"], length:216, abstractText:"In this thesis, we first study two fundamental areas of secure computation over a network. First, we study general two-party secure computation, where two mutually distrustful parties are trying to compute an arbitrary function of their inputs, without revealing any extra information (even if one of them is malicious). We prove that, if any non-trivial function can be so computed, then so can every other function. That is, every non-trivial function is complete for two-party secure computation. Consequently, the complexity assumptions sufficient and/or necessary for securely computing f are the same for every non-trivial function f. Next we study the concrete problem of secure database access, where the privacy of both the database and the use is to be protected from each other and from all other participating or eavesdropping parties. We are interesting in practical and theoretical aspects of this problem, addressing issues of efficiency, security, and complexity. More specifically, we start from the model of private information retrieval (PIR), where users are trying to retrieve information from a database while keeping their queries private from the database owner. We then explore the following directions:<ul><li>We study the necessary assumptions for single server PIR with low communication. We prove that oblivious transfer is necessary, implying that PIR is a complete primitive for secure computation, and that computational SPIR protocols can be efficiently constructed from PIR protocols.</li><li>We introduce the model of SPIR, where the privacy of the data, as well as the user, is guaranteed. We show how to efficiently transform PIR protocols into SPIR protocols, for both the information-theoretic and computation settings.</li><li>We introduce the random server model for PIR, and show how to use it to achieve information theoretic solutions in which the database need not give away its data to be replicated, and with minimal online computation for the database.</li></ul>"},
	{authors:["Ran Canetti", "Uri Feige", "Oded Goldreich", "Moni Naor"], title:"Adaptively Secure Multiparty Computation", year:1996, id:5, length:30, tags:["Unsorted","Adaptive Adversaries","Significant Papers","Adversaries","Communication","Proofs","General Theorems"],abstractText:"A fundamental problem in designing secure multiparty protocols is how to deal with adaptive adversaries (i.e. adversaries that may choose the corrupted parties during the course of the computation), in a setting where the channels are insecure and secure communication is achieved by cryptographic primitives based on the computational limitations of the adversary. It turns out that the power of an adaptive adversary is greatly affected by the amount of information gathered upon the corruption of a party. This amount of information models the extent to which uncorrupted parties are trusted to carry out instructions that cannot be externally verified, such as erasing records of past configurations. It has been shown that if the parties are trusted to erase such records, then adaptively secure computation can be carried out using known primitives. However, this total trust in parties may be unrealistic in many scenarios. An important question, open since 1986, is whether adaptively secure multiparty computation can be carried out in the 'insecure channel' setting, even if no party is thoroughly trusted. Our main result is an affirmative resolution of this question for the case where even uncorrupted parties may deviate from the protocol by keeping record of all past configurations. We first propose a novel property of encryption protocols and show that if an encryption protocol enjoying this property is used, instead of a standard encryption scheme, then known constructions become adaptively secure. Next we construct, based on the standard RSA assumption, an encryption protocol that enjoys this property. We also consider parties that, even when uncorrupted, may internally deviate from their protocols in arbitrary ways, as long as no external test can detect fault behavior. We show that in this case no non-trivial protocol can be proven adaptively secure using black-box simulation. This holds even if the communication channels are totally secure.", hasPage:true},
	{authors:["Sanjam Garg", "Amit Sahai"], title:"Adaptively Secure Multi-Party Computation with Dishonest Majority", year:2012, id:6, length:26, tags:["Unsorted","Adaptive Adversaries","Dishonest Majority","General Theorems"], abstractText:"Adaptively secure multiparty computation is an essential and fundamental notion in cryptography. In this work, we focus on the basic question of constructing a multiparty computation protocol secure against a malicious, adaptive adversary in the stand-alone sitting without assuming an honest majority, in the plain model. It has been believed that this question can be resolved by composing known protocols from the literature. We show that, in fact, this belief is fundamentally mistaken. In particular, we show:<ul><li>Round inefficiency is unavoidable when using black-box simulation. There does not exist any \\(o(\\frac{n}{\\log{n}})\\) round protocol that adaptively securely realizes a (natural) n-party functionality with a black-box simulator. Note that most previously known protocols in the adaptive security setting relied on black-box simulators.</li><li>A constant round protocol using non-black-box simulation. We construct a constant round adaptively secure multiparty computation protocol in a setting without honest majority that makes crucial use of non-black box techniques.</li></ul>Taken together, these results give the first resolution to the question of adaptively secure multiparty computation protocols with a malicious dishonest majority in the plain model, open since the first formal treatment of adaptive security for multiparty computation in 1996."},
	{authors:["Yehuda Lindell", "Benny Pinkas"], title:"An Efficient Protocol for Secure Two-Party Computation in the Presence of Malicious Adversaries", year:2007, id:7, length:27, tags:["Unsorted", "Protocols", "Two-Party Computation","Proofs","Oblivious Transfer"], abstractText:"We show an efficient secure two-party protocol, based on Yao's construction, which provides security against malicious adversaries. Yao's original protocol is only secure in the presence of semi-honest adversaries. Security against malicious adversaries can be obtained by applying the compiler of Goldreich, Micali and Wigderson (the 'GMW compiler'). However, this approach does not seem to be very practical as it requires using generic zero-knowledge proofs. Our construction is based on applying cut-and-choose techniques to the original circuit and inputs. Security is proved according to the ideal/real simulation paradigm, and the proof is in the standard model (with no random oracle model or common reference string assumptions). The resulting protocol is computationally efficient: the only usage of asymmetric cryptography is for running O(1) oblivious transfers for each input bit (or for each bit of a statistical security parameter, whichever is larger). Our protocol combines techniques from folklore (like cut-and-choose) along with new techniques for efficiently proving consistency of inputs. We remark that a naive implementation of the cut-and-choose technique with Yao's protocol does not yield a secure protocol. This is the first paper to show how to properly implement these techniques, and to provide a full proof of security. Our protocol can also be interpreted as a constant-round black-box reduction of secure two-party computation to oblivious transfer and perfectly-hiding commitments, or a black-box reduction of secure two-party computation to oblivious transfer alone, with a number of rounds which is linear in a statistical security parameter. These two reductions are comparable to Kilian's reduction, which uses OT alone but incurs a number of rounds which is linear in the depth of the circuit [18]."},
	{authors:["T.R. Srinath", "Magendra Pratap Singh", "Alwyn Roshan Pais"], title:"Anonymity and Verifiability in Multi-Attribute Reverse Auction", year:2011, id:8, length:8, tags:["Unsorted","Auction","Protocols"], abstractText:"The use of e-Auction services has been increasing in recent years. Security requirements in conducting e-Auctions are mainly bid privacy, anonymity and public verifiability. Most of the secure protocols concentrate on privacy and anonymity, which are achieved through bidder-resolved multi-party computation, assuming two or more trusted third parties, either through numerous auctioneers or with asymmetric models in which the commercial entity of an auction issuer or registration manager is assumed in addition to the auctioneer. Multi-attribute reverse auctions promise higher market efficiency and effective information exchange. This work extends and uses the existing schemes. This scheme uses scoring function, winner determination in multi-attribute auctions to implement public verifiability. Anonymity is achieved through bidder side pseudonym generation. By results and analysis we say this is very simple and effective scheme. This scheme ensures public verifiability and anonymity in multi-attribute auctions without revelation of the bids received, third parties and complex communications."},
	{authors:["Vinod M. Prabhakaran", "Manoj M. Prabhakaran"], title:"Assisted Common Information: Further Results", year:2011, id:9, length:8, tags:["Unsorted","Two-Party Computation"], abstractText:"We presented assisted common information as a generalization of Gács-Körner (GK) common information at ISIT 2010. The motivation for our formulation was to improve upperbounds on the efficiency of protocols for secure two-party sampling (which is a form of secure multi-party computation). Our upperbound was based on a monotonicity property of a rate-region (called the assisted residual information region) associated with the assisted common information formulation. In this note we present further results. We explore the connection of assisted common information with the Gray-Wyner system. We show that the assisted residual information region and the Gray-Wyner region are connected by a simple relationship: the assisted residual information region is the increasing hull of the Gray-Wyner region under an affine map. Several known relationships between GK common information and Gray-Wyner system fall out as consequences of this. Quantities which arise in other source coding contexts acquire new interpretations. In previous work we showed that assisted common information can be used to derive upperbounds on the rate at which a pair of parties can {\em securely sample} correlated random variables, given correlated random variables from another distribution. Here we present an example where the bound derived using assisted common information is much better than previously known bounds, and in fact is tight. This example considers correlated random variables defined in terms of standard variants of oblivious transfer, and is interesting on its own as it answers a natural question about these cryptographic primitives."},
	{authors:["Rashid Sheikh", "Beerendra Kumar", "Durgesh Kumar Mishra"], title:"Changing Neighbors k-Secure Sum Protocol for Secure Multi-Party Computation", year:2010, id:10, length:5, tags:["Unsorted","Data Mining","Information Theoretic Security", "Protocols"], abstractText:"Privacy preservation is an important area of the data mining because it allows the sharing of data between multiple parties. Various techniques are available to give privacy between multiple parties. In recent years, privacy preserving data mining has become more important because of the increasing ability to store personal data on the internet. In this paper, we discuss a novel protocol to compute the sum of an individual's data given by parties with zero leakage probability. We break the data blocks into segments and redistribute the segments among all the parties. After redistribution neighbors also changed their place. This is a scenario where it is impossible to know the private data of some other party."},
	{authors:["Dinh Tien Tuan Anh", "Quach Vinh Thanh", "Anwitaman Datta"], title:"CloudMine: Multi-Party Privacy-Preserving Data Analytics Service", year:2012, id:11, length:24, tags:["Unsorted","Specific Problems","Protocols","Data Mining","Databases"], abstractText:"An increasing number of businesses are replacing their data storage and computation infrastructure with cloud services. Likewise, there is an increased emphasis on performing analytics based on multiple datasets obtained from different data sources. While ensuring security of data and computation outsourced to a third party cloud is in itself challenging, supporting analytics using data distributed across multiple, independent clouds is even further from trivial. In this paper we present CloudMine, a cloud-based service which allows multiple data owners to perform privacy-preserved computation over the joint data using their clouds as delegates. CloudMine protects data privacy with respect to semi-honest data owners and semi-honest clouds. It furthermore ensures the privacy of the computation outputs from the curious clouds. It allows data owners to reliably detect if their cloud delegates have been lazy when carrying out the delegated computation. CloudMine can run as a centralized service on a single cloud, or as a distributed service over multiple, independent clouds. CloudMine supports a set of basic computations that can be used to construct a variety of highly complex, distributed privacy-preserving data analytics. We demonstrate how a simple instance of CloudMine (secure sum service) is used to implement three classical data mining tasks (classification, association rule mining and clustering) in a cloud environment. We experiment with a prototype of the service, the results of which suggest its practicality for supporting privacy-preserving data analytics as a (multi) cloud-based service."},
	{authors:["Claude Cr&eacute;peau", "Jeroen van de Graaf", "Alain Tapp"], title:"Committed Oblivious Transfer and Private Multiparty Computation", year:1995, id:12, length:14, tags:["Unsorted","Oblivious Transfer","Zero Knowledge Proofs"], abstractText:"In this paper we present an efficient protocol for \"Committed Oblivious Transfer\" to perform oblivious transfer on committed bits: suppose Alice is committed to bits \\(a_0\\) and \\(a_1\\) and Bob is committed to b, they both want Bob to learn and commit to \\(a_b\\) without Alice learning b nor Bob learning \\(a_\\bar{b}\\). Our protocol, based on the properties of error correcting codes, uses Bit Commitment (BC) and one-out-of-two Oblivious Transfer (OT) as black boxes. Consequently the protocol may be implemented with or without a computational assumption, depending on the kind of BC and OT used by the participants. Assuming a Broadcast Channel is also available, we exploit this result to obtain a protocol for Private Multiparty Computation, without making assumptions about a specific number or fraction of participants being honest. We analyze the protocol's efficiency in terms of BCs and OTs performed. Our approach connects Zero Knowledge proofs on BCs, Oblivious Circuit Evaluation and Private Multi-Party Computations in a conceptually simple and efficient way."},
	{authors:["Ran Canetti","Rosario Gennaro"], title:"Incoercible Multiparty Computation", year:1996, id:13, length:10, tags:["Unsorted","Coercion"], abstractText:" Current secure multiparty protocols have the following deficiency. The public transcript of the communication can be used as an involuntary <B>commitment</B> of the parties to their inputs and outputs. Thus parties can be later coerced by some authority to reveal their private data. Previous work that has pointed this interesting problem out contained only partial treatment. In this work we present the first general and rigorous treatment of the coercion problem in secure computation. First we present a general definition of protocols that provide resilience to coercion. Our definition constitutes a natural extension of the general paradigm used for defining secure multiparty protocols. Next we show that if trapdoor permutations exist then any function can be incoercibly computed (i.e., computed by a protocol that provides resilience to coercion) in the presence of computationally bounded adversaries and only public communication channels. This holds as long as less than half the parties are coerced (or corrupted). In particular, ours are the first incoercible protocols without physical assumptions. Also, our protocols constitute an alternative solution to the recently solved adaptive security problem."},
	{authors:["Gilad Asharov","Yehuda Lindell","Tal Rabin"], title:"Perfectly-Secure Multiplication for Any t < n/3", year:2011, id:14, length:19, tags:["Unsorted","Information Theoretic Security","Proofs"], abstractText:"In the setting of secure multiparty computation, a set of n parties with private inputs wish to jointly compute some functionality of their inputs. One of the most fundamental results of information-theoretically secure computation was presented by Ben-Or, Goldwasser and Wigderson (BGW) in 1988. They demonstrated that any n-party functionality can be computed with perfect security, in the private channels model. The most technically challenging part of this result is a protocol for multiplying two shared values, with perfect security in the presence of up to t < n/3 malicious adversaries. In this paper we provide a full specification of the BGW perfect multiplication protocol and prove its security. This includes one new step for the perfect multiplication protocol in the case of n/4 ≤ t < n/3. As in the original BGW protocol, this protocol works whenever the parties hold univariate (Shamir) shares of the input values. In addition, we present a new multiplication protocol that utilizes bivariate secret sharing in order to achieve higher efficiency while maintaining a round complexity that is constant per multiplication. Both of our protocols are presented with full proofs of security."},
	{authors:["Moni Naor", "Kobbi Nissim"], title:"Communication Preserving Protocols for Secure Function Evaluation", year:2001, id:15, length:10, tags:["Unsorted","Specific Problems","Protocols","General Theorems"], abstractText:"A secure function evaluation protocol allows two parties to jointly compute a function f(x,y) of their inputs in a manner not leaking more information than necessary. A major result in this field is: \"any function f that can be computed using polynomial resources can be computed securely using polynomial resources\" (where 'resources' refers to communication and computation). This result follows by a general transformation from any circuit for f to a secure protocol that evaluates f. Although the resources used by protocols resulting from this transformation are polynomial in the circuit size, they are much higher (in general) than those required for an insecure computation of f. We propose a new methodology for designing secure protocols, utilizing the communication complexity tree (or branching program) representation of f. We start with an efficient (insecure) protocol for f and transform it into a secure protocol. In other words, \"any function f that can be computed using communication complexity c can be can be computed securely using communication complexity that is polynomial in c and a security parameter\". We show several simple applications of this new methodology resulting in protocols efficient either in communication or in computation. In particular, we exemplify a protocol for the Millionaires' problem, where two participants want to compare their values but reveal no other information. Our protocol is more efficient than previously known ones in either communication or computation."},
	{authors:["Martin Hirt", "Ueli Maurer"], title:"Complete Characterization of Adversaries Tolerable in Secure Multi-Party Computation", year:1997, id:16, length:10, tags:["Unsorted","Adversaries","Summary","General Theorems"],abstractText:"The classical results in unconditional multiparty computation among a set of n players state that less than n/2 passive or less that n/3 active adversaries can be tolerated; assuming a broadcast channel, the threshold for active adversaries in n/2. Strictly generalizing these results we specify the set of potentially misbehaving players as an arbitrary set of subsets of the player set. We prove the necessary and sufficient conditions for the existence of secure multiparty protocols in terms of the potentially misbehaving player sets. For every function there exists a protocol against a set of potential passive collusions if and only if no two of these collusions add up to the full player set. The same condition applies for active adversaries when assuming a broadcast channel. Without broadcast channels, for every function there exists a protocol secure against a set of potential active adverse player sets if and only if no three of these sets add up to the full player set. The complexities of the protocols not using a broadcast channel are polynomial, that of the protocol with broadcast is only slightly higher.", hasPage:true},
	{authors:["Michael Ben-Or", "Shafi Goldwasser", "Avi Wigderson"], title:"Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation", year:1988, id:17, hasPage:true, length:10, tags:["Unsorted","General Theorems","Significant Papers","Adversaries"],abstractText:"Every function of n inputs can be efficiently computed by a complete network of n processors in such a way that:<ol><li>If no faults occur, no set of size t &lt; n/2 of players gets any additional information (other than the function value),</li><li>Even if Byzantine faults are allowed, no set of size t&lt;n/3 can either disrupt the computation or get additional information.</li></ol>Furthermore, the above bounds on t are tight!"},
	{authors:["Ivan Damg&aring;rd", "Yuval Ishai"], title:"Constant-Round Multiparty Computation Using a Black-Box Pseudorandom Generator", year:2005, id:18, length:20, tags:["Unsorted","Honest Majority","Adaptive Adversaries","Constant-Round Protocols","Protocols"], abstractText:"We present a constant-round protocol for general secure multiparty computation which makes a black-box use of a pseudorandom generator. In particular, the protocol does not require expensive zero-knowledge proofs and its communication complexity does not depend on the computational complexity of the underlying cryptographic primitive. Our protocol withstands an active, adaptive adversary corrupting a minority of the parties. Previous constant-round protocols of this type were only known in the semi-honest model or for restricted classes of functionalities", include:true},
	{authors:["Ronald Cramer", "Ivan Damg&aring;rd", "Stefan Dziembowski", "Martin Hirt", "Tal Rabin"], title:"Efficient Multiparty Computations Secure Against an Adaptive Adversary", year:1999, id:19, length:16, tags:["Unsorted","Verified Secret Sharing","Honest Majority"], abstractText:"We consider veriﬁable secret sharing (VSS) and multiparty computation (MPC) in the secure-channels model, where a broadcast channel is given and a non-zero error probability is allowed. In this model Rabin and Ben-Or proposed VSS and MPC protocols secure against an adversary that can corrupt any minority of the players. In this paper, we ﬁrst observe that a subprotocol of theirs, known as weak secret sharing (WSS), is not secure against an adaptive adversary, contrary to what was believed earlier. We then propose new and adaptively secure protocols for WSS, VSS and MPC that are substantially more efficient than the original ones. Our protocols generalize easily to provide security against general Q<sup>2</sup>-adversaries.", inclue:true},
	{authors:["Martin Hirt", "Ueli Maurer", "Bartosz Przydatek"], title:"Efficient Secure Multiparty Computation", year:2000, id:20, length:18, tags:["Unsorted", "Information Theoretic Security"], abstractText:"Since the introduction of secure multi-party computation, all proposed protocols that provide security against cheating players suffer from very high communication complexities. The most efficient unconditionally secure protocols among n players, tolerating cheating by up to t &lt; n/3 of them, require communicating \\(O(n^6)\\) field elements for each multiplication of two elements, even if only one player cheats. In this paper, we propose a perfectly secure multi-party protocol which requires communicating \\(O(n^3)\\) field elements per multiplication. In this protocol, the number of invocations of the broadcast primitive is independent of the size of the circuit to be computed. The proposed techniques are generic and apply to other protocols for robust distributed computations. Furthermore, we show that a sub-protocol proposed in [GRR98] for improving the efficiency of unconditionally secure multi-party computation is insecure.", hasPage:true},
	{authors:["Yehuda Lindell"], title:"General Composition and Universal Composability in Secure Multi-Party Computation", year:2003, id:21, length:30, tags:["Unsorted","Concurrency","Universal Composability", "General Composability","Two-Party Computation"], abstractText:"Concurrent general composition relates to a setting where a secure protocol is run in a network concurrently with other, arbitrary protocols. Clearly, security in such a setting is what is desired, or even needed, in modern computer networks where many different protocols are executed concurrently. Canetti (FOCS 2001) introduced the notion of universal composability and showed that security under this definition is sufficient for achieving concurrent general composition. However, it is not known whether or not the opposite direction also holds. Our main result is a proof that security under concurrent general composition, when interpreted in the natural way under the simulation paradigm, is equivalent to a variant of universal composability, where the only difference relates to the order of quantifiers in the definition. (In newer versions of universal composability, these variants are equivalent.) An important corollary of this theorem is that existing impossibility results for universal composability (for all its variants) are inherent for definitions that imply security under concurrent general composition, as formulated here. In particular, there are large classes of two-party functionalities for which it is impossible to obtain protocols (in the plain model) that remain secure under concurrent general composition. We stress that the impossibility results obtained are not \"black-box,\" and apply even to non-black-box simulation. Our main result also demonstrates that the definition of universal composability is somewhat \"minimal\" in that the composition guarantee provided by universal composability implies the definition itself. This indicates that the security definition of universal composability is not overly restrictive.", include:true},
	{authors:["Ronald Cramer","Ivan Damg&aring;rd", "Ueli Maurer"], title:"Efficient General Secure Multi-Party Computation from and Linear Secret-Sharing Scheme", year:2000, id:22, length:19, tags:["Unsorted","Verifiable Secret Sharing"], abstractText:"We show that verifiable secret sharing (VSS) and secure multi-party computation (MPC) among a set of n players can efficiently be based on any linear secret sharing scheme (LSSS) for the players, provided that the access structure of the LSSS allows MPC or VSS at all. Because an LSSS neither guarantees reconstructability when some shares are false, nor verifiability of a shared value, nor allows for the multiplication of shared values, an LSSS is an apparently much weaker primitive than VSS or MPC. Our approach to secure MPC is generic and applies to both the information-theoretic and the cryptographic setting. The construction is based on 1) a formalization of the special multiplicative property of an LSSS that is needed to perform a multiplication on shared values, 2) an efficient generic construction to obtain from any LSSS a multiplicative LSSS for the same access structure, and 3) an efficient generic construction to build verifiability into every LSSS (always assuming that the adversary structure allows for MPC or VSS at all). The protocols are efficient. In contrast to all previous information-theoretically secure protocols, the field size is not restricted (e.g, to be greater than n). Moreover, we exhibit adversary structures for which our protocols are polynomial in n while all previous approaches to MPC for non-threshold adversaries provably have super-polynomial complexity."},
	{authors:["Boaz Barak","Amit Sahai"], title:"How To Play Almost Any Mental Game Over The Net - Concurrent Composition via Super-Polynomial Simulation", year:2005, id:23, length:50, tags:["Unsorted","Concurrency","Asynchronous"], abstractText:"We construct a secure protocol for any multiparty functionality that remains secure (under a relaxed definition of security introduced by Prabhakaran and Sahai (STOC '04)) when executed concurrently with multiple copies of itself and other protocols, without any assumptions on existence of trusted parties, common reference string, honest majority or synchronicity of the network. The relaxation of security is obtained by allowing the ideal-model simulator to run in quasipolynomial (as opposed to polynomial) time. Quasipolynomial simulation suffices to ensure security for most applications of multiparty computation. Furthermore, Lindell (FOCS '03, TCC' 04) recently showed that such a protocol is impossible to obtain under the more standard definition of polynomial-time simulation by an ideal adversary. Our construction is the first such protocol under reasonably standard cryptographic assumptions (i.e., existence of a hash function collection that is collision resistent with respect to circuits of subexponential size, and existence of trapdoor permutations which are secure with respect to circuits of quasi-polynomial size). We introduce a new technique: \"protocol condensing\". That is, taking a protocol that has strong security properties but requires super-polynomial communication and computation, and then transforming it into a protocol with polynomial communication and computation, that still inherits the strong security properties of the original protocol. Our result is obtained by combining this technique with previous techniques of Canetti, Lindell, Ostrovsky, and Sahai (STOC '02) and Pass (STOC '04)."},
	{authors:["Andrew C. Yao"], title:"How to Generate and Exchange Secrets", year:1986, id:24, length:6, tags:["Significant Papers","Two-Party Computation","Fairness","General Solutions","Practicality","Protocols"], abstractText:"In this paper we introduce a new tool for controlling the knowledge transfer process in cryptographic protocol design. It is applied to solve a general class of problems which include most of the two-party cryptographic problems in the literature. Specifically, we show how two parties A and B can interactively generate a random integer \\(N = pq\\) such that its secret, i.e. the prime factors \\((p, q)\\), is hidden from either party individually but is recoverable jointly if desired. This can be utilized to give a protocol for two parties with private values \\(i\\) and \\(j\\) to compute any polynomially computable functions \\(f(i,j)\\) and \\(g(i,j)\\) with minimal knowledge transfer and a strong <span class=\"load-definable\">fairness</span> property. As a special case, A and B can exchange a pair of secrets \\(s_A\\), \\(s_B\\), e.g. the factorization of an integer and a <span class=\"load-definable\" data-define=\"Hamiltonian cycle\">Hamiltonian circuit</span> in a graph, in such a way that \\(s_A\\) becomes computable by B when and only when \\(s_B\\) becomes computable by A. All these results are proved assuming only that the problem of factoring large integers is computationally intractable.", hasPage:true},
	{authors:["Claudio Orlandi"], title:"Is Multiparty Computation Any Good In Practice?", year:2011, id:25, length:6, tags:["Unsorted","Summary"], abstractText:"The aim of this paper is to present some of the recent progress in efficient secure multiparty computation (MPC). In MPC we have a set of parties owning a set of private inputs. The par ties want to compute a function of their inputs, but they do not trust each other, therefore they need a cryptographic protocol to perform the computation in a way that 1) the output is correct and 2) cheating parties will not be able to learn any information about the honest parties inputs. Even though this problem has been formulated and essentially solved almost 30 years ago, practical solutions that can be relevant for real-world applications have been discovered only in the last few years. We will present some of these advances, trying to explain to a non-specialized audience the significance of the several existing security notions."},
	{authors:["Yehuda Lindell"], title:"Lower Bounds and Impossibility Results for Concurrent Self Composition", year:2005, id:26, length:45, tags:["Unsorted","Concurrency", "Universal Composability"], abstractText:"In the setting of concurrent self composition, a single protocol is executed many times concurrently in a network. In this paper, we prove lower bounds and impossibility results for secure protocols in this setting. First and foremost, we prove that there exist large classes of functionalities that cannot be securely computed under concurrent self composition, by any protocol. We also prove a communication complexity lower bound on protocols that securely compute a large class of functionalities in this setting. Specifically, we show that any protocol that computes a functionality from this class and remains secure for m concurrent executions, must have bandwidth of at least m bits. The above results are unconditional and hold for any type of simulation (i.e., even for non-black-box simulation). In addition, we prove a severe lower bound on protocols that are proven secure using black-box simulation. Specifically, we show that any protocol that computes the blind signature or oblivious transfer functionalities and remains secure for m concurrent executions, where security is proven via black-box simulation, must have at least m rounds of communication. Our results hold for the plain model, where no trusted setup phase is assumed. While proving our impossibility results, we also show that for many functionalities, security under concurrent self composition (where a single secure protocol is run many times) is actually equivalent to the seemingly more stringent requirement of security under concurrent general composition (where a secure protocol is run concurrently with other arbitrary protocols). This observation has significance beyond the impossibility results that are derived by it for concurrent self composition."},
	{authors:["Matthias Fitzi","Juan A. Garay", "Ueli Maurer", "Rafail Ostrovsky"], title:"Minimal Complete Primitives for Secure Multi-Party Computation", year:2005, id:27, length:21, tags:["Unsorted"], abstractText:"The study of minimal cryptographic primitives needed to implement secure computation among two or more players is a fundamental question in cryptography. The issue of complete primitives for the case of two players has been thoroughly studied. However, in the multi-party setting, when there are n > 2 players and t of them are corrupted, the question of what are the simplest complete primitives remained open for t ≥ n/3. (A primitive is called complete if any computation can be carried out by the players having access only to the primitive and local computation.) In this paper we consider this question, and introduce complete primitives of minimal cardinality for secure multiparty computation. The cardinality issue (number of players accessing the primitive) is essential in settings where primitives are implemented by some other means, and the simpler the primitive the easier it is to realize. We show that our primitives are complete and of minimal cardinality possible for most cases."},
	{authors:["Markus Jakobson","Ari Juels"], title:"Mix and Match: Secure Function Evaluation via Ciphertexts", year:2000, id:28, length:16, tags:["Unsorted","Specific Problems","Protocols"], abstractText:"We introduce a novel approach to general secure multiparty computation that avoids the intensive use of verifiable secret sharing characterizing nearly all previous protocols in the literature. Instead, our scheme involves manipulation of ciphertexts for which the underlying private key is shared by participants in the computation. The benefits of this protocol include a high degree of conceptual and structural simplicity, low message complexity, and substantial flexibility with respect to input and output value formats. We refer to this new approach as mix and match. While the atomic operations in mix and match are logical operations, rather than full field operations as in previous approaches, the techniques we introduce are nonetheless highly practical for computations involving intensive bitwise manipulation. One application for which mix and match is particularly well suited is that of sealed-bid auctions. Thus, as another contribution in this paper, we present a practical, mix-and-match-based auction protocol that is fully private and non-interactive and may be readily adapted to a wide range of auction strategies."},
	{authors:["Durgesh Kumar Mishra","Samiksha Shukla"], title:"Multi-Agent Model using Secure Multi-Party Computing in e-Governance", year:2009, id:29, length:5, tags:["Unsorted","Summary"], abstractText:"Information management and retrieval of all the citizen occurs in almost all the public service functions. Electronic Government system is an emerging trend in India through which efforts are made to strive maximum safety and security. Various solutions for this have been proposed like Shibboleth, Public Key Infrastructure, Smart Cards and Light Weight Directory Access Protocols. Still, none of these guarantee 100 percent security. Efforts are being made to provide common national identity solution to various diverse Government identity cards. In this paper, we discuss issues related to these solutions."},
	{authors:["Ronald Cramer", "Ivan Damg&aring;rd", "Jesper B. Nielsen"], title:"Multiparty Computation from Threshold Homomorphic Encryption", year:2001, id:30, length:20, tags:["Unsorted","Homomorphism","Threshold Encryption"], abstractText:"We introduce a new approach to multiparty computation (MPC) basing it on homomorphic threshold cryptosystems. We show that, given keys for any sufficiently efficient system of this type, general MPC protocols for n parties can be devised which are secure against an active adversary that corrupts any minority of the parties. The total number of bits broadcast is \\(O(nk|C|)\\), where k is the security parameter and |C| is the size of a (Boolean) circuit computing the function to be securely evaluated. An earlier proposal by Franklin and Haber with the same complexity was only secure for passive adversaries, while all earlier protocols with active security had complexity at least quadratic in n. We give two examples of threshold cryptosystems that can support our construction and lead to the claimed complexities. "},
	{authors:["Elette Boyle", "Shafi Goldwasser", "Abhishek Jain", "Yael Tauman Kalai"], title:"Multiparty Computation Secure Against Continual Memory Leakage", year:2012, id:31, length:20, tags:["Unsorted","Leakage"], abstractText:"We construct a multiparty computation (MPC) protocol that is secure even if a malicious adversary, in addition to corrupting 1-ε fraction of all parties for an arbitrarily small constant ε&gt;0, can leak information about the secret state of each honest party. This leakage can be continuous for an unbounded number of executions of the MPC protocol, computing different functions on the same or different set of inputs. We assume a (necessary) \"leak-free\" preprocessing stage. We emphasize that we achieve leakage resilience without weakening the security guarantee of classical MPC. Namely, an adversary who is given leakage on honest parties' states, is guaranteed to learn nothing beyond the input and output values of corrupted parties. This is in contrast with previous works on leakage in the multiparty protocol setting, which weaken the security notion, and only guarantee that a protocol which leaks l bits about the parties' secret states, yields at most l bits of leakage on the parties' private inputs. For some functions, such as voting, such leakage can be detrimental. Our result relies on standard cryptographic assumptions, and our security parameter is polynomially related to the number of parties."},
	{authors:["Gilad Asharov", "Abhishek Jain", "Daniel Wichs"], title:"Multiparty Computation with Low Communication, Computation and Interaction via Threshold FHE", year:2012, id:32, length:48, tags:["Unsorted","Homomorphism","Threshold Encryption"], abstractText:"Fully homomorphic encryption (FHE) enables secure computation over the encrypted data of a single party. We explore how to extend this to multiple parties, using threshold fully homomorphic encryption (TFHE). In such scheme, the parties jointly generate a common FHE public key along with a secret key that is shared among them; they can later cooperatively decrypt ciphertexts without learning anything but the plaintext. We show how to instantiate this approach efficiently, by extending the recent FHE schemes of Brakerski, Gentry and Vaikuntanathan (CRYPTO '11, FOCS '11, ITCS '12) based on the (ring) learning with errors assumption. Our main tool is to exploit the property that such schemes are additively homomorphic over their keys. Using TFHE, we construct simple multiparty computation protocols secure against fully malicious attackers, tolerating any number of corruptions, and providing security in the universal composability framework. Our protocols have the following properties: Low interaction: 3 rounds of interaction given a common random string, or 2 rounds with a public-key infrastructure. Low communication: independent of the function being computed (proportional to just input and output sizes). Cloud-assisted computation: the bulk of the computation can be efficiently outsourced to an external entity (e.g. a cloud service) so that the computation of all other parties is independent of the complexity of the evaluated function."},
	{authors:["Martin Hirt"], title:"Multiparty Computation: Efficient Protocols, General Adversaries, and Voting", year:2001, id:33, length:174, tags:["Unsorted","Theses", "Adversaries","Specific Problems"], abstractText:"Secure multi-party computation allows a set of players to jointly compute an arbitrary function of their inputs, without revealing these inputs to each other. For example, the players can compute the average of their incomes in such a way that no player learns the income of any other player. Or, as a more applied example, a set of voters can compute the sum of their votes without revealing any particular vote. The classical results in the literature state that \\(n\\) players can compute any function in such a way that any subset of up to \\(t&lt;n/2\\) players obtains no (zero) information about the other players' inputs, except for what can be derived from the public function output. If the bad players may deviate from the protocol and try both to obtain information about the other players inputs as well as to falsify the public output of the computation, then up to \\(t&lt;n/3\\) can be tolerated. Both bounds are tight. The achievements of this thesis are three-fold: First, we investigate the efficiency of multi-party protocols. Especially those protocols that allow the bad players to deviate from the protocol are very inefficient. We show that protocols that tolerate misbehavior of the players are almost as efficient as protocols that require all players to follow the protocol correctly. The framework that allows this speed-up is generic and might be used for other distributed tasks as well. Second, we generalize the existential results for multi-party computation. We show that one can tolerate certain collusions to be larger than the mentioned threshold \\(t\\), at the cost that some other collusions of size \\(t\\) cannot be tolerated. This models well the fact that in the real-world, some players might be more likely to cheat than others. For various models, we give complete characterizations of the collusions that can be tolerated. Third, we study secret-ballot voting, a particular application of multi-party computation. We are especially interested in the so-called ''receipt-freeness'' property, which essentially means that voters should not be able to sell their right to vote. Receipt-freeness is known to be a subtle property, because one has to deal with voters who are willing to do anything for convincing the vote-buyer that they have submitted the requested vote. We propose a modular framework for such protocols, and construct two concrete receipt-free voting protocols that are more efficient than any receipt-free voting protocol in the literature."},
	{authors:["David Chaum","Claude Cr&eacute;peau", "Ivan Damg&aring;rd"], title:"Multiparty Unconditionally Secure Protocols", year:1988, id:34, length:10, tags:["Verifiable Secret Sharing","Information Theoretic Security","Honest Majority","General Theorems"], hasPage:true, abstractText:"Assume n participants \\(P_1,P_2,\\dots,P_n\\) share the knowledge of a multivariable function F and that they want to publicly compute \\(z=F(x_1,x_2,\\dots,x_n)\\), where \\(x_i\\) is a secret input provided by \\(P_i\\). The difficulty is to simultaneously provide the secrecy of each \\(x_i\\) and to guarantee the correctness of the common result z. Such a task has been accomplished in [GMW] under the assumption that trapdoor permutations exist. The result we propose in this extended abstract is that, under the assumption that each pair of participants can communicate secretly, any reasonable function can be computed if at least \\(\\frac{2n}{3}\\) of the participants are honest and this is proved without any cryptographic assumption. Our result is based on a non-cryptographic verifiable secret sharing protocol that we also introduce in this paper."},
	{authors:["Ran Canetti","Ivan Damg&aring;rd","Stefan Dziembowski","Yuval Ishai","Tal Malkin"], title:"On adaptive vs. non-adaptive security of multiparty protocols", year:2001, id:35, length:18, tags:["Unsorted","Adversaries","Proofs"], abstractText:"Security analysis of multiparty cryptographic protocols distinguishes between two types of adversarial settings: In the non-adaptive setting, the set of corrupted parties is chosen in advance, before the interaction begins. In the adaptive setting, the adversary chooses who to corrupt during the course of the computation. We study the relations between adaptive security (i.e., security in the adaptive setting) and non-adaptive security, according to two definitions and in several models of computation. While affirming some prevailing beliefs, we also obtain some unexpected results. Some highlights of our results are:<ul><li>According to the definition of Dodis-Micali-Rogaway (which is set in the information-theoretic model), adaptive and non-adaptive security are equivalent. This holds for both honest-but-curious and Byzantine adversaries, and for any number of parties.</li><li>According to the definition of Canetti, for honest-but-curious adversaries, adaptive security is equivalent to non-adaptive security when the number of parties is logarithmic, and is strictly stronger than non-adaptive security when the number of parties is super-logarithmic. For Byzantine adversaries, adaptive security is strictly stronger than non-adaptive security, for any number of parties.</li></ul>"},
	{authors:["Deepesh Data","Vinod M. Prabhakaran","Manoj M. Prabhakaran"], title:"On the Communication Complexity of Secure Computation", year:2014, id:36, length:37, tags:["Unsorted","Information Theoretic Security"], abstractText:"Information theoretically secure multi-party computation (MPC) is a central primitive of modern cryptography. However, relatively little is known about the communication complexity of this primitive. In this work, we develop powerful information theoretic tools to prove lower bounds on the communication complexity of MPC. We restrict ourselves to a 3-party setting in order to bring out the power of these tools without introducing too many complications. Our techniques include the use of a data processing inequality for residual information - i.e., the gap between mutual information and Gács-Körner common information, a new information inequality for 3-party protocols, and the idea of distribution switching by which lower bounds computed under certain worst-case scenarios can be shown to apply for the general case. Using these techniques we obtain tight bounds on communication complexity by MPC protocols for various interesting functions. In particular, we show concrete functions that have \"communication-ideal\" protocols, which achieve the minimum communication simultaneously on all links in the network. Also, we obtain the first explicit example of a function that incurs a higher communication cost than the input length in the secure computation model of Feige, Kilian and Naor (1994), who had shown that such functions exist. We also show that our communication bounds imply tight lower bounds on the amount of randomness required by MPC protocols for many interesting functions"},
	{authors:["Yehuda Lindell"], title:"On the Composition of Secure Multi-Party Protocols", year:2002, id:37, length:143, tags:["Unsorted","Theses","Universal Composability"], abstractText:"In the setting of multiparty computation, sets of two or more parties with private inputs wish to jointly compute some (predetermined) function of their inputs. This computation should be such that the outputs received by the parties are correctly distributed, and none of the parties learn anything beyond their prescribed output. This encompasses any distributed computing task and includes computations as simple as coin-tossing and broadcast, and as complex as electronic voting, electronic auctions, electronic cash schemes and anonymous transactions. The feasibility (and infeasibility) of multiparty computation has been extensively studied, resulting in a seemingly comprehensive understanding of what can and cannot be securely computed, and under what assumptions. However, most of this research relates only to the stand-alone setting, in which a single set of parties execute a single protocol in isolation. In contrast, in modern network settings, it is usually the case that many parties run many protocol executions. In this thesis, we study the feasibility of secure multi-party computation under this more realistic setting of general composition of protocols and executions. The main results presented are as follows: <ol><li>We show that the basic task of achieving secure broadcast is strictly harder under composition. Specifically, in the stand-alone model, it is known that digital signatures can be used in order to obtain broadcast that is secure for any number of corrupted parties. In contrast, we show that it is impossible to obtain a secure broadcast protocol that composes in parallel or concurrently (even assuming digital signatures), unless one assumes that strictly less than one third of the parties are corrupted.</li><li>The above impossibility result has a serious impact on the composition of secure multi-party protocols (when a third or more of the parties may be corrupted). This is because all known protocols for secure multi-party computation assume a broadcast channel, and implement this channel in a point-to-point network using a protocol for secure broadcast. Therefore, these multi-party protocols do not compose. We bypass this problem as follows. First, we provide a new definition of secure multiparty computation that is a mild relaxation of previous definitions. Next, we show that under this definition, secure computation of any function can be achieved without broadcast by adapting known protocols. As a corollary we obtain secure multiparty protocols that compose (concurrently, when an honest majority is assumed, and in parallel when any number of parties may be corrupted).</li><li>Finally, we study the feasibility of obtaining \"universally composable\" secure multiparty computation. The composition operation considered in the framework of universal composability is very general. In particular, it guarantees that a secure protocol remains secure even when run concurrently with other arbitrary protocols. This captures the security requirements of protocols in real settings (like that of the Internet). Previously, it has been shown that when a majority of the parties are assumed to be honest, universally composable protocols can be constructed from any functionality (in the standard model). It has also been shown that when only a minority of the parties are honest, there are inportant functionalities that cannot be securely realized in a universally composable way in the standard model. Thus, an important open question is whether or nor there exists a reasonable model in which universally composable multiparty computation of general functionalities can be achieved, for an honest minority. We show that in the common reference string model, universally composable protocols exist for any two-party and multiparty functionality and for any number of corrupted parties. This result establishes the feasibility of obtaining secure two-party and multiparty computation (without an honest majority) under the most stringent security definition currently known.</li></ol>"},
	{authors:["Amos Beimel","Yehuda Lindell","Eran Omri","Ilan Orlov"], title:"1/p-Secure Multiparty Computation without Honest Majority and the Best of Both Worlds", year:2011, id:38, length:20, tags:["Unsorted","Dishonest Majority"], abstractText:"<p>A protocol for computing a functionality is secure if an adversary in this protocol cannot cause more harm than in an ideal computation, where parties give their inputs to a trusted party which returns the output of the functionality to all parties. In particular, in the ideal model such computation is fair – all parties get the output. Cleve (STOC 1986) proved that, in general, fairness is not possible without an honest majority. To overcome this impossibility, Gordon and Katz (Eurocrypt 2010) suggested a relaxed definition – 1/p-secure computation – which guarantees partial fairness. For two parties, they construct 1/p-secure protocols for functionalities for which the size of either their domain or their range is polynomial (in the security parameter). Gordon and Katz ask whether their results can be extended to multiparty protocols.</p><p>We study 1/p-secure protocols in the multiparty setting for general functionalities. Our main result is constructions of 1/p-secure protocols that are resilient against any number of corrupt parties provided that the number of parties is constant and the size of the range of the functionality is at most polynomial (in the security parameter n). If less than 2/3 of the parties are corrupt, the size of the domain is constant, and the functionality is deterministic, then our protocols are efficient even when the number of parties is log log n. On the negative side, we show that when the number of parties is super-constant, 1/p-secure protocols are not possible when the size of the domain is polynomial. Thus, our feasibility results for 1/p-secure computation are essentially tight.</p><p>We further motivate our results by constructing protocols with stronger guarantees: If in the execution of the protocol there is a majority of honest parties, then our protocols provide full security. However, if only a minority of the parties are honest, then our protocols are 1/p-secure. Thus, our protocols provide the best of both worlds, where the 1/p-security is only a fall-back option if there is no honest majority.</p>"},
	{authors:["Adriana L&oacute;pez-Alt","Eran Tromer","Vinod Vaikuntanathan"], title:"On-the-Fly Multiparty Computation on the Cloud via Multikey Fully Homomorphic Encryption", year:2013, id:39, length:44, tags:["Unsorted","Homomorphism","Databases","Specific Problems","Protocols"], abstractText:"We propose a new notion of secure multiparty computation aided by a computationally-powerful but untrusted \"cloud\" server. In this notion that we call on-the-fly multiparty computation (MPC), the cloud can non-interactively perform arbitrary, dynamically chosen computations on data belonging to arbitrary sets of users chosen on-the-fly. All user's input data and intermediate results are protected from snooping by the cloud as well as other users. This extends the standard notion of fully homomorphic encryption (FHE), where users can only enlist the cloud's help in evaluating functions on their own encrypted data. In on-the-fly MPC, each user is involved only when initially uploading his (encrypted) data to the cloud, and in a final output decryption phase when outputs are revealed; the complexity of both is independent of the function being computed and the total number of users in the system. When users upload their data, they need not decide in advance which function will be computed, nor who they will compute with; they need only retroactively approve the eventually-chosen functions and on whose data the functions were evaluated. This notion is qualitatively the best possible in minimizing interaction, since the users' interaction in the decryption stage is inevitable: we show that removing it would imply generic program obfuscation and is thus impossible. Our contributions are two-fold:<ol><li>We show how on-the-fly MPC can be achieved using a new type of encryption scheme that we call multikey FHE, which is capable of operating on inputs encrypted under multiple, unrelated keys. A ciphertext resulting from a multikey evaluation can be jointly decrypted using the secret keys of all the users involved in the computation.</li><li>We construct a multikey FHE scheme based on NTRU, a very efficient public-key encryption scheme proposed in the 1990s. It was previously not known how to make NTRU fully homomorphic even for a single party. We view the construction of (multikey) FHE from NTRU encryption as a main contribution of independent interest. Although the transformation to a fully homomorphic system deteriorates the efficiency of NTRU somewhat, we believe that this system is a leading candidate for a practical FHE scheme.</li></ol>"},
	{authors:["Christian Cachin","Jan Camenisch"], title:"Optimistic Fair Secure Computation", year:2000, id:40, length:19, tags:["Unsorted", "Two-Party Computation", "Asynchronous","Fairness"], abstractText:"We present an efficient and fair protocol for secure two-party computation in the optimistic model, where a partially trusted third party T is available, but not involved in normal protocol executions. T is needed only if communication is disrupted or if one of the two parties misbehaves. The protocol guarantees that although one party may terminate the protocol at any time, the computation remains fair for the other party. Communication is over an asynchronous network. All our protocols are based on efficient proofs of knowledge and involve no general zero-knowledge tools. As intermediate steps we describe efficient verifiable oblivious transfer and verifiable secure function evaluation protocols, whose security is proved under the decisional Diffie-Hellman assumption."},
	{authors:["Yevgeniy Dodis","Silvio Micali"], title:"Parallel Reducibility for Information-Theoretically Secure Computation", year:2000, id:41, length:19, tags:["Unsorted","Information Theoretic Security","Concurrency"], abstractText:"Secure Function Evaluation (SFE) protocols are very hard to design, and reducibility has been recognized as a highly desirable property of SFE protocols. Informally speaking, reducibility (sometimes called modular composition) is the automatic ability to break up the design of complex SFE protocols into several simpler, individually secure components. Despite much effort, only the most basic type of reducibility, sequential reducibility (where only a single sub-protocol can be run at a time), has been considered and proven to hold for a specific class of SFE protocols. Unfortunately, sequential reducibility does not allow one to save on the number of rounds (often the most expensive resource in a distributed setting), and achieving more general notions is not easy (indeed, certain SFE notions provably enjoy sequential reducibility, but fail to enjoy more general ones)."},
	{authors:["Danny Bickson","Danny Dolev","Genia Bezman","Benny Pinkas"], title:"Peer-to-Peer Secure Multi-Party Numerical Computation", year:2008, id:42, length:10, tags:["Unsorted","Networks","Large Scale","Protocols","Specific Problems"], abstractText:"We propose an efficient framework for enabling secure multi-party numerical computations in a Peer-to-Peer network. This problem arises in a range of applications such as collaborative filtering, distributed computation of trust and reputation, monitoring and numerous other tasks, where the computing nodes would like to preserve the privacy of their inputs while performing a joint computation of a certain function. Although there is a rich literature in the field of distributed systems security concerning secure multi-party computation, in practice it is hard to deploy those methods in very large scale Peer-to-Peer networks. In this work, we examine several possible approaches and discuss their feasibility. Among the possible approaches, we identify a single approach which is both scalable and theoretically secure. An additional novel contribution is that we show how to compute the neighborhood based collaborative filtering, a state-of-the-art collaborative filtering algorithm, winner of the Netflix progress prize of the year 2007. Our solution computes this algorithm in a Peer-to-Peer network, using a privacy preserving computation, without loss of accuracy. Using extensive large scale simulations on top of real Internet topologies, we demonstrate the applicability of our approach. As far as we know, we are the first to implement such a large scale secure multiparty simulation of networks of millions of nodes and hundreds of millions of edges."},
	{authors:["Danny Bickson","Tzachy Reinman", "Danny Dolev", "Benny Pinkas"], title:"Peer-to-Peer Secure Multiparty Numerical Computation Facing Malicious Adversaries", year:2010, id:43, length:16, tags:["Unsorted","Networks","Large Scale","Protocols","Specific Problems"], abstractText:"We propose an efficient framework for enabling secure multi-party numerical computations in a Peer-to-Peer network. This problem arises in a range of applications such as collaborative filtering, distributed computation of trust and reputation, monitoring and other tasks, where the computing nodes are expected to preserve the privacy of their inputs while performing a joint computation of a certain function. Although there is a rich literature in the field of distributed systems security concerning secure multi-party computation, in practice it is hard to deploy those methods in very large scale Peer-to-Peer networks. In this work, we try to bridge the gap between theoretical algorithms in the security domain, and a practical Peer-to-Peer deployment. We consider two security models. The first is the semi-honest model where peers correctly follow the protocol, but try to reveal private information. We provide three possible schemes for secure multi-party numerical computation for this model and identify a single light-weight scheme which outperforms the others. Using extensive simulation results over real Internet topologies, we demonstrate that our scheme is scalable to very large networks, with up to millions of nodes. The second model we consider is the malicious peers model, where peers can behave arbitrarily, deliberately trying to affect the results of the computation as well as compromising the privacy of other peers. For this model we provide a fourth scheme to defend the execution of the computation against the malicious peers. The proposed scheme has a higher complexity relative to the semi-honest model. Overall, we provide the Peer-to-Peer network designer a set of tools to choose from, based on the desired level of security."},
	{authors:["Ivan Damg&aring;rd","Yuval Ishai","Mikkel Kr&oslash;igaard"], title:"Perfectly Secure Multiparty Computation and the Computational Overhead of Cryptography", year:2007, id:44, length:32, tags:["Unsorted", "Honest Majority","Two-Party Computation","Information Theoretic Security"], abstractText:"We study the following two related questions: a) What are the minimal computational resources required for general secure multiparty computation in the presence of an honest majority? b) What are the minimal resources required for two-party primitives such as zero-knowledge proofs and general secure two-party computation? We obtain a nearly tight answer to the first question by presenting a perfectly secure protocol which allows n players to evaluate an arithmetic circuit of size s by performing a total of \\(O(s\\log{s}\\log{n}^2)\\) arithmetic operations, plus an additive term which depends (polynomially) on n and the circuit depth, but only logarithmically on s. Thus, for typical large-scale computations whose circuit width is much bigger than their depth and the number of players, the amortized overhead is just polylogarithmic in n and s. The protocol provides perfect security with guaranteed output delivery in the presence of an active, adaptive adversary corrupting a (1/3 − ε) fraction of the players, for an arbitrary constant ε&gt;0 and sufficiently large n. The best previous protocols in this setting could only offer computational security with a computational overhead of poly(k,logn,logs), where k is a computational security parameter, or perfect security with a computational overhead of \\(O(n\\log{n})\\). We then apply the above result towards making progress on the second question. Concretely, under standard cryptographic assumptions, we obtain zero-knowledge proofs for circuit satisfiability with \\(2^{-k}\\) soundness error in which the amortized computational overhead per gate is only polylogarithmic in k, improving over the ω(k) overhead of the best previous protocols. Under stronger cryptographic assumptions, we obtain similar results for general secure two-party computation."},
	{authors:["Martin Hirt","Ueli Maurer","Bartosz Przydatek"], title:"Player Elimination: How to make Cheating Harmless in Multiparty Computation", year:1999, id:45, length:17, tags:["Unsorted","Cheating"], abstractText:"The most efficient multi-party computation protocol known so far for the secure-channels model resilient against an active adversary allows a set of n players to compute an arbitrary circuit with m multiplication gates with a communication complexity of \\(O(mn^6)\\). In this paper we present a perfectly secure protocol for this task with communication complexity \\(O(mn^3)\\). Compared with the most efficient private (but non-resilient) protocol, this reduces the price for resilience from \\(O(n^4)\\) to \\(O(n)\\). The new protocol is even a factor of \\(O(n)\\) more efficient than the most efficient protocol for the cryptographic model. The techniques for achieving this substantial speed-up are generic and can be applied to many other distributed protocols, in both cryptographic and unconditional models. The crucial new notion is player elimination: Whenever a fault occurs, this results in the elimination of a set of players guaranteed to contain at least a certain number of cheaters (and possibly some honest players). There is no necessity to agree on which players in the set are the cheaters. Due to the elimination of cheaters, the adversary can slow down the computation of at most t rounds of the protocol, where t denotes the upper bound on the number of cheaters. For protocols of reasonable size (at least\\(\\Omega(t)\\) multiplication gates) this results in a worst-case complexity (when cheating occurs) essentially equal to the best-case complexity (when no cheating occurs). Further efficiency improvements result from amortizing the complexity of the broadcast sub-protocol over many gates."},
	{authors:["Martin Hirt","Ueli Maurer"], title:"Player Simulation and General Adversary Structures in Perfect Multiparty Computation", year:1999, id:46, length:30, tags:["Unsorted","Adversaries"], abstractText:"The goal of secure multiparty computation is to transform a given protocol involving a trusted party into a protocol without need for the trusted party, by simulating the party among the players. Indeed, by the same means, one can simulate an arbitrary player in any given protocol. We formally define what it means to simulate a player by a multiparty protocol among a set of (new) players, and we derive the resilience of the new protocol as a function of the resiliences of the original protocol and the protocol used for the simulation. In contrast to all previous protocols that specify the tolerable adversaries by the number of corruptible players (a threshold), we consider general adversaries characterized by an adversary structure, a set of subsets of the player set, where the adversary may corrupt the players of one set in the structure. Recursively applying the simulation technique to standard threshold multiparty protocols results in protocols secure against general adversaries. The classical results in unconditional multiparty computation among a set of n players state that, in the passive model, any adversary that corrupts less than n/2 players can be tolerated, and in the active model, any adversary that corrupts less than n/3 players can be tolerated. Strictly generalizing these results we prove that, in the passive model, every function (more generally, every cooperation specified by involving a trusted party) can be computed securely with respect to a given adversary structure if and only if no two sets in the adversary structure cover the full set of players, and, in the active model, if and only if no three sets cover the full set of players. The complexities of the protocols are polynomial in the number of maximal adverse player sets in the adversary structure."},
	{authors:["Manas A. Pathak","Bhiksha Raj"], title:"Privacy-Preserving Protocols for Eigenvector Computation", year:2010, id:47, length:14, tags:["Unsorted","Homomorphism","Specific Problems","Linear Algebra"], abstractText:"In this paper, we present a protocol for computing the principal eigenvector of a collection of data matrices belonging to multiple semi-honest parties with privacy constraints. Our proposed protocol is based on secure multiparty computation with a semi-honest arbitrator who deals with data encrypted by the other parties using an additive homomorphic cryptosystem. We augment the protocol with randomization and obfuscation to make it difficult for any party to estimate properties of the data belonging to other parties from the intermediate steps. The previous approaches towards this problem were based on expensive QR decomposition of correlation matrices, we present an efficient algorithm using the power iteration method. We analyze the protocol for correctness, security, and efficiency."},
	{authors:["Yehuda Lindell"], title:"Protocols for Bounded-Concurrent Secure Two-Party Computation in the Plain Model", year:2004, id:48, length:48, tags:["Unsorted", "Concurrency","Two-Party Computation"], abstractText:"Until recently, most research on the topic of secure computation focused on the stand-alone model, where a single protocol execution takes place. In this paper, we construct protocols for the setting of <i>bounded-concurrent self composition</i>, where a (single) secure protocol is run many times concurrently, and there is a predetermined bound on the number of concurrent executions. In short, we show that <i>any</i> two-party functionality can be securely computed under bounded-concurrent self-composition, in the plain model (where the only setup assumption made is that the parties communicate via authenticated channels). Our protocol provides the first feasibility result for general two-party computation in the plain model, <i>for any model of concurrency.</i> All previous protocols assumed a trusted setup phase in order to obtain a common reference string. On the downside, the number of rounds of communication in our protocol is super-linear in the bound on the number of concurrent-executions. However, we believe that our constructions will lead to more efficient protocols for this task."},
	{authors:["Andrew C. Yao"], title:"Protocols for Secure Computations", year:1982, id:49, length:5, hasPage:true, tags:["Protocols","Significant Papers","Two-Party Computation"],abstractText:"Two millionaires wish to know who is richer; however, they do not want to find out inadvertently any additional information about each other's wealth. How can they carry out such a conversation?"},
	{authors:["Roger Colbeck"], title:"Quantum and Relativistic Protocols for Secure Multiparty Computation", year:2006, id:50, length:150, tags:["Unsorted","Quantum","Theses","Protocols"],abstractText:"After a general introduction, the thesis is divided into four parts. In the first, we discuss the task of coin tossing, principally in order to highlight the effect different physical theories have on security in a straightforward manner, but, also, to introduce a new protocol for non-relativistic strong coin tossing. This protocol matches the security of the best protocol known to date while using a conceptually different approach to achieve the task. In the second part variable bias coin tossing is introduced. This is a variant of coin tossing in which one party secretly chooses one of two biased coins to toss. It is shown that this can be achieved with unconditional security for a specified range of biases, and with cheat-evident security for any bias. We also discuss two further protocols which are conjectured to be unconditionally secure for any bias. The third section looks at other two-party secure computations for which, prior to our work, protocols and no-go theorems were unknown. We introduce a general model for such computations, and show that, within this model, a wide range of functions are impossible to compute securely. We give explicit cheating attacks for such functions. In the final chapter we discuss the task of expanding a private random string, while dropping the usual assumption that the protocol's user trusts her devices. Instead we assume that all quantum devices are supplied by an arbitrarily malicious adversary. We give two protocols that we conjecture securely perform this task. The first allows a private random string to be expanded by a finite amount, while the second generates an arbitrarily large expansion of such a string."},
	{authors:["Ramij Rahaman","Marcin Wie&sacute;niak","Marek &#379;ukowski"], title:"Quantum Anonymous Veto with Hardy Paradox", year:2013, id:51, length:6, tags:["Unsorted","Specific Problems","Quantum"], abstractText:"The Anonymous Veto (or dining cryptographers) problem, which allows a voting party in a jury to anonymously veto a decision, which is to be approved unanimously, has a classical solution in form of a protocol, security of which is guaranteed only by computational hardness. We present a generalization to a multi qubit case of Hardy's argument against local realism, which avoids statistical inequalities, and show that generalized Hardy-type correlations allow a simple quantum solution of the problem. This is possible because Hardy-type conditions for correlations precisely determine a specific genuine multipartite entangled state, which can satisfy them."},
	{authors:["Shailesh Vaya"], title:"(Unconditional) Secure Multiparty Computation with Man-in-the-middle Attacks", year:2010, id:52, tags:["Unsorted","Communication","Byzantine Agreement"], length:18, abstractText:"In secure multi-party computation n parties jointly evaluate an n-variate function f in the presence of an adversary which can corrupt up till t parties. All honest parties are required to receive their correct output values, irrespective of how the corrupted parties under the control of the adversary behave. The adversary should not be able to learn anything more about the input values of the honest parties, then what can be inferred from the input and output values of the corrupted parties and structure of the function. Almost all the works that have appeared in the literature so far assume the presence of authenticated channels between the parties. This assumption is far from realistic. Two directions of research have been borne from relaxing this (strong) assumption: (a) The adversary is virtually omnipotent and can control all the communication channels in the network, (b) Only a partially connected topology of authenticated channels is guaranteed and adversary controls a subset of the communication channels in the network. This work introduces a new setting for (unconditional) secure multiparty computation which is an interesting intermediate model with respect to the above well studied models from the literature (by sharing a salient feature from both the above models). We consider the problem of (unconditional) secure multi-party computation when 'some' of the communication channels connecting the parties can be corrupted passively as well as actively. We model communication channels as entities just like parties and consider a few different types of channels, namely fully secure channels, authenticated but eavesdroppable channels, partially tamperable channels and fully tamperable channels. For this setting, some honest parties may be connected to several other honest parties via corrupted channels and may not be able to authentically/privately communicate with them. Such parties may not be assured the canonical guarantees of correctness or privacy. Honest parties which are not guaranteed correctness or privacy properties are called sacrificed, as is done for the notion of almost everywhere secure computation (above model (b)). We present appropriate definitions of security for this new intermediate model of secure computation for the stand alone setting. We show how to adapt protocols for (unconditional) secure multiparty computation to realize the definitions and also argue the tightness of the results achieved by us."},
	{authors:["Martin Hirt","Ueli Maurer"], title:"Robustness for Free in Unconditional Multi-Party Computation", year:2001, id:53, length:15, tags:["Unsorted", "Information Theoretic Security", "Robustness"], abstractText:"We present a very efficient multi-party computation protocol unconditionally secure against an active adversary. The security is maximal, i.e., active corruption of up to t < n/3 of the n players is tolerated. The communication complexity for securely evaluating a circuit with m multiplication gates over a finite field is \\(O(mn^2)\\) field elements, including the communication required for simulating broadcast, but excluding some overhead costs (independent of m) for sharing the inputs and reconstructing the outputs. This corresponds to the complexity of the best known protocols for the passive model, where the corrupted players are guaranteed not to deviate from the protocol. The complexity of our protocol may well be optimal. The constant overhead factor for robustness is small and the protocol is practical."},
	{authors:["Mariana Raykova"], title:"Secure Computation in Heterogeneous Environments: How to Bring Multiparty Computation Closer to Practice?", year:2012, id:54, length:316, tags:["Unsorted","Theses","Specific Problems"], abstractText:"Many services that people use daily require computation that depends on the private data of multiple parties. While the utility of the final result of such interactions outweighs the privacy concerns related to output release, the inputs for such computations are much more sensitive and need to be protected. Secure multiparty computation (MPC) considers the question of constructing computation protocols that reveal nothing more about their inputs than what is inherently leaked by the output. There have  been strong theoretical results that demonstrate that every functionality can be computed securely. However, these protocols remain unused in practical solutions since they introduce efficiency overhead prohibitive for most applications. Generic multiparty computation techniques address homogeneous setups with respect to the resources available to the participants and the adversarial model. On the other hand, realistic scenarios present a wide diversity of heterogeneous environments where different participants have different available resources and different incentives to misbehave and collude. In this thesis we introduce techniques for multiparty computation that focus on heterogeneous settings. We present solutions tailored to address different types of asymmetric constraints and improve the efficiency of existing approaches in these scenarios."},
	{authors:["Ran Canetti","Rafail Ostrovsky"], title:"Secure Computation with Honest-Looking Parties: What if nobody is truly honest?", year:1999, id:55, length:18, tags:["Unsorted","Dishonest Majority"], abstractText:"In a secure multiparty computation, a set of mutually distrustful parties interact in order to evaluate a pre-defined function of their inputs, without revealing the inputs to each other. In this scenario, the trust in other parties should be minimal. In the classic formulation of this problem, most of the parties are trusted to exactly follow the prescribed protocol, except for a limited number of parties that are corrupted by a centralized adversary and are allowed to deviate from the protocol in an arbitrary way. However, an assumption of a totally honest behavior of most parties can not be verified. In particular, if an 'honest-looking' party diverges from its protocol in a way that is indistinguishable from a totally honest player, it can do so with 'impunity'. In this paper, we consider the situation where <i>all parties</i> (even uncorrupted ones) may deviate from their protocol in arbitrary ways, under the sole restriction that most of the parties do not risk being detected by other parties as deviating from the protocol execution. The question whether secure protocols exist in this scenario was raised in the past, and solutions for very limited deviations from the protocol (i.e. refraining from erasing data) were given. Yet solving the general problem was believed hard, if at all possible. Contrary to this belief, we show that if secure communication channels are provided (and one-way functions exist) then any polynomial function can be securely computed in this scenari."},
	{authors:["Dan Kenigsberg","Tal Mor"], title:"Secure Controlled Teleportation", year:2006, id:56, length:3, tags:["Unsorted","Quantum"], abstractText:"Several protocols for controlled teleportation were suggested by Yang, Chu, and Han [PRA 70, 022329 (2004)]. In these protocols, Alice teleports qubits (in an unknown state) to Bob iff a controller allows it. We view this problem in the perspective of secure multi-party quantum computation. We show that the suggested entanglement-efficient protocols for m-qubit controlled teleportation are open to cheating; Alice and Bob may teleport (m−1)-qubits of quantum information, out of the controller's control. We conjecture that the straightforward protocol for controlled teleportation, which requires each controller to hold m entangled qubits, is optimal. We prove this conjecture for a limited, but interesting, subset of protocols."},
	{authors:["Ronald Cramer","Ivan Damg&aring;rd"], title:"Secure Distributed Linear Algebra in a Constant Number of Rounds", year:2001, id:57, length:18, tags:["Unsorted","Linear Algebra","Specific Problems","Information Theoretic Security"], abstractText:"Consider a network of processors among which elements in a finite field K can be verifiably shared in a constant number of rounds. Assume furthermore constant-round protocols are available for generating random shared values, for secure multiplication and for addition of shared values. These requirements can be met by known techniques in all standard models of communication. In this model we construct protocols allowing the network to securely solve standard computational problems in linear algebra. In particular, we show how the network can securely, efficiently and in constant-round compute determinant, characteristic polynomial, rank, and the solution space of linear systems of equations. Constant round solutions follow for all problems which can be solved by direct application of such linear algebraic methods, such as deciding whether a graph contains a perfect match. If the basic protocols (for shared random values, addition and multiplication) we start from are unconditionally secure, then so are our protocols. Our results offer solutions that are significantly more efficient than previous techniques for secure linear algebra, they work for arbitrary fields and therefore extend the class of functions previously known to be computable in constant round and with unconditional security. In particular, we obtain an unconditionally secure protocol for computing a function f in constant round, where the protocol has complexity polynomial in the span program size of f over an arbitrary finite field."},
	{authors:["Tamir Tassa"], title:"Secure Mining of Association Rules in Horizontally Distributed Databases", year:2014, id:58, length:18, tags:["Unsorted", "Data Mining","Databases","Sets","Specific Problems"], abstractText:"We propose a protocol for secure mining of association rules in horizontally distributed databases. The current leading protocol is that of Kantarcioglu and Clifton [12]. Our protocol, like theirs, is based on the Fast Distributed Mining (FDM) algorithm of Cheung et al. [6], which is an unsecured distributed version of the Apriori algorithm. The main ingredients in our protocol are two novel secure multiparty algorithms&mdash;one that computes the union of private subsets that each of the interacting players hold, and another that tests the inclusion of an element held by in one player in a subset held by another. Our protocol offers enhanced privacy with respect to the protocol in [12]. In addition, it is simpler and is significantly more efficient in terms of communication rounds, communication cost and computational cost."},
	{authors:["Oded Goldreich"], title:"Secure Multi-Party Computation", year:2002, id:59, length:110, tags:["Unsorted","Summary","Proofs","Two-Party Computation"], abstractText:"More than ten years have elapsed since the first completeness theorems for two-party and multiparty fault-tolerant computation have been announced (by Yao and Goldreich, Micali, and Wigderson, respectively). Analogous theorems have been proven in a variety of models, yet full proofs of the above mentioned basic results (i.e. for the \"computational model\" as well as for the \"private channel model\" are not to be found. This manuscript attempts to redeem this sour state of affairs, at least as far as the \"computational model\" goes.", include:true},
	{authors:["Ronald Cramer","Ivan Damg&aring;rd","Jesper B. Nielsen"], title:"Secure Multiparty Computation and Secret Sharing: An Information Theoretic Approach", year:2013, id:60, length:382, tags:["Unsorted","Summary","Verifiable Secret Sharing","Proofs","Information Theoretic Security"], abstractText:"This is a book on information theoretically secure Multiparty Computatio (MPC) and Secret-Sharing, and about the intimate and fascinating relationship between the two notions. We decided to write the book because we felt that a comprehensive treatment of unconditionally secure techniques for MPC was missing in the literature. In particular, because some of the first general protocols were found before appropriate definitions of security had crystallized, proofs of those basic solutions have been missing so far. We present the basic feasibility results for unconditionally secure MPC from the late 80s, generalizations to arbitrary access structures using linear secret sharing, and a selection of more recent techniques for efficiency improvements. We also present our own variant of the UC framework in order to be able to give complete and modular proofs for the protocols we present."},
	{authors:["Wenliang Du","Mikhail J. Atallah"], title:"Secure Multi-Party Computation Problems and Their Applications: A Review and Open Problems", year:2001, id:61, length:10, tags:["Unsorted", "Summary"], abstractText:"The growth of the Internet has triggered tremendous opportunities for cooperative computation, where people are jointly conducting computation tasks based on the private inputs they each supplies. These computations could occur between mutually untrusted parties, or even between competitors. For example, customers might send to a remote database queries that contain private information; two competing financial organizations might jointly invest in a project that must satisfy both organizations' private and valuable constraints, and so on. Today, to conduct such computations, one entity must usually know the inputs from all the participants; however if nobody can be trusted enough to know all the inputs, privacy will become a primary concern.This problem is referred to as Secure Multiparty Computation Problem (SMC) in the literature. Research in the SMC area has been focusing on only a limited set of specific SMC problems, while privacy concerned cooperative computations call for SMC studies in a variety of computation domains. Before we can study the problems, we need to identify and define the specific SMC problems for those computation domains. We have developed a framework to facilitate this problem-discovery task. Based on our framework, we have identified and defined a number of new SMC problems for a spectrum of computation domains. Those problems include privacy-preserving database query, privacy-preserving scientific computations, privacy-preserving intrusion detection, privacy-preserving statistical analysis, privacy-preserving geometric computations, and privacy-preserving data mining.The goal of this paper is not only to present our results, but also to serve as a guideline so other people can identify useful SMC problems in their own computation domains.", include:true},
	{authors:["Peter Bogetoft", "Dan Lund Christensen", "Ivan Damg&aring;rd", "Martin Geisler", "Thomas Jakobsen","Mikkel Kr&oslash;igaard", "Janus Dam Nielsen", "Jesper B. Nielsen", "Kurt Nielsen", "Jakob Pagter","Michael Schwartzbach", "Tomas Toft"], title:"Secure Multiparty Computation Goes Live", year:2008, id:62, length:13, tags:["Summary","Unsorted"], abstractText:"In this note, we report on the first large-scale and practical application of multiparty computation, which took place in January 2008. We also report on the novel cryptographic protocols that were used.", include:true},
	{authors:["Ueli Maurer"], title:"Secure Multi-Party Computation Made Simple", year:2006, id:63, length:15, tags:["Unsorted", "Verifiable Secret Sharing","Proofs","Summary"], abstractText:"A simple approach to secure multi-party computation is presented. Unlike previous approaches, it is based on essentially no mathematical structure (like bivariate polynomials) or sophisticated sub-protocols (like zero-knowledge proofs). It naturally yields protocols secure for mixed (active and passive) corruption and general (as opposed to threshold) adversary structures, confirming the previous tight bounds in a simpler formulation and with simpler proofs. Due to their simplicity, the described protocols are well-suited for didactic purposes, which is a main goal of this paper."},
	{authors:["Joan Feigenbaum","Yuval Ishai","Tal Malkin","Kobbi Nissim","Martin J. Strauss","Rebecca N. Wright"], title:"Secure Multiparty Computation of Approximations", year:2001, id:64, length:30, tags:["Unsorted","Approximation", "Specific Problems"], abstractText:"Approximation algorithms can sometimes provide efficient solutions when no efficient exact computation is known. In particular, approximations are often useful in a distributed setting where the inputs are held by different parties and may be extremely large. Furthermore, for some applications, the parties want to compute a function of their inputs securely, without revealing more information than necessary. In this work, we study the question of simultaneously addressing the above efficiency and security concerns via what we call secure approximations. We start by extending standard definitions of secure (exact) computation to the setting of secure approximations. Our definitions guarantee that no additional information is revealed by the approximation beyond what follows from the output of the function being approximated. We then study the complexity of specific secure approximation problems. In particular, we obtain a sublinear-communication protocol for securely approximating the Hamming distance and a polynomial-time protocol for securely approximating the permanent and related #P-hard problems.", include:true},
	{authors:["Klearchos Loukopoulos","Daniel E. Browne"], title:"Secure Multi-Party Computation with a Dishonest Majority via Quantum Means", year:2011, id:65, length:12, tags:["Quantum","Two-Party Computation","Dishonest Majority","Unsorted"], abstractText:"We introduce a scheme for secure multi-party computation utilising the quantum correlations of entangled states. First we present a scheme for two-party computation, exploiting the correlations of a Greenberger-Horne-Zeilinger state to provide, with the help of a third party, a near-private computation scheme. We then present a variation of this scheme which is passively secure with threshold t = 2, in other words, remaining secure when pairs of players conspire together provided they faithfully follow the protocol. Furthermore we show that the passively secure variant can be modified to be secure when cheating parties are allowed to deviate from the protocol. We show that this can be generalised to computations of n-party polynomials of degree 2 with a threshold of n−1. The threshold achieved is significantly higher than the best known classical threshold, which satisfies the bound t < n/2. Our schemes, each complying with a different definition of security, shed light on how Lo's seminal theorem translates into a measurement based scheme and highlight which physical assumptions are necessary in order to achieve quantum secure multi-party computation."},
	{authors:["Mikhail J. Atallah","Wenliang Du"], title:"Secure Multi-Party Computational Geometry", year:2001, id:66, length:16, tags:["Computational Geometry","Specific Problems","Unsorted"], abstractText:"The general secure multiparty computation problem is when multiple parties (say, Alice and Bob) each have private data (respectively, a and b) and seek to compute some function f(a,b) without revealing to each other anything unintended (i.e. anything other than what can be inferred from knowing f(a,b)). It is well known that, in theory, the general secure multiparty computation problem is solvable using circuit evaluation protocols. While this approach is appealing in its generality, the communication complexity of the resulting protocols depend on the size of the circuit that expresses the functionality to be computed. As Goldreich as recently pointed out [6], using the solutions derived from these general results to solve specific problems can be impractical; problem-specific solutions should be developed, for efficiency reasons. This paper is a first step in this direction for the area of computation geometry. We give simple solutions to some specific geometric problems, and in doing so we develop some building blocks that we believe will be useful in the solution of other geometric and combinatorial problems as well."},
	{authors:["Claude Cr&eacute;peau","Daniel Gottesman","Adam Smith"], title:"Secure Multiparty Quantum Computation", year:2002, id:67, length:9, tags:["Unsorted","Quantum","Information Theoretic Security","Verifiable Secret Sharing"], abstractText:"Secure multiparty computation, also called secure function evaluation, has been extensively studied in classical cryptography. We consider the extension of this task to computation with quantum inputs and circuits. Our protocols are information-theoretically secure, i.e. no assumptions are made on the computational power of the adversary. For the weaker task of verifiable quantum secret sharing, we give a protocol which tolerates any \\(t&lt;\frac{n}{4}\\) cheating parties (out of n). This is shown to be optimal. We use this new tool to show how to perform any multiparty quantum computation as long as the number of dishonest players in less than \\(\\frac{n}{6}\\)."},
	{authors:["Tony Thomas"], title:"Secure Two-Party Protocols for Point Inclusion Problem", year:2008, id:68, length:9, tags:["Computational Geometry","Specific Problems","Two-Party Computation","Unsorted"], abstractText:"It is well known that, in theory, the general secure multiparty computation problem is solvable using circuit evaluation protocols. However, the communication complexity of the resulting protocols depends on the size of the circuit that expresses the functionality to be computed, and hence can be impractical. Hence, special solutions are needed for specific problems for efficiency reasons. The point inclusion problem in computation geometry is a special multiparty computation and has many applications. Previous protocols for the secure point inclusion problem are not adequate. In this paper we modify some known solutions to the point inclusion problem in computational geometry to the framework of secure two-party computation."},
	{authors:["Matthew Franklin","Stuart Haver"], title:"Joint Encryption and Message-Efficient Secure Computation", year:1994, length:12, tags:["Unsorted"], id:69, abstractText:"<p>This paper connects two areas of recent cryptographic research: secure distributed computation, and group-oriented cryptography. We construct a probabilistic public-key encryption scheme with the following properties:</p><ol><li>It is easy to encrypt using the public keys of any subset of parties, such that it is hard to decrypt without the cooperation of every party in the subset.</li><li>It is easy for any private key holder to give a \"witness\" of its contribution to the decryption (e.g., for parallel decryption).</li><li>It is \"blindable\": From an encrypted bit it is easy for anyone to compute a uniformly random encryption of the same bit.</li><li>It is \"xor-homomorphic\": Prom two encrypted bits it is easy for anyone to compute an encryption of their xor.</li><li>It is \"compact\": The size of an encryption does not depend on the number of participants.</li></ol><p>Using this joint encryption scheme as a tool, we show how to reduce the message complexity of secure computation versus a passive adversary (gossiping faults).</p>"},
	{authors:["Rosario Gennaro","Michael O. Rabin","Tal Rabin"], title:"Simplified VSS and Fast-track Multiparty Computations with Applications to Threshold Cryptography", year:1998, id:70, length:23, tags:["Threshold Cryptography","Verifiable Secret Sharing","Homomorphism","Unsorted"],abstractText:"The goal of this paper is to introduce a simple verifiable secret sharing scheme, and to improve the efficiency of known secure multiparty protocols and, by employing these techniques, to improve the efficiency of applications which use these protocols. First we present a very simple Verifiable Secret Sharing protocol which is based on fast cryptographic primitives and avoids altogether the need for expensive zero-knowledge proofs. This is followed by a highly simplified protocol to compute multiplications over shared secrets. This is a major component in secure multiparty computation protocols and accounts for much of the complexity of proposed solutions. Using our protocol as a plug in unit for known protocols reduces their complexity. We show how to achieve efficient multiparty computations in the computational model,through the application of homomorphic commitments. Finally, we borrow from other fields and introduce into the multiparty computation scenario the notion of fast-track computations. In a model in which malicious faults are rare we show that it is possible to carry out a simpler and more efficient protocol which does not perform all the expensive checks needed to combat a malicious adversary from foiling the computation. Yet, the protocol still enables detection of faults and recovers the computation when faults occur without giving any information advantage to the adversary. This results in protocols which are much more efficient under normal operation of the system i.e. when there are no faults. As an example of the practical impact of our work we show how our techniques can be used to greatly improve the speed and the fault-tolerance of existing threshold cryptography protocols."},
	{authors:["Ran Canetti"], title:"Studies in Secure Multiparty Computation and Applications", year:1996, id:71, length:34, tags:["Adaptive Adversaries","Theses","Asynchronous","Proofs","Byzantine Agreement","Unsorted"], abstractText:"Consider a set of parties who do not trust each other, nor the channels by which they communicate. Still, the parties wish to correctly compute some common function of their local inputs, while keeping their local data as private as possible. This, in a nutshell, is the problem of secure multiparty computation. This problem is fundamental in cryptography and in the study of distributed computations. It takes many different forms, depending on the underlying network, on the function to be computed, and on the amount of distrust the parties have in each other and in the network. We study several aspects of secure multiparty computation. We first present new definitions of this problem in various settings. Our definitions draw from previous ideas and formalizations, and incorporate aspects that were previously overlooked. Next we study the problem of dealing with adaptive adversaries. (Adaptive adversaries are adversaries that corrupt parties during the course of the computation, based on the information gathered so far.) We investigate the power of adaptive adversaries in several settings. In particular, we show how to construct adaptively secure protocols for computing any function in a computational setting, where the communication channels can be tapped by the adversary, and secure communication is achieved by cryptographic primitives based on the computational limitations of the adversary. We remark that the problem of dealing with adaptive adversaries in a computational setting was considered to be a hard open problem. Next, we initiate a study of secure multiparty computation in asynchronous networks. We consider a completely asynchronous network where the parties are connected via secure channels. In this setting, we present appropriate definitions and construct protocols for securely computing any function. We present a detailed proof of security of our protocols. In the same asynchronous setting, we apply ideas and techniques of secure multiparty computation to a classical problem in the field of distributed computing, namely the problem of reaching agreement in the presence of Byzantine faults. We present the first asynchronous Byzantine Agreement protocol with optimal resilience (i.e. an adversary may corrupt up to \\(\\lceil\\frac{n}{3}\\rceil-1\\) of the n parties) and polynomial complexity. Finally, we address the problem of maintaining the security of computer systems in the presence of repeated, however transient break-ins. We present a new approach for dealing with this problem. Using our approach, we show how systems can automatically recover from transient break-ins. We introduce mechanisms for maintaining the security of internal data of parties. We use secure multiparty computation as a formal setting for developing and analyzing our mechanisms."},
	{authors:["Yehuda Lindell"], title:"Composition of Secure Multiparty Protocols: A Comprehensive Study", year:2003, id:72, length:203, tags:["Unsorted","Books","Composition"], abstractText:""},
	{authors:["Matthias Fitzi","Martin Hirt","Ueli Maurer"], title:"Trading Correctness for Privacy in Unconditional Multi-Party Computation", year:1998, id:73, length:16, tags:["Corruption","Verifiable Secret Sharing","Unsorted"], abstractText:"This paper improves on the classical results in unconditionally secure multiparty computation among a set of n players by considering a model with three simultaneously occurring types of player corruption: the adversary can actively corrupt (i.e. take full control over) up to \\(t_a\\) players and, additionally, can passively corrupt (i.e. read the entire information of) up to \\(t_p\\) players and fail-corrupt (i.e. stop the computation of) up to \\(t_f\\) other players. The classical results in multi-party computation are for the special cases of only passive (\\(t_a=t_f=0\\)) or only active (\\(t_p=t_f=0\\)) corruption. In the passive case, every function can be computed securely if and only if \\(t_p&lt;\frac{n}{2}\\). In the active case, every function can be computed securely if and only if \\(t_a&lt;\frac{n}{3}\\) when a broadcast channel is available, then this bound is \\(t_a&lt;\frac{n}{2}\\). These bounds are tight. Strictly improving these results, one of our results states that, in addition to tolerating \\(t_a&lt;\frac{n}{3}\\) actively corrupted player,s privacy can be guaranteed against every minority, thus tolerating <i>additional</i> \\(t_p \leq\frac{n}{6}\\) passively corrupted players. These protocols require no broadcast and have an exponentially small failure probability. We further show that the bound \\(t&lt;\frac{n}{2}\\) for passive corruption holds even if the adversary is additionally allowed to make the passively corrupted players fail. Moreover, we characterize completely the achievable thresholds \\(t_a, t_p\\), and \\(t_f\\) for four scenarios. Zero failure probability is achievable if and only if \\(3t_a+2t_p+t_f<n\\); this holds whether or not a broadcast channel is available. Exponentially small failure probability with a broadcast channel is achievable if and only if \\(2t_a+2t_p+t_f<n\\); without broadcast, the additional condition \\(3t_a+t_f<n\\) is necessary and sufficient."},
	{authors:["Dominique Unruh"], title:"Universally Composable Quantum Multi-Party Computation", year:2009, id:74, length:33, tags:["Quantum","Universal Composability","Oblivious Transfer","Unsorted"], abstractText:"The Universal Composability model (UC) by Canetti (FOCS 2001) allows for secure composition of arbitrary protocols. We present a quantum version of the UC model which enjoys the same compositionality guarantees. We prove that in this model statistically secure oblivious transfer protocols can be constructed from commitments. Furthermore, we show that every statistically classically UC secure protocol is also statistically quantum UC secure. Such implications are not known for other quantum security definitions. As a corollary, we get that quantum UC secure protocols for general multi-party computation can be constructed from commitments."},
	{authors:["Ran Canetti","Yehuda Lindell","Rafail Ostrovsky","Amit Sahai"], title:"Universally Composable Two-Party and Multi-Party Secure Computation", year:2002, id:75, length:81, tags:["Asynchronous","Unsorted","Two-Party Computation", "Zero Knowledge Proofs","Semi-Honesty","Universal Composability"], abstractText:"Under the assumption that each participant can broadcast a message to all other participants and that each pair of participants can communicate secretly, we present a verifiable secret sharing protocol, and show that any multiparty protocol, or game with incomplete information, can be achieved if a majority of the players are honest. The secrecy achieved is unconditional and does not rely on any assumption about computational intractability. Applications of these results to Byzantine Agreement are also presented. Underlying our results is a new tool of Information Checking which provides authentication without cryptographic assumptions and may have wide applications elsewhere."},
	{authors:["Tal Rabin","Michael Ben-Or"], title:"Verifiable Secret Sharing and Multiparty Protocols with Honest Majority", year:1989, id:76, length:13, tags:["Verifiable Secret Sharing", "Honest Majority","Byzantine Agreement","Unsorted"], abstractText:"Under the assumption that each participant can broadcast a message to all other participants and that each pair of participants can communicate secretly, we present a verifiable secret sharing protocol, and show that any multiparty protocol, or game with incomplete information, can be achieved if a majority of the players are honest. The secrecy achieved is unconditional and does not rely on any assumption about computational intractability. Applications of these results to Byzantine Agreement are also presented. Underlying our results is a new tool of Information Checking which provides authentication without cryptographic assumptions and may have wide applications elsewhere.", hasPage:true},
	{authors:["Yehuda Lindell","Benny Pinkas"], title:"A Proof of Security of Yao's Protocol for Two-Party Computation", year:2006, id:77, length:25, tags:["Two-Party Computation","Proofs","Unsorted"], ref:[24,81], abstractText:"In the mid 1980's, Yao presented a constant-round protocol for securely computing any two-party functionality in the presence of semi-honest adversaries (FOCS 1986). In this paper, we provide a complete description of Yao's protocol, along with a rigorous proof of security. Despite the importance of Yao's protocol to the theory of cryptography, and in particular to the field of secure computation, to the best of our knowledge, this is the first time that an explicit proof of security has been published.", include:true},
	{authors:["Ivan Damg&aring;rd","Marcel Keller", "Enrique Larraia", "Valerio Pastro", "Peter Scholl", "Nigel P. Smart"], title:"Practical Covertly Secure MPC for Dishonest Majority – or: Breaking the SPDZ Limits", year:2013, id:78, length:45, tags:["Dishonest Majority","Unsorted"], abstractText:"SPDZ (pronounced \"Speedz\") is the nickname of the MPC protocol of Damgard et al. from Crypto 2012. SPDZ provided various efficiency innovations on both the theoretical and practical sides compared to previous work in the preprocessing model. In this paper we both resolve a number of open problems with SPDZ; and present several theoretical and practical improvements to the protocol. In detail, we start by designing and implementing a covertly secure key generation protocol for obtaining a BGV public key and a shared associated secret key. In prior work this was assumed to be provided by a given setup functionality. Protocols for generating such shared BGV secret keys are likely to be of wider applicability than to the SPDZ protocol alone. We then construct both a covertly and actively secure preprocessing phase, both of which compare favourably with previous work in terms of efficiency and provable security. We also build a new online phase, which solves a major problem of the SPDZ protocol: namely prior to this work preprocessed data could be used for only one function evaluation and then had to be recomputed from scratch for the next evaluation, while our online phase can support reactive functionalities. This improvement comes mainly from the fact that our construction does not require players to reveal the MAC keys to check correctness of MAC'd values. Since our focus is also on practical instantiations, our implementation offloads as much computation as possible into the preprocessing phase, thus resulting in a faster online phase. Moreover, a better analysis of the parameters of the underlying cryptoscheme and a more specific choice of the field where computation is performed allow us to obtain a better optimized implementation. Improvements are also due to the fact that our construction is in the random oracle model, and the practical implementation is multi-threaded.", include:true},
	{authors:["Juan A. Garay","Philip MacKenzie", "Ke Yang"], title:"Efficient and Secure Multi-Party Computation with Faulty Majority and Complete Fairness", year:2004, id:79, length:27, tags:["Fairness","Dishonest Majority","Protocols","Unsorted"], refs:[49,81], abstractText:"We study the problem of constructing secure multiparty computation (MPC) protocols that are <i>completely fair</i>&mdash;meaning that either all the parties learn the output of the function, or nobody does&mdash;even when a majority of the parties are corrupted. We first propose a framework for fair multiparty computation, within which we formulate a definition of secure and fair protocols. The definitions follows the standard simulation paradigm, but is modified to allow the protocol to depend on the running time of the adversary. In this way, we avoid a well-known impossibility result for fair MPC with corrupted majority; in particular, our definition admits constructions that tolerate up to (n-1) corruptions, where n is the total number of parties. Next, we define a \"commit-prove-fair-open\" functionality and construct an efficient protocol that realizes it, using a new variant of a cryptographic primitive known as 'time-lines.' With this functionality, we show that some of the existing secure MPC protocols can be easily transformed into fair protocols while preserving their security. Putting these results together, we construct efficient, secure MPC protocols that are completely fair even in the presence of corrupted majorities. Further, these protocols remain secure when arbitrarily composed with any protocols, which means, in particular, that they are concurrently-composable and non-malleable. Finally, as an example of our results, we show a very efficient protocol that fairly and securely solves the socialist millionaires' problem."},
	{authors:["Ronald Cramer","Ivan Damg&aring;rd", "Jesper B. Nielsen"], title:"Multiparty Computation, an Introduction", year:2009, id:80, length:83, tags:["Summary","Unsorted"], abstractText:"These lecture notes introduce the notion of secure multiparty computation. We introduce the universal composition framework for phrasing and proving security about protocols, and survey some known general results that describe when secure multiparty computation is possible. We then look at some general techniques for building secure multiparty protocols, including protocols for commitment and verifiable secret sharing, and we show how these techniques together imply general secure multiparty computation. Our goal with these notes is to convey an understanding of some basic ideas and concepts from this field, rather than to give a fully formal account of all proofs and details. We hope the notes will be accessible to most graduate students in computer science and mathematics with an interest in cryptography.", include:true},
	{authors:["Oded Goldreich","Silvio Micali", "Avi Wigderson"], title:"How To Play Any Mental Game", year:1987, hasPage:true, id:81, length:12, tags:["Oblivious Transfer","General Theorems","Verifiable Secret Sharing","Protocols","Honest Majority","Privacy", "Significant Papers"], abstractText:"We present a polynomial-time algorithm that, given as input the description of a game with incomplete information and any number of players, produces a protocol for playing the game that leaks no partial information, provided the majority of the players is honest. Our algorithm automatically solves all the multi-party protocol problems addressed in complexity-based cryptography during the last 10 years. It actually is a completeness theorem for the class of distributed protocols with honest majority. Such completeness theorem is optimal in the sense that, if the majority of the players is not honest, some protocol problems have no efficient solution.", self_ref:"O. Goldreich, S. Micali, and A. Wigderson. How to Play Any Mental Game or a Completeness Theorem for Protocols with Honest Majority. <i>Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing</i>, pages 218–229. ACM. 1987."},
	{authors:["David Chaum","Ivan Damg&aring;rd","Jeroen van de Graaf"], title:"Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result", id:82, length:33, year:1988, tags:["Unsorted","Significant Papers", "Protocol","Information Theoretic Security"], abstractText:"A protocol is presented that allows a set of parties to collectively perform any agreed computation, where every party is able to choose secret inputs and verify that the resulting output is correct, and where all secret inputs are optimally protected.", hasPage:true},
	{authors:["Thomas Schneider","Michael Zohner"], title:"GMW vs. Yao? Efficient Secure Two-Party Computation with Low Depth Circuits", year:2013, length:8, id:83, abstractText:"Secure two-party computation is a rapidly emerging field of research and enables a large variety of privacy-preserving applications such as mobile social networks or biometric identification. In the late eighties, two different approaches were proposed: Yao's garbled circuits and the protocol of Goldreich-Micali-Wigderson (GMW). Since then, research has mostly focused on Yao's garbled circuits as they were believed to yield better efficiency due to their constant round complexity. In this work we give several optimizations for an efficient implementation of the GMW protocol. We show that for semi-honest adversaries the optimized GMW protocol can outperform today's most efficient implementations of Yao's garbled circuits, but highly depends on a low network latency. As a first step to overcome these latency issues, we summarize depth-optimized circuit constructions for various standard tasks. As application scenario we consider privacy-preserving face recognition and show that our optimized framework is up to 100 times faster than previous works even in settings with high network latency.", tags:["Unsorted","Two-Party Computation"]}
];