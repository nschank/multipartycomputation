<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Efficient Secure Multiparty Computation - Author, Year</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
		<script type="text/javascript" src="../../script/toc.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					default:
						return "No info on this equation yet.";
				}
			}

			function authorLink(ref)
			{
				switch (ref)
				{
					default:
						return "#";
				}
			}

			self_def["non-general word"] = "definition";
			//-->
        </script>
    </head>
    <body>
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1" id="overview">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth">
                    <div class="rp_linkbox"><a href="pdf/20.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">Efficient Secure Multiparty Computation</span>
                    <span class="rp_info">2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					<a class="rp_author" href="../authors/Martin Hirt.html">Martin Hirt</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					<a class="rp_author" href="../authors/Ueli Maurer.html">Ueli Maurer</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					<a class="rp_author" href="../authors/Bartosz Przydatek.html">Bartosz Przydatek</a>
					</span>
					
					<div class="rp_snippet">
						&ldquo;&rdquo;
					</div>
					
					THIS PAGE IS UNDER CONSTRUCTION
					<h1>Overview</h1>
                    <div class="main_toc"></div>
					
						
                    <section id="intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Paper Title</b> is...
						</p>
					</section>
					<section id="goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							Some goals that they had.
						</p>
						<p class="rp_analysis">
							Don't forget some results, too!
						</p>
					</section>
					<section id="assumptions">
						<h2>Assumptions</h2>
					</section>
					<section id="defs">
						<h2>Definitions</h2>
						<a href="#def1"><span class="rp_definition_header">Definition 1 - </span></a>
						<p class="rp_original rp_definition">
							A definition 
						</p>
					</section>
					<section id="theorems">
						<h2>Theorems</h2>
						<p class="rp_original">Some general definitions used by several theorems</p>
						<a href="#theorem1"><span class="rp_theorem_header">Theorem 1</span></a>
						<p class="rp_original rp_theorem">
							A theorem
						</p>
					</section>
					<section id="protocol">
						<h2>Protocols</h2>
						<h3><a href="#secxx">Some Protocol Defined</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b></li>
							<li><b>Function(s): </b></li>
							<li><b>Privacy constraints: </b></li>
							<li><b>Cheating: </b></li>
							<li><b>Bits exchanged: </b></li>
							<li><b>Subprotocols: </b></li>
							<li><b>Runtime: </b></li>
							<li><b>Assumptions: </b></li>
							<li><b>Implementations: </b></li>
							<li><b>Notes: </b></li>
						</ul>
					</section>
					<section id="further">
						<h2>Further Reading</h2>
					</section>
					<section id="ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							A reference for this paper
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5" id="annotated_paper">
				<div class="main_window main_fullwidth">
					<h1>Annotated Paper (extended abstract)</h1>
					<div class="main_toc"></div>
					<section id="abstract" data-section-number="0">
						<h2>Abstract</h2>
						<p class="rp_original">
							Since the introduction of secure multiparty computation, all proposed protocols that provide security against cheating players suffer from very high communication complexities. The most efficient unconditionally secure protocols among \(n\) players, tolerating cheating by up to \(t\lt n/3\) of them, require communicating \(\operatorname O(n^6)\) field elements for each multiplication of two elements, even if only one player cheats.
						</p>
						<p class="rp_original">
							In this paper, we propose a perfectly secure multiparty protocol which requires communication \(\operatorname O(n^3)\) field elements per multiplication. In this protocol, the number of invocations of the broadcast primitive is independent of the size of the circuit to be computed. The proposed techniques are generic and apply to other protocols for robust distributed computations.
						</p>
						<p class="rp_original">
							Furthermore, we show that a subprotocol proposed in <span class="reference" data-citation="GRR98">[?]</span> for improving the efficiency of unconditionally secure multiparty computation is insecure.
						</p>
					</section>
					<section id="sec1">
						<h2>1. Introduction</h2>
						<section id="sec1.1">
							<h3>1.1. Secure Multiparty Computation</h3>
							<p class="rp_original">
								The goal of secure multiparty computation, as introduced by Yao<sup class="reference" data-citation="Yao82">[?]</sup>, is to enable a set of \(n\) players to compute an arbitrary agreed function of their private inputs. The computation must guarantee the correctness of the outputs while preserving the secrecy of the players' inputs, even if some of the players are corrupted by an active adversary and misbehave maliciously.
							</p>
							<p class="rp_original">
								As the first general solution to this problem, Goldreich, Micali, and Wigderson<sup class="reference" data-citation="GMW87">[?]</sup> presented a protocol, based on cryptographic intractability assumptions, which allows \(n\) players to securely compute an arbitrary function even if an adversary corrupts any \(t\lt n/2\) of the players. In the secure-channels model, where bilateral secure channels between every pair of players are assumed, Ben-Or, Goldwasser, and Widgerson<sup class="reference" data-citation="BGW88">[?]</sup> and independently Chaum, Cr&eacute;peau, and Damg&aring;rd<sup class="reference" data-citation="CCD88">[?]</sup> proved that unconditional security is possible if at most \(t\lt n/3\) of the players are corrupted. In a model where additionally physical broadcast channels are available, unconditional security is achievable if at most \(t\lt n/2\) players are corrupted<sup class="reference" data-citation="RB89">[?]</sup><sup class="reference" data-citation="Bea91b">[?]</sup><sup class="reference" data-citation="CCDplus99">[?]</sup>.
							</p>
						</section>
						<section id="sec1.2">
							<h3>1.2. Efficiency Considerations</h3>
							<p class="rp_original">
								All proposed multiparty protocols that provide security against misbehaving players suffer from high communication complexities. This is in sharp contrast to their private (but non-resilient) counterparts, for which reasonably efficient solutions are known<sup class="reference" data-citation="BGW88">[?]</sup>. The communication overhead of resilient multiparty protocols over private protocols is due mainly to the sophisticated techniques for achieving resilience against faults. Specifically, these techniques make extensive use of a broadcast primitive, which must be realized with a protocol for Byzantine agreement (e.g. <span class="reference" data-citation="PSL80">[?]</span><span class="reference" data-citation="DFFplus82">[?]</span><span class="reference" data-citation="FM88">[?]</span><span class="reference" data-citation="BGP89">[?]</span><span class="reference" data-citation="CW89">[?]</span>). Such protocols are very communication-intensive. The necessity of the broadcast channel is independent of whether or not actual faults occur: often broadcast is used to complain about an inconsistency, but when no inconsistency is detected, the players must nevertheless broadcast a confirmation message (the inherent information of the message is one bit). Many researchers take a broadcast channel for granted, neglecting the fact that this primitive does not exist in most realistic scenarios for distributed computing, and hence must be simulated. Broadcast is an efficiency bottleneck, in both information-theoretic and cryptographic settings; reducing the number of broadcast invocations is therefore crucial for reducing the overall communication complexity of distributed protocols.
							</p>
							<p class="rp_original">
								There is a line of research that focused on reducing the communication complexity of multiparty protocols. First, several works<sup class="reference" data-citation="BB89">[?]</sup><sup class="reference" data-citation="BMR90">[?]</sup><sup class="reference" data-citation="BFKR90">[?]</sup> concentrated on reducing the round complexity of such protocols. However, the price for the low round complexity is a substantially increased message complexity. With the current results, namely \(\operatorname O(n^6)\) field elements per multiplication, the main efficiency bottleneck seems to be the message complexity rather than the round complexity. First steps towards lower message complexities were taken in <span class="reference" data-citation="BFKR90">[?]</span>. The proposed protocol is very efficient, but it only tolerates adversaries corrupting up to \(t=\operatorname O(\log n)\) players. Protocols with optimal resilience (i.e. \(t\lt n/3\)) were proposed in <span class="reference" data-citation="FY92">[?]</span> and in <span class="reference" data-citation="GRR98">[?]</span>. Their approach is to first perform a private protocol with fault-detections (for the whole protocols in <span class="reference" data-citation="FY92">[?]</span>, and for a part of the protocol in <span class="reference" data-citation="GRR98">[?]</span>), and only in case of faults to repeat the computation with a slow but resilient protocol. Although this approach can improve the best-case complexity of the protocol (when no adversary is present), it cannot speed up the protocol in the presence of a malicious adversary: a single-corrupted player can persistently enforce the robust but slow execution, annihilating (and even inverting) any efficiency gain.
							</p>
						</section>
						<section id="sec1.3">
							<h3>1.3. Contributions</h3>
							<p class="rp_original">
								This paper significantly improves the message complexity of unconditionally secure multiparty computations, without increasing the round complexity in a relevant manner. We consider a set of \(n\) players, where up to \(t\lt n/3\) of them can be corrupted by a computationally unbounded, adaptive, active adversary. We present a protocol that allows the players to securely compute an agreed function specified as an arithmetic sircuit over a finite field \(\mathbb F\), requiring communication of \(\operatorname O(mn^3)\) field elements, where \(m\) denotes the number of multiplication gates in the circuit. The total number of invocations of the broadcast primitive in the whole protocol is only \(\operatorname O(n^2)\), independent of the circuit size.
							</p>
							<p class="rp_original">
								This is to be compared with the most efficient unconditionally secure protocol known so far, namely the protocol of Beaver<sup class="reference" data-citation="Bea91a">[?]</sup>, which requires \(\operatorname O(mn^6)\) field elements. Other protocols whose goal is to improve the message complexity of unconditionally secure multiparty protocols<sup class="reference" data-citation="FY92">[?]</sup><sup class="reference" data-citation="GRR98">[?]</sup> fail to do so in the presence of faults. The new protocol improves even on the cryptographically secure protocol<sup class="reference" data-citation="GRR98">[?]</sup>, which communicates \(\operatorname O(mn^4)\) field elements<sup class="footnote" id="fref1" data-footnote="1"><a href="#footnote1">1</a></sup> (but tolerates up to \(t\lt n/2\) corruptions). Recently, a protocol with cryptographic security for evaluating Boolean circuits was proposed in which \(\operatorname O(mn^3k)\) bits are communicated, where \(k\) is a security parameter<sup class="reference" data-citation="CDN00">[?]</sup>. The round complexities of all considered protocols are essentially equal. All stated complexities include the costs of simulating the broadcast channels by a protocol for Byzantine agreement.
							</p>
							<p class="rp_original">
								The techniques that allow this speed-up are generic and apply to many protocols for general multiparty computation as well as to special-purpose protocols, in both the cryptographic model and the information-theoretic model. One key technique is <i>player elimination</i>. In contrast to previous protocols where only evident misbehavior leads to elimination and where slowing down the protocol is still possible without being detected, we proceed more rigorously: Whenever a fault occurs (and slows down the protocol execution), a set of players which contains at least a certain number of corrupted players (but possibly also some honest ones) is identified and eliminated from the further protocol execution. This ensures that faults occur only rarely, namely at most \(t\) times during the entire computation, which in turn allows to reduce the number of consistency checks performed in the protocol: Rather than after each gate, the consistency checks are performed only after a sequence of gates, a so-called <i>segment</i>. During the entire computation, up to \(t\) segments can fail and require re-computation, but which an appropriate size of the segments, the total cost of re-computation will be much smaller than the savings due to the reduced number of the checks.
							</p>
							<p class="rp_original">
								Furthermore, we show that the very efficient protocol of <span class="reference" data-citation="GRR98">[?]</span> for the verification of equality of shared values is insecure (cf. <a href="#appendixa">App. A</a>), thus invalidating previously stated efficiency improvements.
							</p>
						</section>
						<section id="sec1.4">
							<h3>1.4. Outline</h3>
							<p class="rp_original">
								In <a href="#sec2">Section 2</a> we introduce the general framework for efficient resilient protocols. This framework is not specific for multiparty computation. The new multiparty computation protocol is described in <a href="#sec3">Section 3</a>, and its efficiency is analyzed and compared with known protocols in <a href="#sec4">Section 4</a>. Finally, some conclusions and open problems are mentioned in <a href="#sec5">Section 5</a>.
							</p>
						</section>
					</section>
					<section id="sec2">
						<h2>2. Framework for Efficient Resilient Protocols</h2>
						<section id="sec2.1">
							<h3>2.1. Introduction</h3>
							<p class="rp_original">
								Distributed protocols resilient against misbehavior of some of the players require in general much more communication than their private (but non-resilient) counterparts, even when no cheating occurs. The reasons for this contrast are two-fold: First, in a model where players might deviate from the protocol, expensive consistency checks must be performed frequently, and agreement must be reached on whether or not faults occurred. Second, if indeed at least one player misbehaves, their inconsistencies will occur, and costly fault-recovery procedures must be applies. Note that the consistency checks are necessary even when no cheating occurs, whereas fault recovery is necessary only when at least one player misbehaves.
							</p>
							<p class="rp_original">
								In this section, we describe a framework for efficient resilient protocols that overcomes these disadvantages. The key idea is to eliminate at least one malicious player (and potentially some honest players) each time a fault is detected. Hence the number of fault-recovery invocations is bounded by the maximal number of corrupted players and is independent of the length of the protocol. Furthermore, the resulting seldom occurrence of faults allows to reduce the frequency of consistency checks and thereby to significantly reduce the communication-overhead caused by them.
							</p>
							<p class="rp_original">
								The techniques presented in this section apply to many applications in several models, including those relying on intractability assumptions. The adversary can be static or adaptive, but not mobile: A mobile adversary<sup class="reference" data-citation="OY91">[?]</sup><sup class="reference" data-citation="CH94">[?]</sup> may release some of the corrupted players during the protocol execution and thereby regain the capability of corrupting new players, which contradicts the idea of elimination of corrupted players.
							</p>
						</section>
						<section id="sec2.2">
							<h3>2.2. Incorporating Resilience into a Private Protocol</h3>
							<p class="rp_original">
								We consider a private protocol that proceeds in rounds (e.g. in each round one gate is evaluated) and wish to execute this protocol in a resilient manner. In contrast to the classical approach to resilient protocols, where after each round some consistency checks are performed and agreement on whether or not a fault occurred is reached, we divide the protocol into <i>segments</i>, each consisting of a sequence of rounds, and only at the end of each segment the consistency of the data held by the players is checked and the players agree on whether or not a fault occurred (<i>fault detection</i>). If a fault is detected, then a set of players is identified which contains at least a certain number of cheaters (<i>fault localization</i>), the players in the set are eliminated from the further protocol execution (<i>player elimination</i>), and the failed segment is repeated (<i>fault correction</i>). If privacy is an issue, then after each round some checks must be performed, but no agreement must be reached on the fact whether or not a fault occurred (<i>weak fault detection</i>).
							</p>
							<p class="rp_original">
								During a protocol consisting of \(m\) rounds, the classical approach invokes \(m\) times fault detection and, if at least one player misbehaves permanently, \(m\) times fault-recovery. In our approach, where the protocol is divided into segments of \(m_s\) rounds, only the weak fault detection is invoked \(m\) times. Fault detection is performed \(m/m_s\) times, and fault localization, player elimination, and fault correction are invoked at most \(t\) times. By selecting \(m_s\) appropriately, the overhead for the (in total up to \(t\)) repetitions of a segment will not dominate the total complexity of the protocol, and the costs of fault detection and fault localization are independent of \(m\) (and polynomial in \(n\)). In many applications, this will significantly reduce the overall complexity of the protocol.
							</p>
							<p class="rp_original">
								We now describe the steps in more detail:
							</p>
							<ol class="rp_original">
								<li><b>Private computation with weak fault detection</b>. All rounds of the segment are computed according to the private computation. The computation of this step must be <i>verifiable</i>, i.e. it must be possible to check later (see below) whether or not any faults occurred. However, <i>robustness</i> is not required, i.e. if faults occur, then the computation may fail (in such a case it must be possible to perform an appropriate fault localization, see below). In order to preserve privacy even in case of faults, consistency checks are performed after each round, and every player sends to every other player one bit indicating whether or not he observed an inconsistency. A player who observed or was informed about an inconsistency will use default (random) dummy values unrelated to the actual values in all further rounds of the segment.</li>
								<li><b>Fault detection</b>. The goal of fault detection is to reach agreement on whether or not a fault occurred during the current segment. Typically, fault detection is achieved by having every player broadcast (with a protocol for Byzantine agreement) a binary message according to whether or not he observed or was informed about an inconsistency in any round of the current segment, and a fault is detected if at least one player complains. The following steps 3. to 5. are performed if and only if a fault is detected.</li>
 								<li><b>Fault localization</b>. The purpose of fault localization is to find out which players are corrupted or, because agreement about this can usually not be reached, at least to narrow down the set of players containing the cheaters. The output of fault localization is a set \(\mathcal D\) with \(|\mathcal D| = p\) players, guaranteed to contain at least \(r\) cheaters, denoted as \((r, p)\)-<i>localization</i>.</li>
								<li><b>Player elimination</b>. The set \(\mathcal D\) agreed upon during fault localization is eliminated from the further computation. In general, after eliminating the players in \(\mathcal D\), the protocol cannot be continued immediately, but it must be transformed to capture the new setting with \(n−p\) players and at most \(t−r\) cheaters.</li>
								<li><b>Fault correction</b>. Since some players are eliminated whenever a fault is detected, faults can be corrected simply by repeating the current segment of the protocol.</li>
							</ol>
						</section>
					</section>
					<section id="sec3">
						<h2>3. Constructing Efficient Multiparty Computation Protocols</h2>
						<p class="rp_original">
							In this section we present a construction of efficient multi-party computation protocols in the secure-channels model, based on the framework with player-elimination from the previous section. We first formally define the considered model, then we describe the main (top-level) protocol and finally all required sub-protocols.
						</p>
						<section id="sec3.1">
							<h3>3.1. Model</h3>
							<p class="rp_original">
								We consider the well-known secure-channels model as used in <span class="reference" data-citation="BGW88">[?]</span><span class="reference" data-citation="CCD88">[?]</span>: The set \(\mathcal P = \{P_1,\dots,P_n\}\) of \(n\) players is connected by bilateral synchronous reliable secure channels. Broadcast channels are not assumed to be available. The goal of the protocol is to compute an agreed function, specified as an arithmetic circuit over a finite field \(\mathbb F\) with \(|\mathbb F|\gt n\). The number of inputs to the circuit is denoted by \(n_I\), the total number of outputs by \(n_O\),<sup class="footnote" id="fref2" data-footnote="2"><a href="#footnote2">2</a></sup> the number of multiplication gates in the circuit by \(m\), and the multiplicative depth by \(d\) (i.e. the maximal number of multiplication gates in any path of the circuit). To each player \(P_i\) a unique public value \(\alpha_i\in\mathbb F\backslash\{0\}\) is assigned. There are no further assumptions about the field.<sup class="footnote" id="fref3" data-footnote="3"><a href="#footnote3">3</a></sup> The computation of the function must be secure with respect to a computationally unbounded adaptive active adversary who can corrupt up to \(t\) of the players, where \(t\) is a given threshold with \(t\lt n/3\). Once a player is corrupted, the adversary can read all his information and can make the player misbehave arbitrarily. The security of our protocol is perfect, i.e. unconditional with zero failure probability. Formal definitions of security can be found in <span class="reference" data-citation="Can00">[?]</span> and in <span class="reference" data-citation="MR98">[?]</span>, and our protocol is secure for any of these definitions.
							</p>
							<p class="rp_original">
								To simplify the presentation, we adopt the following convention throughout the description of the protocols: Unless otherwise stated, whenever a player does not receive an expected message, or receives a malformed message, then a default value for this message is taken.
							</p>
						</section>
						<section id="sec3.2">
							<h3>3.2. Main Protocol</h3>
							<p class="rp_original">
								The protocol follows the classical approach for secure multi-party computation: First, each player secret-shares his input(s) among the players. Second, the circuit is evaluated with the shared values. Third, the output value(s) are reconstructed towards the authorized players.
							</p>
							<p class="rp_original">
								According to the framework from <a href="#sec2">Section 2</a>, the circuit will be divided into segments. If the evaluation of a segment fails, then some players are eliminated and the segment is repeated. Clearly, <i>all</i> players must be able to provide input and receive output, including players that are eliminated in the protocol evaluation (also honest players can be eliminated). This is achieved by using a resilient protocol (which does not make use of the player-elimination technique) for sharing input values. No special measures are necessary for receiving output, because the secret-reconstruction protocol can also be performed towards an eliminated player (this player only receives values and cannot cause inconsistencies).
							</p>
							<span class="rp_sub_header">Sharing</span>
							<p class="rp_original rp_sub">
								The sharing is based on Shamir's secret-sharing scheme<sup class="reference" data-citation="Sha79">[?]</sup>, extended to a two-dimensional sharing<sup class="reference" data-citation="GHY87">[?]</sup><sup class="reference" data-citation="BGW88">[?]</sup><sup class="reference" data-citation="CCD88">[?]</sup><sup class="reference" data-citation="RB89">[?]</sup><sup class="reference" data-citation="FHM98">[?]</sup>. Each value is shared among the players with a polynomial of degree \(t\), and each share is again shared among the players with a polynomial of degree \(t\). Formally, a value \(s\) is \(t\)-shared among the players if there exist degree-\(t\) polynomials \(f\) and \(f_1,\dots,f_n\) with \(s = f(0)\) and \(f_i(0) = f(\alpha_i)\). The information held by player \(P_i\) is the share \(s_i = f(\alpha_i)\), the polynomial \(f_i\), and the share-shares \(s_{ji} = f_j(\alpha_i)\) (for \(j=1,\dots,n\)). The polynomials in the sharing must be randomly chosen such that any set of \(t\) players does not obtain any information about the secret.
							</p>
							<span class="rp_sub_header">Segmentation</span>
							<p class="rp_original rp_sub">
								Due to the linearity of the secret-sharing scheme, linear functions of shared values can be computed non-interactively, and hence only multiplication gates are relevant for the communication complexity. In order to partition the circuit with \(m\) multiplication gates and multiplicative depth \(d\) into segments, we select an ordering of the gates which satisfies the partial order defined by the circuit (i.e., the inputs of the \(i\)th gate must be provided by gates with index smaller than \(i\)). Every segment consists of a number of consecutive gates, subject to the following bounds:
							</p>
							<ul class="rp_original rp_sub">
								<li>the number \(m_s\) of multiplication gates in each segment is at most \(\lceil m/n\rceil\),</li>
								<li>the multiplicative depth \(d_s\) of each segment is at most \(\lceil d/n\rceil\).</li>
							</ul>
							<p class="rp_original rp_sub">
								Furthermore, in every segment (except the last) at least one of the above bounds is satisfied with equality, hence the total number of segments is smaller than \(2n\).
							</p>
							<p class="rp_original rp_sub">
								At the end of every segment, fault detection is performed and agreement is reached on whether or not a fault occurred within the segment. If no fault occurred, then the computation of this segment is completed, and the next segment is started. If a fault is detected, then a (1, 2)-localization \(\mathcal D\subset\mathcal P\) will be found and eliminated (we will not consider other types of localizations), and the evaluation of the segment is repeated. During the whole circuit evaluation, at most \(t\) segments fail. The described segmentation guarantees that the repeated computation will not dominate the overall protocol complexity, neither in terms of the number of communicated bits nor in terms of the number of communication rounds.
							</p>
							<span class="rp_sub_header">Protocol Overview</span>
							<p class="rp_original rp_sub">
								Let \(\mathcal P\) denote the set of players, where \(n=|\mathcal P|\), and \(t\lt n/3\) the upper bound on the number of cheaters. During the computation, players can be eliminated, and then \(\mathcal P'\) will deote the set of remaining players, \(n'=|\mathcal P'|\), and \(t'\) the upper bound on the number of cheaters in this set.
							</p>
							<ol class="rp_original">
								<li value="0">Set \(\mathcal P':=\mathcal P,\,n':=m,t'=t\).</li>
								<li>Input stage: Every player \(P\) providing input secret-shares his input value (<a href="#sec3.3">Section 3.3</a>).</li>
								<li>
									Computation stage (<a href="#sec3.4">Section 3.4</a>): For each segment of the circuit:
									<ol>
										<li>
											For each gate in the segment (all gates at the same level can be evaluated in parallel):
											<ul>
												<li>If the gate is linear: Call the sub-protocol for the evaluation of linear functions.</li>
												<li>If the gate is a multiplication gate: Call the multiplication sub-protocol. Players that have detected (or were notified about) a fault earlier in this segment use default shares.</li>
											</ul>
										</li>
										<li>For each \(P_i\in\mathcal P'\), broadcast one bit according to whether or not a fault was observed (or notified) in the segment. If at least one player reports a fault, then the segment fault-localization procedure is invoked to find a (1, 2)-localization \(\mathcal D\), and \(\mathcal P'\) is set to \(\mathcal P'\backslash\mathcal D,\,t'\) is set to \(t' − 1\), and step 2. is restarted (for the same segment).</li>
									</ol>
								</li>
								<li>Output stage: For every player P that is to receive output: Call the sub-protocol for receiving output (<a href="#sec3.5">Section 3.5</a>).</li>
							</ol>
						</section>
						<section id="sec3.3">
							<h3>3.3. Input Stage</h3>
							<p class="rp_original">
								In the input stage, every player secret-shares his input(s). Let \(\mathcal P\) be the set of players, at most \(t\) of which are corrupted and let \(P\) be a designated dealer holding an input \(s\). The protocol for providing \(s\) as input is a variation of the verifiable secret-sharing (VSS) protocol of Ben-Or, Goldwasser, and Wigderson<sup class="reference" data-citation="BGW88">[?]</sup>:
							</p>
							<ol class="rp_original">
								<li><span class="main_language">Distribution</span> The dealer \(P\) selects at random a polynomial \(p(x,y)=\sum\nolimits_{i,j=0}^tr_{ij}x^iy^j\) of degree \(t\) in both variables, where \(p(0,0)=s\), and sends the polynomials \(f_i(x)=p(x,\alpha_i)\) and \(\widetilde{f_i}(y)=p(\alpha_i,y)\) to player \(P_i\) (for \(i=1,\dots,n)\).<sup class="footnote" id="fref4" data-footnote="4"><a href="#footnote4">4</a></sup> This implicitly defines the polynomial \(f(x)=p(0,x)\).</li>
								<li><span class="main_language">Consistency Checks</span> Each pair of players \(P_i,P_j\) (for \(1\leq i,j\leq n\)) checks whether \(f_i(\alpha_j)\stackrel?=\widetilde{f_j}(\alpha_i)\). For this, \(P_i\) sends \(f_i(\alpha_j)\) to \(P_j\), and \(P_j\) checks whether the received value is equal to \(\widetilde{f_j}(\alpha_i\).</li>
								<li><span class="main_language">Complaint Stage</span> Every player broadcasts a message (containing one bit) indicating whether all consistency checks were successful or at least one test failed. In case of a complaint, the player afterwards broadcasts a bit-vector, where the \(j\)th bit indicates whether or not the player has observed an inconsistency with player \(P_j\). The dealer answers the complaints by broadcasting the corresponding correct values.</li>
								<li><span class="main_language">Accusation Stage</span> If a player \(P_j\) observes more than \(t\) inconsistencies or discovers that the dealer's answers contradict his own values, he broadcasts an accusation. In such a case the dealer broadcasts both polynomials \(f_j(x)\) and \(\widetilde{f_j}(y)\). The published polynomials can cause some new inconsistencies with the values held by some other players, who react again with accusations, and so on.<sup class="footnote" id="fref5" data-footnote="5"><a href="#footnote5">5</a></sup> If more than \(t\) players have accused, or if the dealer did not answer all the complaints and accusations, a default sharing (e.g. the constant sharing of 0) is taken.</li>
							</ol>
							<p class="rp_original">
								In the protocol of <span class="reference" data-citation="BGW88">[?]</span>, the share of player \(P_i\) is \(s_i = f(\alpha_i) = f_i(0)\), and the second dimension of the sharing is not used. In our scheme, the share of player \(P_i\) is the polynomial \(f_i\) (and in particular \(s_i = f_i(0)\)), as well as the share-shares \(s_{ji} = \widetilde{f_i}(\alpha_j) = p(\alpha_i, \alpha_j)\) (for \(j = 1,\dots,n\)).
							</p>
							<p class="rp_original">
								In order to analyze the security of this secret-sharing protocol we distinguish two cases: (a) If the dealer is honest, all shares and share-shares of honest players will be consistent, and only values held by corrupted players can be published. No honest player will accuse the dealer, hence there will be at most \(t\) accusations. Clearly, in this case the outcome will be a proper \(t\)-sharing. (b) If the dealer is corrupted, then at the end of the protocol (if there were not more than \(t\) accusations) the cross-over points of all honest players are consistent, and their share-shares uniquely define a two-dimensional polynomial \(p_0(x, y)\), satisfying the conditions for a proper \(t\)-sharing. If there were more than \(t\) accusations, then at least one of the accusations origins from an honest player, and indeed the dealer is cheating. In this case it is legitimate to take some default value as the dealer's secret.
							</p>
						</section>
						<section id="sec3.4">
							<h3>3.4. Computation Stage</h3>
							<p class="rp_original">
								The computation of the circuit proceeds segment by segment. We denote the current set of players with \(\mathcal P'\), where \(n' = |\mathcal P'|\), and the current upper bound on the number of cheaters in \(\mathcal P'\) with \(t'\). Without loss of generality, we assume that \(\mathcal P' = \{P_1,\dots,P_{n'}\}\). A segment is computed as follows: First, the gates of the segment are computed. Linear functions can be computed robustly (as no communication is needed). In contrast, the computation of multiplication gates is private and verifiable, but not robust. At the end of each multiplication sub-protocol, the (honest) players inform each other in a weak fault detection procedure whether or not they observed an inconsistency. If a player observed such an inconsistency, or was informed about one in weak fault detection, then he continues the computation of the segment with default values independent of the actual shares. At the end of each segment, fault detection is performed and, if necessary, fault localization, player elimination and fault correction.
							</p>
							<section id="sec3.4lin">
								<h4>Linear Functions</h4>
								<p class="rp_original">
									Let \(\mathcal L\) be a linear function, and assume that the values \(a,b,\dots\) are \(t\)-shared with polynomials \(f, f_1,\dots,f_{n'},\;g,g_1,\dots,g_{n'},\;\dots,\), respectively. Due to the linearity of \(\mathcal L\), the polynomials \(h = \mathcal L(f, g,\dots)\) and \(h_i =\mathcal L(f_i, g_i,\dots)\) define a \(t\)-sharing of \(c =\mathcal L(a, b,\dots)\). Hence, player \(P_i\) can compute his share of \(c\) as \(h_i = \mathcal L(f_i, g_i,\dots)\) and \(c_{ji} =\mathcal L(a_{ji}, b_{ji},\dots)\) (for \(j = 1,\dots,n'\)). The privacy of this protocol is trivial (there is no communication), and the correctness is due to the linearity of the sharing.
								</p>
							</section>
							<section id="sec3.4mult">
								<h4>Multiplication</h4>
								<p class="rp_original">
									The crucial sub-protocol for multiplication is a re-sharing protocol. A re-sharing protocol is a protocol that takes a degree- sharing of a value \(s\) and generates an independent degree-\(\delta\) sharing of \(s\). This re-sharing is possible in a verifiable (but non-robust) manner if \(t'\lt n'−\gamma\). Privacy can be guaranteed if \(t'\leq\gamma\) and \(t'\leq\delta\).
								</p>
								<p class="rp_original">
									The protocol for computing the \(t\)-shared product \(c\) of two \(t\)-shared values \(a\) and \(b\) proceeds in three steps: First, both inputs \(a\) and \(b\) are re-shared with degree \(t'\). Second, every player locally multiplies his respective shares and share-shares of \(a\) and \(b\), resulting in a degree-\(2t'\) sharing of \(c\). And third, this degree-\(2t'\) sharing of \(c\) is re-shared to a degree-\(t\) sharing.
								</p>
								<p class="rp_original">
									We have to show that the necessary (and sufficient) conditions for all re-sharings are satisfied: After a sequence of \(k\) (1,2)-localizations and eliminations, we have \(n'=n-2k\) and \(t'=t-k\). The requirements for the re-sharing are \(t'\lt n'-t\) and \(t'\lt n'-2t'\), and both are satisfied for \(3t\lt n\).
								</p>
								<span class="rp_sub_header">Re-sharing Protocol</span>
								<p class="rp_original rp_sub">
									The goal of re-sharing is to transform a \(\gamma\)-sharing of a value \(s\) into a proper and independent \(\delta\)-sharing of \(s\), where \(t'\lt n'-\gamma,\,t'\leq\gamma\) and \(t'\leq\delta\). The re-sharing sub-protocol can fail in the presence of malicious players. However, if it fails, all (honest) players will learn so, and at the end of the segment, agreement on whether or not such a fault occurred will be reached and the segment will be repeated if necessary.
								</p>
								<p class="rp_original rp_sub">
									Roughly speaking, our re-sharing protocol works along the lines of degree reduction of <span class="reference" data-citation="BGW88">[?]</span><span class="reference" data-citation="GRR98">[?]</span>, but it is significantly more efficient, due to various techniques in the spirit of the player-elimination framework (cf. <a href="#sec2">Section 2</a>.
								</p>
								<p class="rp_original rp_sub">
									Assume that \(s\) is \(\gamma\)-shared with the polynomials \(f\) and \(f_1,\dots,f_{n'}\), and player \(P_i\) holds the polynomial \(f_i(x)\) (hence his share \(s_i = f_i(0)\)), and his share-shares \(s_{ji} = f_j(\alpha_i)\) (for \(j = 1,\dots, n'\)). The value \(s\) can be expressed as a linear combination (Lagrange interpolation) of the values \(s_1,\dots,s_{n'}\)<sup class="reference" data-citation="BGW88">[?]</sup><sup class="reference" data-citation="GRR98">[?]</sup>. Therefore, once the values \(s_1,\dots,s_{n'}\) are \(\delta\)-shared, the required \(\delta\)-sharing of \(s\) can be computed by a distributed evaluation of the appropriate linear function (as described in <a href="#sec3.4">Section 3.4</a>). Thus, the re-sharing can be performed as follows: Every player \(\delta\)-shares his share \(s_i\), proves that the shared value is indeed \(s_i\), and computes his degree-\(\delta\) share of \(s\) as a linear combination of the received shares of \(s_1,\dots,s_{n'}\).
								</p>
								<p class="rp_original rp_sub">
									We describe the steps in more detail:
								</p>
								<ol class="rp_original">
									<li>
										<span class="main_language">Non-robust VSS</span> Every player \(P_i\) shares his share \(s_i\) with the degree-\(\delta\) polynomials \(h^{(i)}, h^{(i)}_1,\dots, h^{(i)}_{n'}\) in a non-robust but verifiable manner. The protocol works like the first two steps of the VSS in the input stage (<a href="#sec3.3">Section 3.3</a>):
										<ol type="a">
											<li>\(P_i\) selects at random a polynomial \(p^{(i)}(x,y)\) of degree \(\delta\) in both variables, where \(p^{(i)}(0,0)=s_i\), and sends the polynomials \(h_j^{(i)}(x)=p^{(i)}(x,\alpha_i)\) and \(\tilde h_j^{(i)}(y)=p^{(i)}(\alpha_j,y)\) to player \(P_j\) (for \(j=1,\dots,n'\)). This implicitly defines the polynomial \(h^{(i)}(x)=p^{(i)}(0,x)\).</li>
											<li>Each pair of players \(P_j,P_k\) (for \(1\leq j,j\leq n'\)) verifies the equality of their common shares. For this, \(P_j\) sends \(h_j^{(i)}(\alpha_k)\) to \(P_k\), who then checks whether the received value is equal to \(\tilde h_j^{(i)}(\alpha_j)\)</li>
										</ol>
									</li>
									<li>
										<span class="main_language">Proving Correctness.</span> Every player \(P_i\) proves that \(h^{(i)}(0)=f_i(0)\) by showing that the free coefficient of the polynomial \(h^{(i)}(0)-f_i(x)\) is equal to zero. This is done in two steps:
										<ol type="a">
											<li>Let \(mu=\operatorname{max}(\gamma,\delta).\,P_i\) computes the polynomial \(g^{(i)}(x):=(h^{(i)}(x)-f_i(x))/x\) (whose degree is at most \(\mu-1\)), and distributes the shares on \(g^{(i)}\) among the players. For this purpose the non-robust VSS protocol from Step 1 is used, where the corresponding two-dimensional polynomial, say \(q^{(i)}(x,y)\), is chosen randomly, but such that \(q^{(i)}(0,x)=g^{(i)}(x)\).</li>
											<li>Every player \(P_k\) checks whether \(\alpha_kg^{(i)}(\alpha_k)=h^{(i)}(\alpha_k)-f_i(\alpha_k)\).</li>
										</ol>
									</li>
								</ol>
							</section>
						</section>
					</section>
				</div>
            </div>
			<div class="main_toplevel main_section main_color7" id="footnotes">
                <h1>Footnotes</h1>
				
                <ol id="footnotes">
                    <li id="footnote1">
						<a href="#fref1">[^]</a> In this protocol, the field must be large for security reasons.
					</li>
					<li id="footnote2">
						<a href="#fref2">[^]</a> \(n_O\) specifies the total number of outputs&mdash;if the same value is given as output to several players, then this value is counted several times.
					</li>
					<li id="footnote3">
						<a href="#fref3">[^]</a> This is contrast to the protocol in <span class="reference" data-citation="BGW88">[?]</span>, where the existence of an \(n\)th <span class="definable">root of unity</span> in \(\mathbb F\) is assumed.
					</li>
					<li id="footnote4">
						<a href="#fref4">[^]</a> An efficiency gain of a factor 2 can be achieved by setting \(r_{ij} = r_{ji}\), and hence \(f_i(x) = \widetilde{f_i}(x)\). One can prove that privacy is not violated by this technique. See <span class="reference" data-citation="CDM00">[?]</span> for more details.
					</li>
					<li id="footnote5">
						<a href="#fref5">[^]</a> One can show that two rounds of accusations are sufficient to reach agreement. After two rounds of accusations, either the total number of accusations exceeds \(t\), or all accusations in the second round originate from corrupted players.
					</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color8" id="references">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="citation1">A citation</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+20@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Created by Nicolas Schank 2014, Brown University</p>
				<p>All original work is free for any use by anyone whatsoever.</p>
				<p>For more information about liability and licensing of the original paper, see <a href="../liability.html">Liability</a>.</p>
            </div>
        </div>
    </body>
</html>
<!--
1. Save template page
2. Set hasPage to true
3. Change 20 to number in email and pdf
4. Transcribe paper
5. References
6. Annotate paper
	7.0. proofread
	7.1. copy assumptions
	7.2. copy theorems
	7.3. copy definitions
	7.4. mark definitions
	7.5. mark equations
	7.6. link to previous research
7. Write protocol descriptions 
8. Check previous research for places to link
9. Write intro, goals, results
10. Tags
11. Consider implementations
12. Find reference
-->