<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Verifiable Secret Sharing and Multiparty Protocols with Honest Majority - Rabin, Ben-Or, 1989</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
		<script type="text/javascript" src="../../script/toc.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					default:
						return "No info on this equation yet.";
				}
			}

			function authorLink(ref)
			{
				switch (ref)
				{
					default:
						return "#";
				}
			}

			self_def["non-general word"] = "definition";
			//-->
        </script>
    </head>
    <body>
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1" id="overview">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth" id="_A">
                    <div class="rp_linkbox"><a href="pdf/76.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">Verifiable Secret Sharing and Multiparty Protocols with Honest Majority</span>
                    <span class="rp_info">1989
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/Tal Rabin.html">Tal Rabin</a>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/Michael Ben-Or.html">Michael Ben-Or</a>
					</span>
					
					<div class="rp_snippet">
						&ldquo;&rdquo;
					</div>
						
                    <div class="main_toc"></div>
					
					<h1>Overview</h1>	
                    <section id="intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Paper Title</b> is...
						</p>
					</section>
					<section id="goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							Some goals that they had.
						</p>
						<p class="rp_analysis">
							Don't forget some results, too!
						</p>
					</section>
					<section id="assumptions">
						<h2>Assumptions</h2>
					</section>
					<section id="defs">
						<h2>Definitions</h2>
						<a href="#def1"><span class="rp_definition_header">Definition 1 - </span></a>
						<p class="rp_original rp_definition">
							A definition 
						</p>
					</section>
					<section id="theorems">
						<h2>Theorems</h2>
						<p class="rp_original">Some general definitions used by several theorems</p>
						<a href="#theorem1"><span class="rp_theorem_header">Theorem 1</span></a>
						<p class="rp_original rp_theorem">
							A theorem
						</p>
					</section>
					<section id="protocol">
						<h2>Protocols</h2>
						<h3><a href="#secxx">Some Protocol Defined</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b></li>
							<li><b>Function(s): </b></li>
							<li><b>Privacy constraints: </b></li>
							<li><b>Cheating: </b></li>
							<li><b>Bits exchanged: </b></li>
							<li><b>Subprotocols: </b></li>
							<li><b>Runtime: </b></li>
							<li><b>Assumptions: </b></li>
							<li><b>Implementations: </b></li>
							<li><b>Notes: </b></li>
						</ul>
					</section>
					<section id="further">
						<h2>Further Reading</h2>
					</section>
					<section id="ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							A reference for this paper
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5" id="annotated_paper">
                <div class="main_window main_fullwidth">
					<h1>Annotated Paper</h1>
                    <div class="main_toc"></div>
					<section id="abstract">
						<h2>Abstract</h2>
						<p class="rp_original">
							Under the assumption that each participant can broadcast a message to all other participants and that each pair of participants can communicate secretly, we present a verifiable secret sharing protocol, or game with complete information, can be achieved if a majority of the players are honest. The secrecy achieved is unconditional and does not rely on any assumption about computational intractability. Applications of these results to Byzantine Agreement are also presented.
						</p>
						<p class="rp_original">
							Underlying our results is a new tool of Information Checking which provides authentication without cryptographic assumptions and may have wide applications elsewhere.
						</p>
					</section>
                    <section id="sec1">
                        <h2>1. Introduction</h2>
						<p class="rp_original">
							Comparing the recent unconditional results on multiparty protools of Ben-Or, Goldwasser, and Widgerson<sup class="reference" data-citation="BGW">[?]</sup> and of Chaum, Cr&eacute;peau, and Damg&aring;rd<sup class="reference" data-citation="CCD">[?]</sup>, to the previous cryptographic results of Goldreich, Micali, and Wigderson<sup class="reference" data-citation="GMW">[?]</sup>, based on the existence of secure trapdoor functions, we find the following: On the one hand, the cryptographic results are stronger since they require only a majority of the \(n\) participating players to be honest, while the unconditional results require that more than \(\frac{2n}3\) of the players be honest. One the other hand, the unconditional results are both simpler and stronger since their security is "Information Theoretic" and does not depend on any assumptions about computational intractability. Moreover, the results of <span class="reference" data-citation="BGW">[?]</span> with up to \(t\leq\frac n 3\) faulty players guarantee absolute correctness of the results, and do not allow even an exponentially small probability of error. Such exponentially small errors are inherent to any cryptographic result based on trapdoor functions.
						</p>
						<p class="rp_original">
							The one third limit on the number of unreliable participants in the unconditional results mentioned above is necessary since otherwise even Byzantine agreement is impossible It is natural to ask, however, what can be done if we ensure agreement by assuming the existence of a broadcast channel? Likewise, by <span class="reference" data-citation="D">[?]</span>, Byzantine agreement is still possible in incomplete networks with \(2t+1\) connectibity and we can ask what multiparty protocols can be achieved under these conditions.
						</p>
						<p class="rp_original">
							To understand why a broadcast channel doesn't seem to help that much, we note a theorem of <span class="reference" data-citation="BGW">[?]</span> stating that the absolutely errorless results <i>cannot</i> be extended to tolerate \(t\geq\frac n 3\) faulty players even with a broadcast channel. Moreover, as stated informally in <span class="reference" data-citation="CCD">[?]</span>, the broadcast channel does not allow an absolutely errorless solution even to the Verifiable Secret Sharing problem (VSS) with \(t\geq\frac n 3\) faulty players. We formally prove here that any solution must allow some error probability \(\epsilon\gt0\), though \(\epsilon\) may be only exponentially small (deleted from this extended abstract). Since the VSS protocol is an essential component of any secure multiparty protocol these negative results led many researchers to conjecture that some cryptographic assumptions are indeed needed to handle \(t\) faulty players for \(\frac n 3\leq t\lt\frac n 2\), even with a broadcast channel.
						</p>
						<p class="rp_original">
							In a similar way, the VSS protocols of <span class="reference" data-citation="CCD">[?]</span> and <span class="reference" data-citation="BGW">[?]</span> were used by Feldman and Micali<sup class="reference" data-citation="FM">[?]</sup> and Feldman<sup class="reference" data-citation="F">[?]</sup> to achieve constant expected time non-cryptographic Byzantine agreement protocols in the synchronous and asynchronous cases respectively. Here again there are some intriguing gaps. In the synchronous case assuming a complete communication network, the protocols of <span class="reference" data-citation="FM">[?]</span> can tolerate up to \(t\lt\frac n 3\) faulty players, but leave the general network case to cryptographic protocols. In the asynchronous case the non-cryptographic solution of <span class="reference" data-citation="F">[?]</span> allows only \(t\lt\frac n4\) faulty players and relies on cryptographic VSS protocols to handle up to \(t\lt\frac n3\) faults. Feldman has also raised the conjecture that \(t\lt\frac n4\) is the limit for any unconditional asynchronous VSS protocol.
						</p>
						<p class="rp_original">
							The main results of this paper close most of these gaps. We show
						</p>
						<span class="rp_theorem_header">Main Theorem:</span>
						<p class="rp_original rp_theorem">
							Assuming the existence of a broadcast channel and private communication channels between each pair of \(n\) players, there exists a (poly-time) Verifiable Secret Sharing protocol tolerating up to \(t\lt\frac n2\) fault players. The secrecy achieved is unconditional, and the probability of error is exponentially small.
						</p>
						<p class="rp_original">
							A new and very practical idea of <i>Information Checking</i> is introduced in this paper. Information Checking is what enables our solution, and it may have wide applications elsewhere. It is a non-cryptographic weaker version of Digital Signatures. Weaker in the sense that not all securities provided by Digital Signatures are supplied by Information Checking, but it gives exactly the right amount of authentication power we need.
						</p>
						<p class="rp_original">
							As a simply application of our information checking technique we show, (Compare Tompa and Woll <span class="reference" data-citation="TW">[?]</span>),
						</p>
						<span class="rp_theorem_header">Theorem 1: VSS with Honest Dealer</span>
						<p class="rp_original rp_theorem">
							Let \(n\geq2t+1\). Assuming only secure communication channels between each pair of \(n\) players (without broadcast), an honest dealer can distribute a secret such that (a) no set of \(t\) players has any information about the secret and (b) any set of players containing at least \(t+1\) honest players will be able to reveal the correct secret, with only an exponentially small probability of error.
						</p>
						<p class="rp_original">
							We mention some further applications of these results to incomplete communication networks (without broadcast capability). Let \(G\) be a synchronous communication network of \(d\) processors. In <span class="reference" data-citation="D">[?]</span>, Dolev established necessary and sufficient conditions for the existence of non-cryptographic Byzantine Agreement protocols tolerating up to \(t\) Byzantine faults on G. Namely, that \(n\geq3t+1\), and that the connectivity of \(G\) is at least \(2t+1\). The following theorem extends the fast Byzantine agreement protocols of <span class="reference" data-citation="FM">[?]</span> to incomplete synchronous networks satisfying Dolev's conditions.
						</p>
						<span class="rp_theorem_header">Theorem 2:</span>
						<p class="rp_original rp_theorem">
							Let \(G\) be a synchronous network of \(n\geq3t+1\) processors, with connectivity at least \(2t+1\), and diameter \(d=d(G)\), that provides private and secure communication links between processors that are directly connected by \(G\), then there is an \(O(d)\) expected time randomized Byzantine agreement protocol on \(G\) tolerating up to \(t\) Byzantine faults.
						</p>
						<p class="rp_original">
							Similarly, Dolev's conditions are sufficient for general multiparty protocols. Extending the complete network results of <span class="reference" data-citation="BGW">[?]</span> and <span class="reference" data-citation="CCD">[?]</span> we have<sup><a href="#footnote1">1</a></sup>
						</p>
						<span class="rp_theorem_header">Theorem 3:</span>
						<p class="rp_original rp_theorem">
							Let \(G\) be a communication network between \(n\) players satisfying the conditions of theorem 2, then any multiparty protocol can be achieved on \(G\) if at most \(t\) of the players are faulty. Here again, the secrecy achieved is unconditional, and the probability of error is exponentially small.
						</p>
						<p class="rp_original">
							Our main theorem on VSS using the broadcast channel provides the necessary building block for general multiparty protocols under the same conditions. The next theorem provides the most important application of the main theorem, and it provides a strictly stronger result than the previous cryptographic results.
						</p>
						<span class="rp_theorem_header">Theorem 4:</span>
						<p class="rp_original rp_theorem">
							Assuming that each participant can broadcast a message to all other participants and that each pair of participants can communicate secretly any multiparty protocol, or game with incomplete information, can be achieved if a majority of the players are honest.
						</p>
						<span class="rp_sub_header">Remark:</span>
						<p class="rp_original rp_sub">
							It is important to note that Theorem 4 only guarantees that a set of up to \(t\lt\frac n2\) fault players cannot gain any additional information or disrupt the computation. As in all the previous results, it cannot prevent the bad players from sending all the information they are holding to some honest player. Likewise, if among three players one of the players is faulty and stops sending messages, no further secrecy conditions are imposed on the other two honest players left. Therefore, they can exchange all their input information between them and complete the computation. This last example may seem quite puzzling. It is therefore natural to add to the requirements on our protocols that any honest player alone will not hold any additional information (not following from the information in his hands together with the fault players). This last condition can easily be guaranteed if \(n\gt2(t+1)+1\) by protecting our computation from coalitions of size \(t+1\) instead of \(t\).
						</p>
						<p class="rp_original">
							Our results demonstrate the importance of the "Information Checking" idea and we expect this idea to have wide applications. One such possible application is a &frac13;-resilient non-cryptographic Asynchronous Byzantine Agreement protocol. Using our information checking we can present such a solution only under a weaker model of adversary, leaving this important question open.
						</p>
						<p class="rp_original">
							This extended abstract is a combination of two separate papers. The Main Theorem, Theorem 1, and the Information Checking protocol are the main results of Tal Rabin's Master Thesis written under the supervision of Michael Ben-Or<sup class="reference" data-citation="RT">[?]</sup>. The other results are mentioned above are from <span class="reference" data-citation="B">[?]</span>.
						</p>
						<section id="sec1.1">
							<h3>1.1. The Model of Computation</h3>
							<p class="rp_original">
								In our model of computation we assume a complete synchronous network together with a broadcast channel. The pairwise communication channels between participants are secure, that is, they cannot be read of tampered with by other participants. The broadcast channel enables each participant to send the same message to all participants, it identifies the sender, and it is completely reliable. In particular, if any participant receives a message via the broadcast channel all other players will receive the same message.
							</p>
							<p class="rp_original">
								We assume two types of players: <i>knights</i> - Honest players or dealers who do not disclose any of the information in their hands, and follow all protocols and, <i>knaves</i> - Fault players or dealers who do as they wish. They may pass incorrect information, or decide to withhold. It is also assumed that all knaves may collaborate and pool their information together. Knaves may have unlimited computing capabilities.
							</p>
							<p class="rp_original">
								We postulate a <i>dynamic adversary</i> who, at any time during a protocol, and having seen all public may choose which additional players will turn into knaves. The total number of players who are knaves is bounded by \(t\). In addition, the dealer may also be a knave.
							</p>
							<p class="rp_original">
								We choose a security parameter \(k\), so that \(2^{-k}\) is deemed a small enough error margin for our needs. Our protocols will be randomized in the sense that no matter what the adversary and the knaves will do, the probability of an error, i.e. improper outcome, will be smaller than \(2^{-k}\). All of our protocols and algorithms will be polynomial in the number of players \(n\), and in \(k\).
							</p>
						</section>
						<section id="sec1.2">
							<h3>1.2. The Information Checking Protocol</h3>
							<p class="rp_original">
								We now proceed to describe a simple process, which will be used later on to solve the Verifiable Secret Sharing Problem. This process enables us to carry out authentication of information. It is not as powerful as Digital Signatures, but on the other hand it needs no cryptographic assumptions.
							</p>
							<p class="rp_original">
								There are 3 participants in the process: (1) \(D\)-dealer, ho holds a data \(s\), (2) \(INT\)-an intermediary, who is to receive \(s\) from \(D\), and who at a later time may wish to pass it on to, (3) \(R\) - the recipient. The player \(R\) is said to <i>accept</i> \(s\), if he believes that this value originated with \(D\). We wish that the protocol of acceptance will have the following properties:
							</p>
							<ol class="rp_original">
								<li>If \(D\) and \(R\) are knights, then \(R\) will always accept \(s\) if it actually originated with \(D\), and will reject with probability \(\geq 1-\frac1{2^k}\) any other value \(s'\).</li>
								<li>Regardless if \(D\) is a knight or a knave, \(INT\) will know, with probability of mistake \(leq\frac1{2^k}\), whether \(R\) will accept the \(s\) that he holds.</li>
							</ol>
							<p class="rp_original">
								For this, a new tool called <i>Information Checking</i> is proposed. Information Checking has two major parts called (1) <i>check vectors</i> (2) <i>verification of check vectors</i>.
							</p>
							<p class="rp_original">
								Information Checking is carried out by the three participants in the following way: We assume that a large enough prime, \(p\gt2^k\), has been decided upon for all the computations. Without loss of generality \(s\in\mathbb{Z}_p\).
							</p>
						</section>
						<section id="sec1.3">
							<h3>1.3. Check Vectors:</h3>
							<p class="rp_original">
								The dealer \(D\) chooses two random numbers \(b\neq0\) and \(y\) both in \(\mathbb Z_p\), and hands it to \(INT\) the pair \((s,y)\). The dealer \(D\) computes \(s+by=c\). Then the dealer hands to \(R\) the vector \((b,c)\) which will be known as the <i>Check Vector</i>.
							</p>
							<p class="rp_original">
								Later, when \(INT\) will transmit \((s,y)\) to the receiver \(R\), the receiver will compute \(s+by\) and will accept only if it equals \(c\). It is easily seen that this check vector method essentially disarms a knave \(INT\) from the ability to pass to \(R\) a false value, \(s'\), which \(R\) will accept.
							</p>
							<span class="rp_theorem_header">Lemma 1</span>
							<p class="rp_original">
								(1) The probability that \(INT\) will deceive \(R\), when the dealer \(D\) is a knight, is \(\frac1{p-1}\lt\frac1{2^k}\). (2) The receiver \(R\), has no information about \(s\) from his check vector.
							</p>
							<span class="rp_sub_header">Proof of Lemma 1:</span>
							<ol class="rp_original">
								<li>If \(INT\) chooses a new value \(s'\), which he would like \(R\) to accept he must find the \(y'\) which will solve the equation $$s'+by'=c$$ Only one \(y'\) will solve the equation for the \(b\) held in \(R\)'s hand. Thus the probability $$\operatorname{Pr}\left[R\text{ will accept }s'\neq s\,\middle|\,D\text{ is a knight}\right]\;=\;\frac1{p-1}$$</li>
								<li>The receiver \(R\), has no information about \(s\) from the check vector that he holds, because all values of \(s\) are still possible, with equal probability, due to the fact that for each \(s\) there is a single \(y\) which satisfies the equation.</li>
							</ol>
							<span class="rp_sub_header">Remark</span>
							<p class="rp_original rp_sub">
								Information checking immediately generalizes to the case of several receivers. Let us assume the case where there is one dealer \(D\), one intermediary \(INT\), and receivers \(R_1,\dots,R_n\). The dealer hands to \(INT\) the secret \(s\) and random values \(y_1,\dots,y_n\), \(y_i\) will eventually be handed to \(R_i\) to authenticate \(s\). Each \(R_i\) receives from \(D\) a check vector \((b_i,c_i)\), created in the way described above. Even if all \(R_i\)'s pool their data together, they still have no information about the secret, and for the intermediary who holds the \(y_i\)'s the probability of deceiving one of the players is \(\frac1{p-1}\).
							</p>
							<p class="rp_original rp_sub">
								Thus the check vector assures the property 1., that is \(D\) is a knight, then \(R\) accepts the original \(s\) transmitted, and rejects substitutes.
							</p>
							<section id="sec1.3.1">
								<h4>1.3.1. Verification of Check Vectors:</h4>
								<p class="rp_original">
									To secure property 1 we use the "zero-knowledge" proof technique of <span class="reference" data-citation="R2">[?]</span>. We modify the above procedure as follows: The dealer transfers to \(INT\) an ordered set of pairs \((s,y_1),\dots,(s,y_{2k})\) and to \(R\) an ordered set of check vectors \((b_1,c_1),\dots, (b_{2k},c_{2k})\), where the \(y_i\) and \(b_i\) are chosen by \(D\) as before and hence $$s+b_iy_i\quad\text{for}\,1\leq i\leq2k.$$ The intermediary \(INT\) chooses \(k\) distinct random indices \(d_1,\dots,d_k\;1\leq d_i\leq2k\). He then asks \(R\) to reveal \((b_{d_1},c_{d_1}),\dots,(b_{d_k},c_{d_k})\). For each one of these check vectors, \(INT\) computes $$s+b_{d_i}y_{d_i}=c_{d_i}.$$ If <i>all</i> \(k\) check vectors satisfy the equation, then \(INT\) concludes that \(R\) will accept the value \(s\) that \(INT\) holds. Otherwise he concludes that \(R\) will reject his value.
								</p>
								<p class="rp_original">
									We stipulate that \(R\) will accept a value \(s\) handed over to him by \(INT\), if <i>any one</i> of the <i>unrevealed</i> check vectors, which he holds for \(s\), satisfy the necessary equation.
								</p>
								<span class="rp_theorem_header">Lemma 2</span>
								<p class="rp_original rp_theorem">
									The probability that the intermediary \(INT\) will assume that \(R\) will accept \(s\) when in fact \(R\) will reject it is at most \(\leq\frac{1 }{\binom{2k}{k}} \approx \frac{\sqrt{k}}{2^{2k}}\).
								</p>
								<span class="rp_sub_header">Proof of Lemma 2:</span>
								<p class="rp_original rp_sub">
									If the dealer is a knight then \(R\) will never reject \(s\). In order for the error stated in the Lemma to occur, it must be that \(INT\) has received \(k\) check vectors which are good and \(R\) holds \(k\) unrevealed check vectors which are all faulty. Thus, the probability that \(INT\) will choose all the \(k\) good check vectors is: $$\operatorname{Pr}\left[I\text{ assumes }R\text{ will accept }s\,\middle|\,R\text{ rejects }s\right]\;\leq\;\binom{2k}{k}^{-1}$$ Thus using the protocol of Information Checking as a primitive, we achieve the required 1. and 2.
								</p>
							</section>
						</section>
                    </section>
					<section id="sec2">
						<h2>2. Secret Sharing when the Dealer is a Knight</h2>
						<p class="rp_original">
							In the following protocol we have a group of \(n\) players, including at most \(t\) knaves, where \(n\geq2t+1\). We assume that the dealer is a knight. He owns a secret \(s\), which he wishes to share among the \(n\) players. Without loss of generality we may assume that the secret \(s\in\mathbb Z_p\), for some prime number \(p\gt n\). (The reader should not confuse this new prime \(p\) which can be a small prime with the large prime number used for the generation and verification of the check vectors described above.) We want to achieve that any set of fewer than \(t+1\) players will have no information about the secret \(s\), and any set of \(t+1\) or more players which contains at least \(t+1\) knights will be able to compute the secret. When the secret is revealed we want that all knights will agree on the same value and that it will be the original secret the dealer shared. This gives a new, simple, polynomial-time solution for the problem treated in <span class="reference" data-citation="TW">[?]</span>.
						</p>
						<span class="rp_sub_header">Phase 1 - Sharing the Secret</span>
						<ol class="rp_original rp_sub">
							<li>We fix a prime \(p\gt n\), and \(n\) distinct points, \(a_1,\dots,a_n\in\mathbb Z_p\), known to all players.</li>
							<li>The dealer chooses randomly \(a_1,\dots,a_t\in\mathbb Z_p\) and defines \(f(x)=a_tx^t+\dots+a_1x+s\).</li>
							<li>He computes \(f(a_i)\) for all \(i\).</li>
							<li>For each \(f(a_i)\) he chooses random \(b_{i1}\neq0,y_{i1},\dots,b_{in}\neq0,y_{in}\) and creates the check vectors as described above.</li>
							<li>The dealer hands over to \(P_i\) the data:	
								<ul>
									<li>\(f(a_i)\) - \(P_i\)'s value on the graph of \(f(x)\).</li>
									<li>\(y_{i1},\dots,y_{in}\) - \(P_i\) will hand \(y_{ij}\) to \(P_j\), so \(P_j\) can authenticate \(P_i\)'s piece.</li>
									<li>\((b_{1i}c_{1i}),\dots,(b_{ni},c_{ni})\) - check vectors, where \((b_{ji},c_{ji})\) is \(P_i\)'s check vector for \(P_j\)'s piece.</li>
								</ul>
							</li>
						</ol>
						<p class="rp_original rp_sub">
							This completes the dealer's part.
						</p>
						<span class="rp_sub_header">Phase 2 - Revealing the Secret</span>
						<p class="rp_original rp_sub">
							When the secret is to be revealed:
						</p>
						<ol class="rp_original">
							<li>Every \(P_i\) hands to every \(P_j,\;j\neq i\), the pair \((f(a_i),y_{ij})\). (Knaves may, of course, give false values.)</li>
							<li>For all the pairs that \(P_i\) received he checks, using \((b_{ij},c_{ji})\), that \(f(a_j)+b_{ji}y_{ji}=c_{ji}\) and accepts when appropriate. (Each \(P_i\) who is himself a knight will accept at least \(t+1\) pieces from the knights, and by Lemma 1 will reject, with high probability, all false pieces from the knaves.</li>
							<li>Say \(P_i\) accepted \(f(a_{i_1}),\dots,f(a_{i_r}),\,r\geq t+1\). He can now take \(t+1\) pieces and compute \(f(x)\) by interpolation. Since the dealer was a knight <i>all</i> the accepted points lie on the graph of \(f(x)\). The reconstructed secret \(s\) is uniquely defined as the constant term of \(f(x)\), and equals the one initially distributed.</li>
						</ol>
						<p class="rp_original">
							It is easy to see that the above algorithm provides us with the possibility or a knight dealer to share a secret, so that the knaves can not interfere in the computations, and that all knights will compute the same value \(s\). This completes the proof of Theorem 1.
						</p>
					</section>
					<section id="sec3">
						<h2>3. The Weak Secret Sharing - WSS</h2>
						<p class="rp_original">
							For the next two problems we add to our model the option of <i>broadcasting</i>. Each player can announce a message which will be heard by all others. This is necessary for \(2t+1\leq n\leq3t\), otherwise Byzantine Agreement can be used.
						</p>
						<span class="rp_definition_header" id="def1">Definition 1</span>
						<p class="rp_original rp_definition">
							It will be said that players \(P_1,\dots,P_r,\, r\geq t+1\), holding pieces given by a dealer, <i>define a secret</i> \(s\), if (1) every player \(P_i\) has a distinct evaluation point, (2) for every subset \(P_{i_1},\dots,P_{i_{t+1}}\), the polynomial \(f(x)\) of degree \(t\), interpolated through the pieces \(\beta_{i_1},\dots,\beta_{i+{t+1}}\), which they hold, is the same, and its free term is \(s\). <b>Note:</b> Checking whether a set of players \(P_1,\dots,P_r\) define a secret \(s\) is polynomial.
						</p>
						<p class="rp_original">
							Under this model with broadcast, we shall define the following properties for <i>Weak Secret Sharing</i>:
						</p>
						<ol class="rp_original">
							<li>The properties of the previous secret sharing protocol, when the dealer is a knight.</li>
							<li>If \(D\) is a knave then after it has been decided, (in a sense to be explained later on), that a secret has been distributed, either 
								<ul class="rp_original">
									<li><i>All</i> knights will agree upon a secret \(s\) which they define (Definition 1) and which is the one shared to <i>them</i> by the dealer, or</li>
									<li><i>All</i> knights decide to disqualify the dealer.</li>
								</ul>
							</li>
						</ol>
						<span class="rp_theorem_header">WSS-Theorem:</span>
						<p class="rp_original rp_theorem">
							Assume \(n\geq2t+1\). For a dealer \(D\), who is present until the end of the protocol, there is a protocol which achieves the Weak Secret Sharing. Moreover, the protocol is of polynomial complexity in both \(n\) and the security parameter \(k\), with any desired probability of success.
						</p>
						
						<section id="sec3.1">
							<h3>3.1. Weak Secret Sharing Protocol</h3>
							<p class="rp_original">
								This protocol is executed in three phases. The first two phases are the ones which ensure that when the secret will be revealed, the desired properties will be achieved. The last phases is the one in which the secret is revealed.
							</p>
							<section id="sec3.1.1">
								<h4>Phase 1: Sharing the Secret</h4>
								<ol class="rp_original">
									<li>Following steps 1-4 above, the dealer shares the secret using a random polynomial and creates check vectors to all the pieces.</li>
									<li>He hands over to \(P_i\) the data:
										<ul class="rp_original">
											<li>\(\beta_i=f(\alpha_i)\) - \(P_i\)'s point on the graph of \(f(x)\).</li>
											<li>\(y_{i1},\dots,y_{in}\) - \(P_i\) will hand \(y_{ij}\) over to \(P_j\), so \(P_j\) can authenticate \(\beta_i\).</li>
											<li>\((b_{1i},c_{1i}),\dots,(b_{ni},c_{ni})\) check vectors, where \((b_{ji},c_{ji})\) is \(P_i\)'s check vector for \(\beta_j\).</li>
										</ul>
									</li>
								</ol>
								<p class="rp_original">
									This is precisely the protocol executed by a dealer who is a knight. But when \(D\) is a knave he can hand over to \(P_i\) arbitrary values for \(\beta_i,y_{i1},\dots,y_{in},(b_{1i},c_{1i}),\dots,(b_{ni},c_{ni})\).
								</p>
								<p class="rp_original">
									Note, whenever a check vector \((b_{ji},c_{ji})\) for the value \(\beta_j\) is mentioned in the above, it is not a single check vector but a set of \(2k\) check vectors for \(\beta_j\). The \(y_{ij}\) is also a set of \(2k\) random values for authentication of \(\beta_i\). All these are requirements for the verification of check vectors as described in Information Checking.
								</p>
							</section>
							<section id="sec3.1.2">
								<h4>Phase 2: Modification Verification of the Check Vector</h4>
								<p class="rp_original">
									The following protocol is carried out by each \(P_i\) with respect to every other player \(P_j\). The player \(P_i\) is to be the intermediary as defined in the Information Checking Protocol, and \(P_j\) will be the receiver. The dealer is the dealer who shared the secret. \(P_i\) wants to verify the check vectors held by all other players for his piece \(\beta_i\). The modification is that if \(P_i\) is not satisfied that all players will accept his piece, he will take measures to ensure that they will.
								</p>
								<ol class="rp_original">
									<li>The intermediary \(P_i\) chooses \(k\) check vectors in the manner described in Information Checking, which he then asks \(P_j\) to <i>broadcast</i>.</li>
									<li>The receiver \(P_j\) broadcasts the requested \(k\) check vectors.</li>
									<li>The dealer may: (1) broadcast an approval of these check vectors, or (2) created a new check vector for \(\beta_i\) in the usual manner, hand over to the intermediary \(P_i\) the number \(y_{ij}\), and <i>broadcast</i> \((b_{ij},c_{ij})\). The broadcasted check vector is now taken to be \(P_j\)'s check vector for \(\beta_i\).</li>
									<li>If the first instance in 3 has occurred, \(P_i\) will continue the verification of check vectors as described above. If he knows that \(P_j\) will accept his point he moves on to the next player to carry out this protocol with him. If he decided that \(P_j\) will reject \(\beta_i\), he broadcasts a request that the dealer \(D\) broadcast his piece on the graph \(f(x)\). After \(P_i\)'s piece has been broadcasted he will stop the verification of check vectors. If the second instance in 3 has occurred, \(P_i\) checks the single check vector, broadcasted by the dealer, and according to the result takes the same measures as defined before.</li>
								</ol>
								<span class="rp_theorem_header" id="lemma3">Lemma 3</span>
								<p class="rp_original rp_theorem">
									In this modified verification of check vectors, data unknown to knaves is never exposed.
								</p>
								<span class="rp_sub_header">Proof of Lemma 3:</span>
								<p class="rp_original rp_sub">
									Data unknown to knaves is data which is transferred between knights. If the dealer exposes \(P_j\)'s check vectors it is because \(D\) and/or \(P_j\) are knaves, otherwise \(D\) will be content with what \(P_j\) had broadcasted. If \(INT\) is a knight and he requests the disclosure of his piece, then it must be that \(D\) is a knave. This is because the dealer has the last say about the check vectors and if after that they are still faulty then he must be a knave - so the information broadcasted is the dealer's information which is already known to the knaves.
								</p>
								<span class="rp_sub_header">Remark</span>
								<p class="rp_original rp_sub">
									The above verification scheme assures a knight \(P_i\), acting as intermediary, that his piece will be accepted by \(P_j\), the receiver, or that the piece associated with him has been made public by the dealer during the process.
								</p>
								<p class="rp_original">
									It is not important if the piece \(\gamma_i\) exposed by \(D\) differs from \(\beta_i\), the piece held by \(P_i\), because \(\gamma_i\) is now a value to which \(D\) has committed himself, as being \(P_i\)'s point on the graph \(f(x)\).
								</p>
								<p class="rp_original">
									At this point it is useful to introduce the following.
								</p>
								<span class="rp_definition_header">Definition 2:</span>
								<p class="rp_original rp_definition">
									A <i>coalition</i> is a subset \(C\subseteq \{P_1,\dots,P_n\}\) of the set of all players, for which at the end of Phase 2: each \(P_i\in C\) knows that every other player \(P_j\in C\) will accept his piece of the shared secret.
								</p>
								<p class="rp_original">
									Not that there may be many coalitions among players, and that one player may be a member in several coalitions. However the following lemma holds.
								</p>
								<span class="rp_theorem_header" id="lemma4">Lemma 4</span>
								<p class="rp_original rp_theorem">
									At the end of the verification of check vectors (Phase 2) the set of players who are knights is a coalition.
								</p>
								<span class="rp_sub_header">Proof:</span>
								<p class="rp_original rp_sub">
									If a player \(P_i\) is a knight, he was either satisfied that all players will accept his point, including all knights, or if he thought that one player will not accept his point, then he requested that it be broadcasted. In the latter case his piece will definitely be accepted by all players. We see that \(P_i\)'s piece will in fact be accepted by all players. This is true for every player \(P_j\) who is a knight&mdash;thus the knights form a coalition.
								</p>
							</section>
							<section id="sec3.1.3">
								<h4>Phase 3 - Revealing the Secret</h4>
								<ol class="rp_original">
									<li>The dealer \(D\) broadcasts his polynomial \(f(X)\), which defines the secret \(s\).</li>
									<li>Each \(P_i\) hands to \(P_j\) his piece \(\beta_i\) and the corresponding \(y_{ij}\)'s.</li>
									<li>\(P_i\) checks, by use of his check vector, for every pair \((\beta_j,y_{ji})\) if he accepts the piece, and creates the list \(\beta_{i_1},\dots,\beta_{i_r}\) of all pieces which he has accepted. (For each knight it is known that \(r\geq t+1\) because of the fact that the set of all knights is a coalition).</li>
									<li>For each piece \(\beta_i\) that \(P_i\) accepted, he checks to see if it is on the graph \(f(x)\). If some piece does not fit \(f(x),\,P_i\) broadcasts his vote to disqualify the dealer \(D\).</li>
									<li>The dealer is disqualified if at least \(t+1\) players so voted.</li>
									<li>If the dealer was not disqualified, \(s\), the free term of \(f(x)\), is taken to be \(D\)'s secret.</li>
								</ol>
							</section>
							<span class="rp_sub_header">Proof of the WSS Theorem:</span>
							<ol class="rp_original">
								<li>When the dealer is a knight: We need to show that he will not be disqualifies, and that all knights will agree on the same secret \(s\), results immediately from the properties of the Information Checking.</li>
								<li>When the dealer is a knave: It is left to show that if he was not disqualified, then the secret \(s\) decided upon is the secret defined by all knights. Step 4 of Phase 3 and the coalition of the knights ensures this. Let us say \(P_i\) is a knight and his piece is not on \(f(X)\), then he casts his vote against the dealer. Because all other knights accept his piece, due to the coalition among them, they will also cast the same vote, and the knave dealer will be disqualified. Now if they agree on \(f(x)\), it must be that they defined it, (see <a href="#def1">Definition 1</a>), thus it is proper to take \(s\), the free term of \(f(x)\), to be the secret.</li>
							</ol>
						</section>
					</section>
					<section id="sec4">
						<h2>4. The Verifiable Secret Sharing - VSS</h2>
						<p class="rp_original">
							We now turn to the proof of the main theorem of this paper.
						</p>
						<span class="rp_theorem_header">Main Theorem:</span>
						<p class="rp_original rp_theorem">
							Assume \(n\geq2t+1\), at most \(t\) players who are knaves and a dealer \(D\), who may be a knight or a knave. There exists a protocol which achieves the Verifiable Secret Sharing. Moreover, the protocol is of polynomial complexity in both \(n\) and the security parameter \(k\), and guarantees any desired probability of success by an appropriate choice of \(k\).
						</p>
						<p class="rp_original">
							We start by stating the protocol. The protocol has 4 phases: sharing the secret by the dealer; a second-level secret sharing by the \(P_i\)'s; zero knowledge proof; and computing the secret. At the end of the third phase it will be said that a proper secret has been shared by \(D\).
						</p>
						<section id="sec4.1">
							<h3>4.1. Phase 1 - Sharing the Secret</h3>
							<ol class="rp_original">
								<li>The dealer chooses randomly \(a_1,\dots,a_t\in \mathbb Z_p\) and defines \(f(x)=a_tx^t+\dots+a_1x+s\).</li>
								<li>He also picks random polynomials, \(g_1(x),\dots,g_{k\cdot n}(x)\) each of degree \(t\).</li>
								<li>He computes \(f(\alpha_i),\;g_j(\alpha_i)\;\text{ for }1\leq i\leq n,\;1\leq j\leq k\cdot n\).</li>
								<li>
									He hands over to \(P_i\) the data:
									<ul>
										<li>\(\beta_i=f(\alpha_i)\;-\;P_i\)'s point on the graph of \(f(x)\).</li>
										<li>\(\gamma_{ji}=g_j(\alpha_i)\) for all \(j\)'s - \(P_i\)'s points on the polynomials \(g_j(x)\).</li>
									</ul>
								</li>
							</ol>
							<p class="rp_original">
								This is the protocol executed by a dealer who is a knight. But when \(D\) is a knave, he may of course hand over to \(P_i\) arbitrary values for \(\beta_i,\gamma_{1i},\dots,\gamma_{k\cdot n,i}\).
							</p>
						</section>
						<section id="sec4.2">
							<h3>4.2. Phase 2 - Second Level Secret Sharing</h3>
							<p class="rp_original">
								Each \(P_i\) shares by WSS, each pieces received from the dealer \(D\), i.e. the pieces \(\beta_i,\gamma_{1i},\dots,\gamma_{k\cdot n,i}\). Let us say that \(P_i\) shares \(\beta_i\) using \(h_i(x)\), and \(\gamma_{ij}\) using \(h_{ji}(x)\). Player \(P_i\) also computes $$\delta_{ji}=\beta_i+\gamma_{ji},\;1\leq j\leq k\cdot m,$$ and creates and distributes check vectors for these values. He does not share the value \(\delta_{ji}\) by a separate, independent, random, polynomial, because the sum of the two polynomials \(h_i(x)+h_{ji}(x)\) which shared \(\beta_i\) and \(\gamma_{ji}\) respectively, has as its free term the value \(\delta_{ji}\).
							</p>
						</section>
						<section id="sec4.3">
							<h3>4.3. Phase 3 - Zero Knowledge Proof</h3>
							<p class="rp_original">
								This phase will ensure that \(D\) has in fact shared a secret \(s\) among the players. In this phase it is possible for players to be disqualified. The player \(P_i\) can be <i>disqualified</i> if:
							</p>
							<ol class="rp_original">
								<li>the secret he shared using the WSS disqualifies him, or</li>
								<li>a vote of at least \(t+1\) players is cast against him.</li>
							</ol>
							<p class="rp_original">
								The protocol for this phase:
							</p>
							<p class="rp_original">
								For each \(g_j(x)\), player \(P_{j\bmod n},\,1\leq j\leq k\cdot n\), decides whether \(D\) will expose \(g_j(x)\) or \(f(x)+g_j(x)\). (This procedure of choosing the polynomial ensures that at least \(k(t+1)\) of the alternatives are randomly chosen). In the \(j\)th round we set \(H(x)\) to be \(g_j(x)\) or \(f(x)+g_j(x)\) depending on the player's decision. This version of zero knowledge proof in the context of VSS was used in <span class="reference" data-citation="CCD">[?]</span>, when \(n\geq3t+1\).
							</p>
							<ol class="rp_original">
								<li>The dealer broadcasts \(H(x)\).</li>
								<li>Each \(P_i\) checks if his piece \(\gamma_{ji}\), or the sum of his two pieces \(\delta_{ji}=\beta_i+\gamma_{ji}\), as the case may be, is on \(H(x)\). If \(P_i\) is not satisfied then he requests that the dealer \(D\) expose <i>all</i> the information which he had handed to \(P_i\) in Phase 1.</li>
								<li>If the dealer \(D\) does not broadcast the required information, the knights decide that <i>no</i> secret was shared.</li>
								<li>
									<p>Every \(P_i\) whose pieces were not broadcasted by \(D\) in 2 now broadcasts his piece \(\gamma_{ji}\text{ or }\delta_{ji}\), as the case may be) and the polynomial by which he shared his piece using the WSS. Because \(P_i\) used the WSS protocol he may now</p>
									<ul>
										<li>Be disqualified, or</li>
										<li>Expose a piece \((y_{ji}\text{ or }\delta_{ji})\) on which all knights agree.</li>
									</ul>
									<p>All players check if this piece is on \(H(x)\), if yes then OK. Otherwise \(P_i\) is disqualified, because at least \(t+1\) knights will case a vote against him.</p>
								</li>
								<li>If at any time \(t+1\) pieces of the secret have been made public, the polynomial which they define is taken as the dealer's secret \(s\). At each stage of the computation the validity of all public points is checked. If one does not match a certain polynomial publicized by \(D\), then it is decided that <i>no</i> secret was shared.</li>
							</ol>
							<span class="rp_theorem_header" id="lemma5">Lemma 5</span>
							<p class="rp_original rp_theorem">
								In step 2 data unknown to the knaves is never revealed.
							</p>
							<span class="rp_sub_header">Proof of Lemma 5</span>
							<p class="rp_original rp_sub">
								If \(P_i\) is a knave - trivial. If \(P_i\) is a knight then the only instance in which his piece \(\gamma_{ji}\) or \(\delta_{ji}\) does not fit \(H(x)\) (and hence causes him to request disclosure) is when \(D\) is a knave, because \(D\) is the one who handed \(P_i\) the pieces \(\beta_i\) and \(\gamma_{ji}\).
							</p>
							<span class="rp_theorem_header" id="lemma6">Lemma 6</span>
							<p class="rp_original rp_theorem">
								A knight player can never be disqualified.
							</p>
							<span class="rp_sub_header">Proof of Lemma 6</span>
							<p class="rp_original rp_sub">
								A knight can not be disqualified by his WSS as proven in <a href="#theorem1">Theorem 1</a>. And he will not disqualified if his piece is not on \(H(x)\), because he would have complained about it in step 2.
							</p>
							<span class="rp_theorem_header" id="lemma7">Lemma 7</span>
							<p class="rp_original rp_theorem">
								At the end of Phase 2 with probability \(2^{-k\cdot(t+1)}\), al pieces held by non-disqualified players and all public pieces define the same polynomial of degree \(t\).
							</p>
							<span class="rp_sub_header">Proof of Lemma 7</span>
							<p class="rp_original rp_sub">
								If a player \(P_i\) has shared a piece \(\beta_i\neq f(\alpha_i)\), then for all \(j\) only <i>one</i> of the following can be true:
							</p>
							<ol class="rp_original rp_sub">
								<li>\(\gamma_{ji}=g_j(\alpha_i)\)</li>
								<li>\(\delta_{ji}=f(\alpha_i)+g_j(\alpha_i)</li>
							</ol>
							<p class="rp_original rp_sub">
								If 1. is true, \(\beta_i+\gamma_{ji}=\delta_{ji}\neq f(\alpha_i)+\gamma_{ji}\). If 2. holds then \(\beta_i+\gamma_{ji}=\delta_{ji} =f(\alpha_i)+g_j(\alpha_i)]) but \(beta_i\neq f(\alpha_i)\) implying that \(\gamma_{ji}\neq g_j(\alpha_i)\).
							</p>
							<p class="rp_original rp_sub">
								Because the decision whether to disclose \(g_j(x)\) or \(f(x)+g_j(x)\) is made randomly (by the \(t+1\) knights) at least \(k\cdot(t+1)\) times, we achieve the desires probability of being correct.
							</p>
						</section>
						<section id="sec4.4">
							<h3>4.4. Phase 4 - Computing the Dealer's Secret</h3>
							<ol class="rp_original">
								<li>All non-disqualified \(P_i\)'s broadcast their piece \(\beta_i\) and the polynomial \(h_i(x)\), which was used in the WSS for that piece.</li>
								<li>The \(\beta_i\)'s and all public pieces form a set \(S\).</li>
								<li>For each piece \(\beta_i\) in \(S\) (excluding public pieces), the non-disqualified players check that it was in fact the one shared by \(h_i(x)\) in the WSS. If a player \(P_i\) who holds the piece \(\beta_i\) is disqualified due to the WSS, then the piece \(\beta_i\) is taken out of \(S\). After this it holds that \(|S|\geq t+1\), because at least all the knights' pieces are in \(S\), due to Secret Sharing when the Dealer is a Knight.</li>
								<li>Each player may take any \(t+1\) pieces from \(S\) and interpolate the polynomial \(f(x)\). The secret \(s\) will be the free term of the polynomial \(f(x)\).</li>
							</ol>
						</section>
						<section id="sec4.5">
							<h3>4.5. Proof of the Main Theorem</h3>
							<p class="rp_original">
								The proof will be divided into two parts:
							</p>
							<ol class="rp_original">
								<li>We will prove that if the dealer is a knight, then it will never be decided that <i>no</i> secret was shared.</li>
								<li>For any dealer, if Phase 3 ended with the decision that a secret has been shared, then all knights will agree to the same secret \(s\), and it will be the one defined by the pieces which they hold and the public pieces.</li>
							</ol>
							<p class="rp_original">
								We now proceed to prove the above:
							</p>
							<ol class="rp_original">
								<li>
									The decision that no secret was shared arises if
									<ul>
										<li>the dealer refuses to broadcast information requested by one of the players, or</li>
										<li>public pieces which he broadcasted do not fit on a polynomial which he broadcasted.</li>
									</ul>
									Since the dealer is a knight, both instances are impossible.
								</li>
								<li>At the end of Phase 3, when all knights know that a proper secret has been shared, it is also known, by <a href="#lemma7">Lemma 7</a>, that all pieces held by non-disqualified players, and all public pieces define the same polynomial. Due to the fact that each one of the unpublicized pieces is shared using WSS, in Phase 4 it must be either revealed <i>properly</i> or the dealer of that piece will be disqualified. But a knave will not be able to introduce a new piece into the computations, which will be accepted by knights, (<a href="#theorem3.1">Theorem 3.1</a>). All points revealed by knights will be accepted (Secret Sharing when the Dealer is a Knight). So we will have at least \(t+1\) pieces which define the same polynomial. Thus the desired properties are achieved.</li>
							</ol>
							<span class="rp_sub_header">Remark</span>
							<p class="rp_original rp_sub">
								Instead of revealing the secret to all the players we can reveal the secret to only one of the players by having all the information sent only to this player.
							</p>
						</section>
					</section>
					<section id="sec5">
						<h2>Incomplete Networks</h2>
						<p class="rp_original">
							Let \(G\) be a synchronous network of \(n\geq3t+1\) processors, with connectivity at least \(2t+1\), and diameter \(d=d(G)\), that provides private and secure communication links between processors that are directly connected by \(G\). To prove both Theorems <a href="#theorem2">2</a> and <a href="#theorem3">3</a>, it is enough to show how to simulate in our partial network a secure communication line between any two honest players given that they are connected by \(2t+1\) vertex disjoint paths in \(O(d)\) steps. Having such a scheme we can simulate on the network \(G\) the constant expected time Byzantine Agreement protocol of Feldman and Micali<sup class="reference" data-citation="FM">[?]</sup> in \(O(d)\) expected time, proving <a href="#theorem2">Theorem 2</a>, or simulate the secure computation protocol of <span class="reference" data-citation="BGW">[?]</span>, proving <a href="#theorem3">Theorem 3</a>.
						</p>
						<p class="rp_original">
							We can therefore assume that the sender of the message \(D\) is honest, and so we are in a case where <a href="#theorem1">Theorem 1</a> applies. To send a message to \(R,\,D\) encodes the message using a polynomial of degree \(t\) into \(2t+1\) pieces, and sends each piece together with check vectors for all the other pieces along a separate route to \(R\). To read the message, \(R\) tests each piece with all the check vectors arriving from all the routes and discards any pieces that does not match with at least \(t+1\) such vectors. Having collected \(t+1\) such pieces, \(R\) computes the interpolation polynomial and takes its free terms as \(D\)'s message. It is easy to see this simple <i>one phase</i> protocol has all the properties needed to prove <a href="#theorem2">Theorem 2</a> and <a href="#theorem3">Theorem 3</a>.
						</p>
						<p class="rp_original">
							After submitting this abstract, the authors have learned that Dolev, Dwork, and Yung<sup class="reference" data-citation="DDY">[?]</sup>have shown how to simulate in a \(2t+1\) connected network a secure communication line between any two honest players in a completely error-free manner. Therefore, our Theorem 3 is not the best possible, as under the conditions of Theorem 3, any multiparty protocol can be achieved with absolutely no error at all (see <span class="reference" data-citation="DDY">[?]</span>). We note that in the "error-free" simulation, the faulty players can delay the message between two honest players for \(O(td)\) steps. Therefore their simulation does not provide a proof of Theorem 2. We briefly sketch below how to combine both results and obtain an absolutely error free secure transmission in \(O(d)\) expected time.
						</p>
						<section id="sec5.1">
							<h3>5.1. Error Free Transmission</h3>
							<p class="rp_original">
								Assume \(D\) and \(R\) are \(2t+1\) connected, and \(D\) wants to transmit the message \(M\) to \(R\). \(D\) randomly writes \(M=M_1+M_2\), and sends using the scheme described above \(M_1\) to \(R\). \(R\) collects all the verified messages (i.e. at least \(t+1\) verifications), and if there is a polynomial of degree \(t\) that <span class="definable" data-define="interpolate">interpolates</span> through <i>all</i> the points, \(R\) takes the free coefficient as \(M_1\). In this case \(R\) broadcasts an acknowledgement on all the \(2t+1\) lines to \(D\), and \(D\) tries to send \(M_2\).
							</p>
							<p class="rp_original">
								On the other hand, if \(R\) cannot complete the interpolation through all the points, \(R\) broadcasts back to \(D\) (along the \(2t+1\) lines) all the information he received from all lines. This step does no relay any information because this will be done wither for \(M_1\) or for \(M_2\) but never for both, and clearly \(M_1 (M_2)\) alone contains no information.
							</p>
							<p class="rp_original">
								At this stage, \(D\) compares the broadcast of \(R\) to its original messages. \(D\) marks all the mismatches as "bad", and broadcasts the "bad" list to \(R\). Concurrently, \(D\) breaks up the message \(M\) into new random pieces \(M=N_1+N_2\), and begins the whole procedure again, but now \(R\) will ignore the shares of the secret coming from connections on the bad list.
							</p>
							<p class="rp_original">
								We continue (using on each retry a new breakup of \(M\)) until either:
							</p>
							<ol type="a" class="rp_original">
								<li>Both pieces arrive in a good shape at \(R\), or</li>
								<li>The "bad" list is longer than \(t+1\), or</li>
								<li>after a bad transmission the bad list doesn't grow.</li>
							</ol>
							<p class="rp_original">
								Clearly, after at most \(t+1\) retries, a pair of good \(D\) and \(R\) will be able to transmit their value securely with no errors at all. Furthermore, if only one of \(D\) and \(R\) is bad, the good player will never wait for more than \(t+1\) rounds. Moreover, because of the check vectors, only with exponentially small probability there will be any need for retransmission.
							</p>
						</section>
						<section id="sec5.2">
							<h3>5.2. Note</h3>
							<p class="rp_original">
								The procedure described above, without the check vectors, is only a slight variation of the transmission scheme of <span class="reference" data-citation="DDY">[?]</span>. It is clear that this procedure works as well without the check vectors, but there is a clear advantage in using the check vectors during this procedure. Without the check vectors, the \(t\) bad players can cause a delay of \(O(t\cdot d)\) steps in the communication between good players, whereas using the check vectors, only with exponentially small probability there will be any need for retransmission.
							</p>
							<p class="rp_original">
								It is clear that if \(D\) and \(R\) are both good, the expected number of communication rounds to get an error free transmission is a constant (\(O(d)\)). A slightly more complicated problem is to handle the case of a bad \(D\) sending a message to a good \(R\). In this case using the scheme described above, the bad \(D\) can easily cause a delay of \(O(td)\) time until \(R\) will be able to continue. Thus, unless we are willing to give up the synchrony of our simulated protocol a single bad player can cause a delay of \(O(td)\) steps.
							</p>
							<p class="rp_original">
								To avoid this problem, we make \(D\) the dealer of the secret in our VSS protocol. Assuming \(R\) is good we get a broadcast channel simulation between all the \(2t+1\) connections and the dealer \(D\) as follows:
							</p>
							<ul class="rp_original">
								<li>A broadcast of one of the \(2t+1\) is sent to \(R\) who sends it on all \(2t+1\) connections, and they transmit the message also to \(D\) (who gets the message by a simple majority rule).</li>
								<li>A broadcast from \(D\) to all the players is done by having \(D\) send the message on all lines to \(R\). \(R\) gets the message (by majority), and sends the value he got to all the \(2t+1\) connections. This value coming from \(R\) is taken as the value of \(D\)'s broadcast.</li>
								<li>The private line between two connections can go through \(R\).</li>
							</ul>
							<p class="rp_original">
								Since the VSS uses a constant number of rounds, so will this simulation. Since the VSS guarantees with exponentially small probability of error that there will be a \(t\)-degree polynomial interpolating through all the accepted points, \(R\) will get a message (or realize that \(D\) is faulty) in constant number of rounds with only an exponentially small probability of not being able to decide what happened. In this case we can go back to the previous scheme, and continue for at most \(O(t)\) more rounds. Since this happens only with exponentially small probability, we get an \(O(d)\) expected time transmission even from a bad \(D\) to a good \(R\). (This case of faulty \(R\) and good \(D\) is not needed at all).
							</p>
							<p class="rp_original">
								From this constant expected time error-free transmission we can prove a stronger version of Theorem 3.
							</p>
							<span class="rp_theorem_header" id="theorem3star">Theorem 3*</span>
							<p class="rp_original rp_theorem">
								Let \(G\) be a synchronous network of \(n\geq3t+1\) processors, with connectivity at least \(2t+1\), and diameter \(d=d(G)\), that provides private and secure communication links between processors that are directly connected by \(G\), then any multiparty protocol \(\mathcal P\) can be achieved on \(G\) if at most \(t\) of the players are faulty. As in <span class="reference" data-citation="DDY">[?]</span>, the computation is completely error-free, and the secrecy achieved is unconditional. Moreover, the expected computation time is only \(O(d)\) times the best secure and error-free protocol for \(\mathcal P\) on a complete network.
							</p>
						</section>
					</section>
					<section id="sec6">
						<h2>6. Multiparty Computations</h2>
						<p class="rp_original">
							In this section, all computations are carried out in a small finite field, for example \(\mathbb Z_p\) where \(n\lt p\lt2n\). Our VSS protocol can be easily modified to work in a small finite field or by using a separate large prime for the check vectors.
						</p>
						<p class="rp_original">
							We say that a group of players \(P_1,\dots,P_n\) <i>will have computed a function \(f(u_1,\dots,u_m)=u\) by a protocol PR</i>, where \(u_1,\dots,u_m\) were entered into the computation using VSS, if at the end of the protocol, \(u\) is a verified shared secret.
						</p>
						<p class="rp_original">
							The problem of multiparty computations can be reduced (see <span class="reference" data-citation="GMW">[?]</span>) to the problem of multiparty function computations. We will produce protocols for addition and multiplication of shared secrets and for multiplication by a publicly known constant, which can be carried out in a fault-tolerant and secrecy-preserving manner. Thus we achieve that a group of \(n\) players can secretly and with fault tolerance compute any function.
						</p>
						<span class="rp_theorem_header">Definition</span>
						<p class="rp_original rp_theorem">
							A group of \(n\) players holds a <i>verified secret (data) \(s\)</i>, shared using the polynomial \(f(x)\), so that \(f(0)=s\), and satisfying the conditions of VSS if:
						</p>
						<ol class="rp_original">
							<li>The polynomial \(f(x)\) is of degree \(t\).</li>
							<li>Each player \(P_i\) holds a share of the secret \(\beta_i=f(\alpha_i)\).</li>
							<li>Every piece \(\beta_i\) was shared by \(P_i\) using WSS.</li>
						</ol>
						<span class="rp_sub_header">Note</span>
						<p class="rp_original rp_sub">
							A result of our VSS protocol to share a secret \(s\) (Theorem ) is that \(s\) will be a <i>verified secret</i>.
						</p>
						<p class="rp_original">
							Now, all we need to show in order to prove Theorem number, is that we can produce protocols for addition and multiplication of verifiable shared secrets \(u\) and \(v\), which maintain the situation that all data in the computation, including the end result, is verified data.
						</p>
						<p class="rp_original">
							Let us look at two secrets \(u\) and \(v\), which are verified secrets. Thus it is known that:
						</p>
						<ol class="rp_original">
							<li>They were shared by \(f^u(x)\) and \(f^v(x)\) respectively, both polynomials of degree \(t\).</li>
							<li>Each \(P_i holds:
								<ul>
									<li>A piece \(f^u(\alpha_i)=\beta_i^u\), which he further shared using the polynomial \(h_i^u(x)\) and the WSS protocol.</li>
									<li>A piece \(f^v(\alpha_i)=\beta_i^v(x)\) and the WSS protocol.</li>
									<li>The pieces \(h_j^u(\alpha_i) =\beta_{ji}^u\) and \(h_j^u(\alpha_i) =\beta_{ji}^v\), which are his shares of the other players' pieces. (The player \(P_i\) received them as a result of WSS).</li>
								</ul>
							</li>
						</ol>
						<section id="sec6.1">
							<h3>6.1. Addition Protocol</h3>
							<p class="rp_original">
								We would like to compute \(u+v\), and to achieve that the sum will be a verified secret.
							</p>
							<p class="rp_original">
								The polynomial \(f^u(x)+f^v(x)=f^{u+v}(x)\) has as its constant term the desired value \(u+v\), and this polynomial is of degree \(t\). If each \(P_i\) adds his pieces \(\beta_i^u+\beta_i^v=\beta_i^{u+v}\), then he will have a share of \(u+v\) by the polynomial \(f^{u+v}(x)\). Therefore, conditions 1 and 2 for a verified secret hold immediately.
							</p>
							<p class="rp_original">
								To achieve condition 3, we need that \(\beta_i^{u+v}\) will be shared using WSS. Note that the value \(\beta_i+{u+v}\) is already shared by the polynomial \(h_i^{u+v}(x)\), which is the sum of the polynomials which shared \(\beta_i^u\) and \(\beta_i^v\), that is \(h_i^u(x)+h_i^v(x) =h_i^{u+v}(x)\). Thus all we need are the appropriate check vectors. This is achieved as follows:
							</p>
							<ol class="rp_original">
								<li>The player \(P_i\) creates check vectors for \(h_i^u(\alpha_j)+ h_i^v(\alpha_j)= h_i^{u+v}(\alpha_j)\) and distributes them to the other players.</li>
								<li>All players verify these check vectors using the Modified Verification of Check Vectors Protocol (see Section ).</li>
							</ol>
							<p class="rp_original">
								During the computation of the addition, knaves may act as they wish, but if they don't follow the protocol they are disqualified. (Their data can be reconstructed if needed in a manner which will be described later).
							</p>
							<span class="rp_theorem_header">Lemma 8</span>
							<p class="rp_original rp_theorem">
								After the above addition protocol is carried out, the sum \(u+v\) is a verified secret.
							</p>
							<p class="rp_original">
								Note: the same protocol can be carried out for subtraction.
							</p>
						</section>
						<section id="sec6.2">
							<h3>6.2. Protocol for Multiplication by a Constant</h3>
							<p class="rp_original">
								There is a publicly known constant \(d\) and we would like to compute the value \(u*d\) so that this product will be a verified secret. This multiplication is trivial. All that \(P_i\) needs to do is multiply his share \(\beta_i^u\) by the constant \(d\). When at a later stage he receives the piece \(\beta_j^{u*d}\) and the value \(y_{ji}^u\) from player \(P_j\), he should just the check vector \((b,c)\) which he holds for the original piece of the player \(P_j\) by computing \(\beta_j^{u*d}+bdy^u_{ji}=cd\).
							</p>
						</section>
						<section id="sec6.3">
							<h3>6.3. Linear Computations</h3>
							<p class="rp_original">
								The combination of the protocol for addition and the protocol for multiplication by a constant provides us with the ability to compute any linear combination of verified secrets.
							</p>
						</section>
						<section id="sec6.4">
							<h3>6.4. Multiplication Protocol</h3>
							<p class="rp_original">
								Before we proceed to show how to compute the product of two verified secrets, let us prove two lemmas which will be needed later.
							</p>
							<span class="rp_theorem_header" id="lemma9">Lemma 9</span>
							<p class="rp_original rp_theorem">
								A dealer can prove that two secrets, \(s_1\) and \(s_2\), which he shared using VSS, are equal.
							</p>
							<span class="rp_sub_header">Proof</span>
							<p class="rp_original rp_sub">
								All players carry out the subtraction protocol for \(s_1\) and \(s_2\). Based on the lemma for addition/subtraction, this new value is a verified secret, and can be reconstructed by the players. They reconstruct the value \(s_1-s_2\). Now, \(s_1-s_2=0\) iff \(s_1=s_2\).
							</p>
							<span class="rp_theorem_header" id="lemma10">Lemma 10</span>
							<p class="rp_original rp_theorem">
								Using the Zero Knowledge technique the dealer can prove that three secrets \(a,\,b\), and \(c\), satisfy \(a\cdot b=c\).
							</p>
							<span class="rp_sub_header">Proof</span>
							<p class="rp_original rp_sub">
								Let \(f,\,g\), and \(h\) be the polynomials used to distribute \(a,\,b\), and \(c\) respectively. We recall that all our secrets are elements of a small finite field \(E,\,|E|=p\), and we can pick \(p\) to satisfy \(n\lt p\lt2n\). Let \(Z=\{(x,y,z)\,|\,xy=z,\,\forall\,x,y\inE\}\) be the multiplication table of \(E\). The dealer randomly permutes the members of \(Z\) to a list \(\{(x_i,y_i,z_i)\}\). He then generates random polynomials of degree \(t,\,f_i,\,g_i\) and \(h_i,\,i=1\dots p^2\), encoding this list, (e.g. \(f_i(0)=x_i\), etc.). The dealer prepares \(m=knp^2\) independent encoded copies of the multiplication table of \(E\) and distributes all the randomly chosen triples in these lists using our secret sharing protocol. At this point each player broadcasts a list of \(kp^2\) requests asking the dealer to either open completely one of the encoded lists or two show, using the equality protocol of Lemma 9, that for some \(i\) on the list \(f(0)-f_i(0),\, g(0)=g_i(0)\), and \(h(0)=h_i(0)\). It is easy to see that this procedure provides a zero knowledge proof to the fact that \(h(0)=f(0)g(0)\), with probability of failure at most \(2^{-k}\).
							</p>
							<p class="rp_original">
								We now proceed to exhibit the multiplication protocol. For the above \(u\) and \(V\), we would like to compute \(u*v\), and to ensure that the product will be a verified secret.
							</p>
							<p class="rp_original">
								The polynomial \(f^u(x)*f^v(x)=f^{u*v}_1(x)\) has as its constant term the desired value \(u*v\), but two problems arise: (1) The polynomial is of degree \(2t\). (2) Its is not a random polynomial. To overcome these problems, we will adapt the methods described in <span class="reference" data-citation="BGW">[?]</span>, and in combination with the VSS protocol, we will return to the state in which all data in the computation is verified data. The protocol is as follows:
							</p>
							<ol class="rp_original">
								<li>
									<p>The player \(P_i\) must extend his WSS of \(\beta_i^u\) and \(\beta_i^v\) to VSS This is easily done: (the protocol given is for \(\beta^u_i\), and the same is done for \(\beta^v_i\).</p>
									<ul>
										<li>Each \(P_j\) holds a piece \(\beta^u_{ij}\) which is a share of \(P_i\text{'s}\,\beta_i^u\). He shares \(\beta_{ij}^u\) using WSS</li>
										<li>Then \(P_i\) carries out the zero knowledge proof, as in our VSS protocol, to show that all shares held by the players lie on a polynomial \(h_i^u(x)\) of degree \(t\).</li>
									</ul>
								</li>
								<li>
									<p>If some player refuses to cooperate, or is disqualified in the above process, then his pieces are reconstructed by the other players, and become common knowledge. The players which participate in this computation, are players who have extended their WSS to VSS, that is that they were not disqualified. Thus, their pieces \(\beta_j^u\), which are now shared by VSS, are points on the graph of the polynomial of the shared secret \(u\). Assume that \(P_i\) didn't follow the protocol, his pieces \(\beta_i^u\) is computed in the following way:</p>
									<p>Since \(\beta^u_i\) is on a polynomial of degree \(t\), we can represent \(\beta^u_i\) as a linear combination with publicly known (and easily computable) coefficients of any other \(t+1\) point on this polynomial. Since at least \(t+1\) players will extend the WSS of their points on this polynomial to a VSS, we can use this linear relation together with the Linear Computation Lemma to compute a verified secret of the missing \(\beta\)'s and make them public. Now it holds, that either \(\beta_i^u\) was shared, using VSS, or it was made public.</p>
								</li>
								<li>The player \(P_i\) computes \(\beta_i^u*\beta_i^v=\beta_i^{u*v}\), and distributes it with a new polynomial \(h_i^{u*v}(x)\), using the VSS protocol. Then he proves that \(h^u_i(0)*h_i^v(0)=h_i^{u*v}(0)\), as described above in Lemma 10. If he fails to do the above, his pieces are reconstructed and exposed.</li>
								<li>In order to randomize the polynomial \(f_1^{u*v}(x)\), each \(P_i\) shares \(t\) random polynomials \(g_{i,j}(x)\), of degree \(t\), and proves that he has done just this. Using the method described in <span class="reference" data-citation="BGW">[?]</span>, they generate a random polynomial of degree \(2t\) with a zero free coefficient. By adding this polynomial to \(f_1^{u*v}(x)\) we obtain a new random polynomial \(f_2^{u*v}(x)\) with the same free coefficient.</li>
								<li>To preform the reduction of the degree of the polynomial, \(f_2^{u*v}(x)\) to degree \(t\), we carry out the linear computation described in <span class="reference" data-citation="BGW">[?]</span>. If a player doesn't cooperate, his piece is revealed using the VSS for this piece. The result of this computation will be that each player holds a verified share of a piece of \(u*v\), shared by the polynomial \(f^{u*v}(x)\) of degree \(t\), so that \(f^{u*v}(0)=f_1^{u*v}(0)\). Each player manages to compute his own, new piece, after all information held by the other players has been passed on to him.</li>
								<li>
									<p>As a result of the above computation, the following facts hold:</p>
									<ul>
										<li>Each player holds a share \(\beta_i^{u*v}\) of the secret \(u*v\).</li>
										<li>This piece is already shared using VSS.</li>
										<li>Due to the VSS of \(\beta_1^{u*v}\), each player \(P_j\) holds a share \(\beta_{ij}^{u*v}\) of \(\beta_i^{u*v}\).</li>
									</ul>
									<p>
										To achieve condition 3 of a verified secret for \(u*v,\,\beta_i^{u*v}\) must be shared by WSS. To transform the VSS of this piece to WSS the following is done:
									</p>
									<ul>
										<li>The player \(P_i\) creates and distributes check vectors for all \(\beta_{ij}^{u*v}\).</li>
										<li>All players execute the Modified Verification of Check Vectors.</li>
										<li>If \(P_i\) fails to cooperate his piece is exposed using the VSS for it.</li>
									</ul>
								</li>
							</ol>
							<p class="rp_original">
								We therefore have
							</p>
							<span class="rp_theorem_header" id="lemma11">Lemma 11</span>
							<p class="rp_original rp_theorem">
								After the above multiplication protocol is carried out the product \(u*v\) is a verified secret.
							</p>
							<p class="rp_original">
								And this completes the proof of Theorem 4.
							</p>
						</section>
					</section>
					<section id="sec7">
						<h2>7. Acknowledgement</h2>
						<p class="rp_original">
							The first author wishes to thank her advisor Michael Ben-Or for suggesting the VSS problem and for his encouragement and many important comments, as well as Michael Rabin for several useful comments.
						</p>
					</section>
				</div>
            </div>
			<div class="main_toplevel main_section main_color7" id="footnotes">
                <h1>Footnotes</h1>
				
                <ol id="footnotes">
                    <li id="footnote1">
						<a href="#fref1">[^]</a> See the section on Incomplete Networks for a discussion of stronger results than stated here.
					</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color8" id="references">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="B">M. Ben-Or. Multiparty Protocols with Honest Majority, in preparation.</li>
					<li id="BGW">M. Ben-Or, S. Goldwasser, and A. Wigderson. Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation, <i>STOC88</i>, pp. 1-10.</li>
					<li id="CCD">D. Chaum, C. Cr&eacute;peau, and I. Damg&aring;rd. Multiparty Unconditionally Secure Protocols. <i>STOC88</i>, pp. 11-19.</li>
					<li id="CGMA">B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. Verifiable Secret Sharing and Achieving Simultaneity in the Presence of Faults. <i>FOCS85</i>, pp.383-395.</li>
					<li id="D">D. Dolev. The Byzantine Generals Strike Again, <i>J. of Algorithms, Vol. 3</i>, pp. 14-30. 1980.</li>
					<li id="DDY">D. Dolev, C. Dwork, M. Yung. Non-Cryptographic Secure Communication on General Networks. Preprint.</li>
					<li id="F">P. Feldman. Optimal Algorithms for Byzantine Agreement. MIT Ph.D Thesis, to appear.</li>
					<li id="FM">P. Feldman, S. Micali. Optimal Algorithms for Byzantine Agreement. <i>STOC88</i>, pp. 148-161.</li>
					<li id="GMW">O. Goldreich, S. Micali, and A. Wigderson. <a href="81.html">How to Play Any Mental Game or a Completeness Theorem for Protocols with Honest Majority.</a> <i>Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing</i>, pages 218–229. ACM. 1987.</li>
					<li id="R1">M. Rabin. Randomized Byzantine Generals. <i>FOCS83</i>, pp. 403-409.</li>
					<li id="R2">M. Rabin. Digitalized Signatures, Foundations of Secure Computations, R. Demillo et.al. editors, Academic Press, (1978), pp. 155-165.</li>
					<li id="RT">T. Rabin. Robust Sharing of Secrets when the Dealer is Honest or Cheating. M.Sc. Thesis, The Hebrew University, July 1988.</li>
					<li id="S">A. Shamir. How to Share a Secret. <i>CACN, 22</i>, pp. 612-613. 1979.</li>
					<li id="TW">M. Tompa and H. Woll. How to Share a Secret with Cheaters. IBM Research Report, RC 11840 (Log #52910). 1986.</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+76@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Created by Nicolas Schank 2014, Brown University</p>
				<p>All original work is free for any use by anyone whatsoever.</p>
				<p>For more information about liability and licensing the original paper, see <a href="../liability.html">Liability</a>.</p>
            </div>
        </div>
    </body>
</html>
<!--
4. Headings
5. Transcribe paper
6. References
7. Annotate paper
	7.0. proofread
	7.1. copy assumptions
	7.2. copy theorems
	7.3. copy definitions
	7.4. mark definitions
	7.5. mark equations
	7.6. link to previous research
8. Write protocol descriptions 
9. Check previous research for places to link
10. Write intro, goals, results
11. Tags
12. Consider implementations
13. Find reference
-->