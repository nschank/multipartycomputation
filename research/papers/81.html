<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>How to Play Any Mental Game - Goldreich Micali Wigderson, 1987</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					case "{0,1}*":
						return "<p>The set of all 0/1 strings of any length, including the empty string.</p>";
					case "HS":
						return "<p>The function \\(HS\\) returns the RV consisting of the public history that is the sequence of all messages sent in an execution of \\(S\\).</p>";
					case "HSi":
						return "<p>The function \\(HS_i\\) returns the RV consisting of the sequence of the internal configurations of machine \\(i\\) in an execution of \\(S\\).</p>";
					case "HST":
						return "<p>For \\(T\\subset \\{1,…,n\\}\\), the function \\(HS_T(x_1,\\dots,x_n)\\) denotes the vector of the private histories of the members of \\(T\\) in an execution of \\(S\\).</p>";
					case "OSi":
						return "<p>The function \\(OS_i(x_1,\\dots,x_n,CI)\\) denotes the RV consisting of the private output of machine \\(i\\) in an execution of \\(S\\).</p>";
					case "PUCk":
						return "<p>The probability function \\(P(U,C,k)\\) calculates the probability that \\(C_k\\) outputs 1 on input a random string from \\(U_k\\), where \\(U\\) is a <span class=\"definable\">poly-bounded family of random variables</span> and \\(C\\) is a <span class=\"definable\">poly-size family of circuits</span>. We assume that the length of the strings that are assigned positive probability by \\(U_k\\) equals the number of Boolean inputs of \\(C_k\\).</p>";
					default:
						return "No info on this equation yet.";
				}
			}

			function authorLink(ref)
			{
				switch (ref)
				{
					default:
						return "#";
				}
			}

			self_def["computational indistinguishability"] = "<a href=\"#def1\">Definition 1</a></p><p class=\"gl_definition\">Informally, groups of random variables are indistinguishable from each other when large groups of them can't be differentiated consistently.</p>";
			self_def["dynamic adversary"] = "A good machine can choose, during the run of the protocol, to become an adversary.";
			self_def["game network"] = "A network of \\(n\\) interacting polynomial-time Turing machines";
			self_def["poly-bounded family of random variables"] = "A family \\(U=\\{U_k\\}\\) such that, for some constant \\(e&gt;0\\), all RVs \\(U_k\\in U\\) assign positive probability only to strings whose length is exactly \\(k^e\\).";
			self_def["poly-size family of circuits"] = "A family \\(C=\\{C_k\\}\\) of Boolean circuits \\(C_k\\) with one Boolean output such that, for some constants \\(e,d&gt;0\\), all \\(C_k\\in C\\) have at most \\(k^e\\) gates and \\(k^d\\) Boolean inputs.";
			//-->
        </script>
    </head>
    <body>
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth"><a id="_A"></a>
                    <div class="rp_linkbox"><a href="pdf/###.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">How to Play Any Mental Game or A Completeness Theorem for Protocols with Honest Majority</span>
                    <span class="rp_info">1987
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <a class="rp_author" href="../authors/odedgoldreich.html">Oded Goldreich</a> <a class="rp_author" href="../authors/authorpage.html">Silvio Micali</a> <a class="rp_author" href="../authors/authorpage.html">Avi Wigderson</a></span>
						
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a>
								<ol>
									<li><a href="#a_intro">Introduction</a></li>
									<li><a href="#a_goals">Goals and Results</a></li>
									<li><a href="#a_defs">Definitions</a></li>
									<li><a href="#a_theorems">Theorems</a></li>
									<li><a href="#a_protocols">Protocols</a></li>
									<li><a href="#a_ref">Referencing This Paper</a></li>
								</ol>
							</li>
                            <li><a href="#_B">Annotated Paper</a></li>
                        </ol>
                    </div>
					
                    <div class="rp_snippet">
						Our algorithm automatically solves all the multi-party protocol problems addressed in complexity-based cryptography during the last 10 years.
					</div>
						
                    <section id="a_intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Paper Title</b> is...
						</p>
					</section>
					<section id="a_goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							Some goals that they had.
						</p>
						<p class="rp_analysis">
							Don't forget some results, too!
						</p>
					</section>
					<section id="a_defs">
						<h2>Definitions</h2>
						<a href="#def1"><span class="rp_definition_header">Definition 1 - Computational Indistinguishability</span></a>
						<p class="rp_definition">
							Two <span class="definable" data-define="poly-bounded family of random variables">poly-bounded families of RV's</span> are <span class="definable">computationally indistinguishable</span> if, for all <span class="definable" data-define="poly-size family of circuits">poly-size families of circuits</span> \(C\), for all constants \(f&gt;0\) and all sufficiently large \(k\in N\),
						</p>
						<p class="rp_definition">
							$$|P(U,c,k)-P(V,C,k)|&lt;k^{-f}$$
						</p>
					</section>
					<section id="a_theorems">
						<h2>Theorems</h2>
						<p class="rp_original">Some general definitions used by several theorems</p>
						<a href="#theorem1"><span class="rp_theorem_header">Theorem 1</span></a>
						<p class="rp_original rp_theorem">
							A theorem
						</p>
					</section>
					<section id="a_protocol">
						<h2>Protocols</h2>
						<h3><a href="#secxx">Some Protocol Defined</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b></li>
							<li><b>Function(s): </b></li>
							<li><b>Privacy constraints: </b></li>
							<li><b>Security constraints: </b></li>
							<li><b>Cheating: </b></li>
							<li><b>Bits exchanged: </b></li>
							<li><b>Runtime:</b></li>
						</ul>
					</section>
					<section id="a_ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							A reference for this paper
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5"><a id="_B"></a>
                <div class="main_window main_fullwidth">
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a></li>
                            <li>
                                <a href="#_B">Annotated Paper</a>
                                <ol>
									<li value="0"><a href="#abstract">Abstract</a></li>
                                    <li><a href="#sec1">Introduction</a></li>
									<li>
										<a href="#sec2">Preliminary Definitions</a>
										<ol>
											<li><a href="sec2.1">Notation and Conventions for Probabilistic Algorithms</a></li>
											<li><a href="sec2.2">Game Networks and Distributed Algorithms</a></li>
											<li><a href="sec2.3">Adversaries</a></li>
											<li><a href="sec2.4">Indistinguishability of Random Variables</a></li>
										</ol>
									</li>
									<li><a href="#sec3">Tm-games with Passive ADversaries</a></li>
                                </ol>
                            </li>
                        </ol>
                    </div>
					<section id="abstract">
						<h2>Abstract</h2>
						<p class="rp_original">
							We present a polynomial-time algorithm that, given as input the description of a game with incomplete information and any number of players, produces a protocol for playing the game that leaks no partial information, provided the majority of the players is honest.
						</p>
						<p class="rp_original">
							Our algorithm automatically solves all the multi-party protocol problems addressed in complexity-based cryptography during the last 10 years. It actually is a completeness theorem for the class of distributed protocols with honest majority. Such completeness theorem is optimal in the sense that, if the majority of the players is not honest, some protocol problems have no efficient solution.
						</p>
					</section>
					
					<section id="sec1">
						<h2>Introduction</h2>
						<p class="rp_original">
							Before discussing how to “make playable" a general game with incomplete information (which we do in section 6) let us address the problem of making playable a special class of games, the <span class="definable">Turing machine</span> games (<i>Tm-games</i> for short).
						</p>
						<p class="rp_original">
							Informally, \(n\) parties, respectively and individually owning secret inputs \(x_1,\dots,x_n\) would like to <i>correctly</i> run a given Turing machine \(M\) on these \(x_i\)‘s while keeping the maximum possible privacy about them. That is, they want to compute \(y=M(x_1,\dots,x_n)\) without revealing more about the \(x_i\)’s than it is already contained in the value \(y\) itself. For instance, if \(M\) computes the sum of the \(x_i\)’s, every single player should not be able to learn more than the sum of the inputs of the other parties. Here \(M\) may very well be a probabilistic Turing machine. In this case, all player want to agree on a single string \(y\), selected with the right probability distribution, as \(M\)’s output.
						</p>
						<p class="rp_original">
							The correctness and privacy constraint of a Tm-game can be easily met with the help of an extra, <span class="definable">trusted party</span> \(P\). Each player \(i\) simply gives his secret input \(x_i\) to \(P\). \(P\) will privately run the prescribed Turing machine, \(M\), on these inputs and publicly announce \(M\)’s output. Making a Tm-game playable essentially means that the correctness and privacy constraints can be satisfied by the \(n\) players themselves, without invoking any extra party. Proving that Tm-games are playable retains most of the flavor and difficulties of our general theorem.
						</p>
					</section>
					<section id="sec2">
						<h2>Preliminary Definitions</h2>
						<section id="sec2.1">
							<h3>Notation and Conventions for Probabilistic Algorithms</h3>
							<p class="rp_original">
								We emphasize the number of inputs received by an <span class="definable">algorithm</span> as follows. If algorithm \(A\) receives only one input we write “\(A(\cdot)\)", if it receives two inputs we write \(A(\cdot,\cdot)\) and so on.
							</p>
							<p class="rp_original">
								RV will stand for "random variable"; in this paper we only consider RVs that assume values in <span class="equation" data-equation="{0,1}*">\(\{0,1\}^*\)</span>. In fact, we deal almost exclusively with random variables arising from probabilistic algorithms. (We make the natural assumption that all parties may make use of probabilistic methods.)
							</p>
							<p class="rp_original">
								If \(A(\cdot)\) is a probabilistic algorithm, then for any input \(x\) the notation \(A(x)\) refers to the RV which assigns to the string \(\sigma\) the probability that \(A\), on input \(x\) outputs \(\sigma\). If \(S\) is a RV that assigns positive probability only to a single element \(e\), we denote the value \(e\) by \(S\). (For instance, if \(A(\cdot)\) is an algorithm that, on input \(x\) outputs \(x^3\), then we may write \(A(2)=8\). This is in agreement with traditional notation.
							</p>
							<p class="rp_original">
								If \(f(\cdot)\) and \(g(\cdot,\cdots)\) are probabilistic algorithms then \(f(g(\cdot,\cdots))\) is the probabilistic algorithm obtained by composing \(f\) and \(g\) (i.e. running \(f\) on \(g\)'s output). For any inputs \(x,y,\cdots\) the associated RV is denoted \(f(g(x,y,\cdots))\).
							</p>
							<p class="rp_original">
								Let PA denote the set of probabilistic polynomial-time algorithms. We assume that a natural representation of these algorithms as binary strings is used.
							</p>
							<p class="rp_original">
								By \(1^k\) we denote the unary representation of integer \(k\).
							</p>
						</section>
						<section id="sec2.2">
							<h3>Game Networks and Distributed Algorithms</h3>
							<p class="rp_original">
								Let us start by briefly describing the communication networks in which games will be played. This is the standard network supporting the execution of multi-party protocols.
							</p>
							<p class="rp_original">
								Informally, a <span class="definable">game network</span> of size \(n\) is a collection of (interacting) probabilistic polynomial-time Turing machines. Each machine has a private read-only input tape, a private write-only output tape and a private read-write work tape. All machines share a common read-only input tape and a common write-only output tape. The \(n\) machines communicate by means of \(n\cdot(n-1)\) special tapes. Machine \(i\) publically sends messages (strings) to machine \(j\) by means of a special tape \(i \rightarrow j\) on which only \(i\) can write and that all other machines can read. There is a common clock whose pulses define time intervals \(1,2,\dots\). Messages are sent at the beginning of a time interval and are received within the same time interval. We stress, though, that our result is largely independent from the specific communication mechanism, and also holds for "less equipped" communication networks.<sup id="fref1"><a href="#footnote1">(1)</a></sup>
							</p>
							<p class="rp_original">
								A probabilistic distributed algorithm \(S\) running in a game network of size \(n\) is a sequence of programs \(S=(S_1,\dots,S_n)\), where \(S_i\) is the program of the \(i\)-th Turing machine in the network. We denote by PDA the class of all probabilistic polynomial-time distributed algorithms.
							</p>
							<p class="rp_original">
								Let \(S\in PDA\) run in a game network of size \(n\) with common input \(CI\) and (respective) private inputs \(x_1,\dots,x_n\). Then <span class="equation" data-equation="HS">\(HS(x_1,\dots,x_n,CI)\)</span> denotes the RV consisting of the public history that is the sequence of all messages sent in an execution of \(S\); <span class="equation" data-equation="HSi">\(HS_i(x_1,\dots,x_n,CI)\)</span> denotes the RV consisting of the internal configurations of machine \(i\), that is the sequence of the internal configurations of machine \(i\) in an execution of \(S\); for \(T\subset \{1,\dots,n\}\), <span class="equation" data-equation="HST">\(HS_T(x_1,\dots,x_n)\)</span> denotes the vector of the private histories of the members of \(T\) in an execution of \(S\); and <span class="equation" data-equation="OSi">\(OS_i(x_1,\dots,x_n,CI)\)</span> denotes the RV consisting of the private output of machine \(i\) in an execution of \(S\).
							</p>
						</section>
						<section id="sec2.3">
							<h3>Adversaries</h3>
							<p class="rp_original">
								We consider two interesting types of adversaries (faulty machines) in a game network: passive ones (a new notion) and malicious ones (a more standard notion).
							</p>
							<p class="rp_original">
								A <span class="definable">passive adversary</span> is a machine that may compute more than required by its prescribed program, but the messages it sends and what it outputs are in accordance to its original program. (Passive adversaries may be thought of as machines who only try to violate the privacy constraint. They keep on running their prescribed programs correctly, but also run, “on the side”, their favorite polynomial time program to try to compute more than their due share of knowledge. In an election protocol, a passive adversary may be someone who respects the majority’s opinion&mdash;and thus does not want to corrupt the tally&mdash;and yet wants to discover who voted for whom.)
							</p>
							<p class="rp_original">
								A <span class="definable">malicious adversary</span> is, instead, a machine that deviates from its prescribed program in any possible action. That is, we allow the program of such a machine to be replaced by any fixed probabilistic polynomial-time program. (Malicious adversaries not only have a better change of disrupting the privacy constraint, but could also make the outcome of a Tm-game vastly different than in an ideal run with a <span class="definable">trusted party</span>.)
							</p>
							<p class="rp_original">
								We allow machines in a game network to become adversarial in a <span class="definable" data-define="dynamic adversary">dynamic</span> fashion, during the execution of a protocol. We also allow adversarial machines (of either type) to undetectedly cooperate. Adversarial machines are not allowed, however, to monitor the private tapes or the internal state of good machines.
							</p>
							<p class="rp_original">
								We believe the malicious-adversary scenario to be the most adversarial among all the natural scenarios in which cryptography may help.
							</p>
							<p class="rp_original">
								Jumping ahead, we will show that all Tm-games are playable with any number of passive adversaries or with \(&lt;\frac{n}{2}\) malicious adversaries. 
							</p>
						</section>
						<section id="sec2.4">
							<h3>Indistinguishability of Random Variables</h3>
							<p class="rp_original">
								Throughout this paper, we will only consider families of RVs \(U=\{U_k\}\) where the parameter \(k\) ranges in the natural numbers. Let \(U=\{U_k\}\) and \(V=\{V_k\}\) be two families of RVs. The following notion of computational indistinguishability expresses the fact that, when the length of \(k\) increases, \(U_k\) becomes “replaceable” by \(V_k\), in the following sense. A random sample is selected either from \(U\), or from \(V\), and it is handed to a “judge”. After studying the sample, the judge will proclaim his verdict: 0 or 1. (We may interpret 0 as the judge’s decision that that the sample came from \(U_k\); 1 as the decision that the sample came from \(V_k\).) It is then natural to say that \(U_k\) becomes “replaceable” by \(V_k\) for \(k\) large enough if, when \(k\) increases, the verdict of any computationally bounded judge becomes “meaningless”, that is essentially uncorrelated to which of the two distributions the sample came from.
							</p>
							<p class="rp_original">
								To formalize the notion of computational indistinguishability we make use of nonuniformity. Thus, our "judge", rather than polynomial time Turing machine, will be a <span class="definable">poly-size family of circuits</span>. That is a family \(C=\{C_k\}\) of Boolean circuits \(C_k\) with one Boolean output such that, for some constants \(e,d&gt;0\), all \(C_k\in C\) have at most \(k^e\) gates and \(k^d\) Boolean inputs. In order to feed samples from our probability distributions to such circuits, we will consider only <span class="definable" data-define="poly-bounded family of random variables">poly-bounded families of RVs</span>. That is families \(U=\{U_k\}\) such that, for some constant \(e&gt;0\), all RV \(U_k\in U\) assigns positive probability only to strings whose length is exactly \(k^e\). If \(U=\{U_k\}\) is a poly-bounded family of RVs and \(C=\{C_k\}\) a poly-bounded sequence of circuits, we denote by <span class="equation" data-equation="PUCk">\(P(U,C,k)\)</span> the probability that \(C_k\) outputs 1 on input a random string from \(U_k\). (Here we assume that the length of the strings that are assigned positive probability by \(U_k\) equals the number of Boolean inputs of \(C_k\).)
							</p>
							<span class="rp_definition_header" id="def1">Definition 1 - Computational Indistinguishability</span>
							<p class="rp_definition">
								Two <span class="definable" data-define="poly-bounded family of random variables">poly-bounded families of RV's</span> are <span class="definable">computationally indistinguishable</span> if, for all <span class="definable" data-define="poly-size family of circuits">poly-size families of circuits</span> \(C\), for all constants \(f&gt;0\) and all sufficiently large \(k\in N\),
							</p>
							<p class="rp_definition">
								$$|P(U,c,k)-P(V,C,k)|&lt;k^{-f}$$
							</p>
							<p class="rp_original">
								This notion was already used by Goldwasser and Micali<a href="#citation1"><sup class="reference" data-citation="1">[1]</sup></a> in the context of encryption, and by Yao<a href="#citation2"><sup class="reference" data-citation="2">[2]</sup></a> in the context of pseudo-random generation. For other notions of indistinguishability and further discussion see <a href="#citation3"><span class="reference" data-citation="3">[3]</span></a>.
							</p>
							<p class="rp_original">
								<b>Remark 1 - </b>
								Let us point out the robustness of the above definition. In this definition, we are handing out computationally bounded "judge" only samples of size 1. This, however, is not restrictive. It should be noticed that the two families of RVs \(\{U_k\}\) and \(\{V_k\}\) are computationally indistinguishable with respect to samples of size 1 if and only if they are computationally indistinguishable with respect to samples whose size is bounded by a fixed polynomial in \(k\).
							</p>
						</section>
					</section>
					<section id="sec3">
						<h2>Tm-games with Passive Adversaries</h2>
						<p class="rp_original">
							A <span class="definable">Tm-game problem</span> consists of a pair \((\bar{M},1^k)\), that is, the description of a Turing machine \(M\) and an integer \(k\), the security parameter, presented in unary.
						</p>
						<p class="rp_original">
							Let us now make some simplifications that will expedite our exposition. Without loss of generality in our scenario, we assume that, when \((\bar{M},1^k)\) is the common input in a game network, all private inputs have the same length \(l\) and that \(T(l)\), the running time of \(M\) on inputs of size \(l\), is less than \(k\).
						</p>
						<p class="rp_original">
							Let \(S\in PDA\). We say that \(S\) is a <i>Tm-game solver for passive adversaries</i> if, for all Tm-game problems \((\bar{M},1^k)\) given as common input and for all (respective) private inputs \(x_1,\dots,x_n\),
						</p>
						<ol class="rp_original">
							<li value="1">
								<i>(Agreement constraint)</i>
								<p>
									At the end of each execution of \(S\), for all machines \(i\) and \(j\), \(i\)'s private output equals \(j\)'s private output.
								</p>
							</li>
							<li value="2">
								<i>(Correctness constraint)</i>
								<p>
									<span class="equation" data-equation="OSi">\(OS_1(x_1,\dots,x_n,(\bar{M},1^k))\)</span>\(=M(x_1,\dots,x_n)\), and
								</p>
							</li>
							<li value="3">
								<i>(Privacy constraint)</i>
								<p>
									\(\forall T\subset\{1,\dots,n\}\) and \(\forall A\in PPT, \exists B\in PPT\) such that \(\{A_k\}\) and \(\{B_k\}\) are computationally undistinguishable RVs. Here</p>
								<p>
									\(A_k=A((\bar{M},1^k),\)<span class="equation" data-equation="HS">\(HS((\bar{M},1^k))\)</span>,<span class="equation" data-equation="HST">\(HS_T((\bar{M},1^k))\)</span>\()\)
								</p>
								<p>and</p>
								<p>
								\(B_k=B((\bar{M},1^k),M(x_1,\dots,x_n),\{(i,x_i):i\in T\})\)
								</p>
							</li>
						</ol>
						<p class="rp_original">Let us now interpret the above definition</p>
						<h5>The agreement constraint</h5>
						<p class="rp_original">
							This constraint essentially says that all machines agree on a single, common string as the output of \(S\).
						</p>
						<h5>The correctness constraint</h5>
						<p class="rp_original">
							This constraint ensures that the output of a game solver \(S\) coincides with the one of \(M\). As \(M\) may be probabilistic, the equality of the correctness constraint must be interpreted as equality between RVs.
						</p>
						<h5>The privacy constraint</h5>
						<p class="rp_original">
							Notice that passive adversaries appear in the above definition in an implicit way. Algorithm \(A\) can be thought as all the members of \(T\) being passive adversaries computing after an execution of \(S\). In fact, passive adversaries are obliged to send messages according to \(S\) and their private history, in an execution of \(S\), as an explicit input to \(A\). Let us stress that the privat history of a machine \(i\) contains the name \(i\), the private input \(x_i\), and \(M\)'s output as well. Thus the privacy constraint essentially says that whatever the passive adversaries may compute after computing \(S\), they could also easily deduce from the desired \(M\)'s output \(y\) and their own private inputs (which they are entitled to have!). In fact, if they are given \(y\) by running \(S\), the passive adversaries will see, in addition to \(y\), only the public history and their own private history. However, whatever they could efficiently compute with this additional input, they could also have computer without it. In other words, \(S\) keeps whatever privacy of the inputs of the good parties is not "betrayed" by the value of \(y\) itself. For instance, if \(M\) computes the sum of the \(x_i\)'s, then the privacy constraint will allow the adversarial players to compute (at the end of \(S\)) essentially only the sum of the inputs of the good parties. As for another example, if \(M\) is the identity function, then the privacy constraint holds vacuously. Same if the set \(T\) is the set of all players.
						</p>
					</section>
                </div>
            </div>
			<div class="main_toplevel main_section main_color7">
                <h1>Footnotes</h1>
				
                <ol id="footnotes">
                    <li id="footnote1">
						<a href="#fref1">[^]</a> For instance, there may be only one communication tape. In this case, digital signatures can be used to authenticate the sender. In case that not all machines may read all communication tapes, Byzantine agreement can be used to simulate the fact that all processors agree on what message machine \(i\) has sent to machine \(j\) at time \(t\). The common clock may be replaced by local clocks that don't drift "too much". The quite tight synchrony of the message delivery can be replaced by a feasible upper bound on the time it takes a message to be delivered, and so on.
					</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color8">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="citation1">
						S. Goldwasser, and S. Micali, <i>Probabilistic Encryption</i>, JCSS Vol. 28, No. 2, April 1984.
						<p>
							An earlier version (containing other results) was titled <i>Probabilistic Encryption and How to Play Mental Poker Hiding All Partial Information</i>
						</p>
					</li>
					<li id="citation2">
						A. Yao, <i>Theory and Application of Trapdoor Functions</i>, Proc. of 23rd FOCS, IEEE, Nov., 1982, pp. 80-91.
					</li>
					<li id="citation3">
						S. Goldwasser, S. Micali and C. Rackoff, <i>The Knowledge Complexity of Interactive Proof-Systems</i>, To appear SIAM J. on Computing (manuscript available from authors).
						<p>
							Earlier version in Proc. 17th Annual ACM Symp. on Theory of Computing, pp 291-304.
						</p>
					</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+###@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Copyright &copy; Nicolas Schank 2014, Brown University</p>
            </div>
        </div>
    </body>
</html>