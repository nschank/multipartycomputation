<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result - David Chaum, Ivan B. Damgård, Jeroen van de Graaf, 1988</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					default:
						return "No info on this equation yet.";
				}
			}

			function authorLink(ref)
			{
				switch (ref)
				{
					default:
						return "#";
				}
			}

			self_def["non-general word"] = "definition";
			//-->
        </script>
    </head>
    <body>
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth" id="_A">
                    <div class="rp_linkbox"><a href="pdf/82.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result</span>
                    <span class="rp_info">1988
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/David Chaum.html">David Chaum</a>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/Ivan Damgård.html">Ivan Damgård</a>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/Jeroen van de Graaf.html">Jeroen van de Graaf</a>
					</span>
					
					<div class="rp_snippet">
						&ldquo;&rdquo;
					</div>
						
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a>
								<ol>
									<li><a href="#intro">Introduction</a></li>
									<li><a href="#goals">Goals and Results</a></li>
									<li><a href="#assumptions">Assumptions</a></li>
									<li><a href="#defs">Definitions</a></li>
									<li><a href="#theorems">Theorems</a></li>
									<li><a href="#protocols">Protocols</a></li>
									<li><a href="#further">Further Reading</a></li>
									<li><a href="#ref">Referencing This Paper</a></li>
								</ol>
							</li>
                            <li><a href="#_B">Annotated Paper</a></li>
                        </ol>
                    </div>
					
					<h1>Overview</h1>	
                    <section id="intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Paper Title</b> is...
						</p>
					</section>
					<section id="goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							Some goals that they had.
						</p>
						<p class="rp_analysis">
							Don't forget some results, too!
						</p>
					</section>
					<section id="assumptions">
						<h2>Assumptions</h2>
					</section>
					<section id="defs">
						<h2>Definitions</h2>
						<a href="#def1"><span class="rp_definition_header">Definition 1 - </span></a>
						<p class="rp_original rp_definition">
							A definition 
						</p>
					</section>
					<section id="theorems">
						<h2>Theorems</h2>
						<p class="rp_original">Some general definitions used by several theorems</p>
						<a href="#theorem1"><span class="rp_theorem_header">Theorem 1</span></a>
						<p class="rp_original rp_theorem">
							A theorem
						</p>
					</section>
					<section id="protocol">
						<h2>Protocols</h2>
						<h3><a href="#secxx">Some Protocol Defined</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b></li>
							<li><b>Function(s): </b></li>
							<li><b>Privacy constraints: </b></li>
							<li><b>Security constraints: </b></li>
							<li><b>Cheating: </b></li>
							<li><b>Bits exchanged: </b></li>
							<li><b>Subprotocols: </b></li>
							<li><b>Runtime:</b></li>
							<li><b>Assumptions:</b></li>
						</ul>
					</section>
					<section id="further">
						<h2>Further Reading</h2>
					</section>
					<section id="ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							A reference for this paper
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5" id="_B">
                <div class="main_window main_fullwidth">
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a></li>
                            <li>
                                <a href="#_B">Annotated Paper</a>
                                <ol>
                                    <li><a href="#sec1">Introduction</a></li>
									<li><a href="#sec2">Overview of the Protocol</a></li>
									<li><a href="#sec3">Bit Commitment Schemes</a></li>
                                </ol>
                            </li>
                        </ol>
                    </div>
					<section id="summary">
						<h2>Summary</h2>
						<p class="rp_original">
							A protocol is presented that allows a set of parties to collectively perform any agreed computation, where every party is able to choose secret inputs and verify that the resulting output is correct, and where all secret inputs are optimally protected.
						</p>
						<p class="rp_original">
							The protocol has the following properties:
						</p>
						<ul class="rp_original">
							<li>One participant is allowed to hide his secrets <i>unconditionally</i>, i.e. the protocol releases no Shannon information about these secrets. This means that a participant with bounded resources can perform computations securely with a participant who may have unlimited computing power. To the best of our knowledge, our protocol is the first of its kind to provide this possibility.</li>
							<li>The cost of our protocol is linear in the number of gates in a circuit performing the computation, and in the number of participants. We believe it is conceptually simpler and more efficient than other protocols solving related problems<sup class="reference" data-citation="1"><a href="#citation1">[1]</a></sup><sup class="reference" data-citation="2"><a href="#citation2">[2]</a></sup><sup class="reference" data-citation="3"><a href="#citation3">[3]</a></sup>. It therefore leads to practical solutions on problems involving small circuits.</li>
							<li>The protocol is <i>openly verifiable</i>, i.e. any number of people can later come in and rechallenge any participant to verify that no cheating has occurred.</li>
							<li>The protocol is optimally secure against conspiracies: even if \(n-1\) out of the \(n\) participants collude, they will not find out more about the remaining participants' secrets than what they could already infer from their own input and the public output.</li>
							<li>Each participant has a chance of undetected cheating that is only exponentially small in the amount of time and space needed for the protocol.</li>
							<li>The protocol adapts easily, and with negligible extra cost, to various additional requirements, e.g. making part of the output private to some participant, ensuring that the participants learn the output simultaneously, etc.</li>
							<li>Participants can prove relations between data used in different instances of the protocol, even if those instances involve different groups of participants. For example, it can be proved that the output of one computation was used as input to another, without revealing more about this data.</li>
							<li>The protocol can be used as an essential tool in proving that all languages in IP have zero knowledge proof systems, i.e. any statement which can be proved interactively can also be proved in zero knowledge.</li>
						</ul>
						<p class="rp_original">
							The rest of this paper is organized as follows: First we survey some related results. Then <a href="#sec2">Section 2</a> gives an intuitive introduction to the protocol. In <a href="#sec3">Section 3</a>, we present one of the main tools used in this paper: bit commitment schemes. Sections <a href="#sec4">4</a> and <a href="#sec5">5</a> contain the notation, terminology, etc. used in the paper. In <a href="#sec6">Section 6</a>, the protocol is presented, along with proofs of its security and correctness. In <a href="#sec7">Section 7</a>, we show how to adapt the protocol to various extra requirements and discuss some generalizations and optimizations. Finally, <a href="#sec8">Section 8</a> contains some remarks on how to construct zero knowledge proof systems for any language in IP.
						</p>
					</section>
                    <section id="sec1">
                        <h2>1. Related Work</h2>
						<p class="rp_original">
							The problem of multiparty secure computations is an important one. When stated in its most general form, its solution implies a solution&mdash;at least a theoretical one&mdash;to almost any protocol construction problem. The first to consider this problem was Yao<sup class="reference" data-citation="4"><a href="#citation4">[4]</a></sup>. He devised protocols that, under various cryptographic assumptions, could keep the inputs secret while allowing each participant only a negligible chance of cheating. He did not, however, address the problem of "fairness", i.e. ensuring that the participants learn the output simultaneously. Layer, Yao<span class="reference" data-citation="1"><a href="#citation1">[1]</a></span> solved also this problem for the two-party case. Recently, in work done independently from (but earlier than) ours, Goldreich, Micali, and Wigderson<sup class="reference" data-citation="2"><a href="#citation2">[2]</a></sup> used Yao's two-party construction to devise a multiparty solution, based on the existence of a trapdoor one-way function. This protocol implements a multiparty simulation of the computation in a circuit. Each participant holds a share of each bit in the real computation, and these shares are manipulated by using Yao's two-party construction \(O(n^2)\) times, where \(n\) is the number of participants. In other work done independently from and almost simultaneously with ours, Galil, Haber, and Yung generalize all the properties of Yao's construction to the multiparty case, and simplify the use of Yao's protocol in the multiparty simulation. Also, they give a concrete construction based on Diffie-Hellman key exchange rather than the existence of a trapdoor one way function. Very recently, Goldreich and Vainish<sup class="reference" data-citation="5"><a href="#citation5">[5]</a></sup> found another simplification by designing a special purpose two-party protocol which could replace Yao's protocol in the multiparty construction.
						</p>
						<p class="rp_original">
							In comparison, our protocol solves the multiparty case using a totally different concept. It attacks the problem "directly", without using Yao's two-party protocol, and without using reductions to 3-colorability<sup class="reference" data-citation="6"><a href="#citation6">[6]</a></sup> or to SAT<sup class="reference" data-citation="7"><a href="#citation7">[7]</a></sup><sup class="reference" data-citation="8"><a href="#citation8">[8]</a></sup> to prove the validity of messages. We rely on a stronger cryptographic assumption than <span class="reference" data-citation="2"><a href="#citation2">[2]</a></span>, namely the <i>Quadratic Residuosity Assumption</i><sup class="reference" data-citation="9"><a href="#citation9">[9]</a></sup>. This, however, allows a simpler and more efficient construction, capable of implementing all the "primitives for cryptographic computations", defined in <span class="reference" data-citation="3"><a href="#citation3">[3]</a></span>. Although our protocol could also be based only on the existence of a trapdoor one-way function, this would reduce the efficiency considerably. Some of the techniques upon which our protocol is based were previously developed and used in the work of Chaum<sup class="reference" data-citation="8"><a href="#citation8">[8]</a></sup> and Brassard and Crépeau<sup class="reference" data-citation="7"><a href="#citation7">[7]</a></sup>. By specializing to the case where only one participant supplies the inputs, our protocol can provide slightly more efficient solutions to the problems solved there.
						</p>
						<p class="rp_original">
							An interesting consequence of our work is that any statement which can be proved interactively, can also be proved in zero knowledge, provided that our cryptographic assumption holds (one assumption which will do in this case is the existence of clawfree trapdoor functions). More formally: any language in IP has a zero knowledge proof system. This result was already proved for protocols with a constant number of rounds in <span class="reference" data-citation="6"><a href="#citation6">[6]</a></span>, where a proof of the result in full generality is attributed to Ben-Or. As far as we know, this last proof is still unpublished, so we cannot comment on possible differences between this proof and ours.
						</p>
                    </section>
					<section id="sec2">
						<h2>2. Overview of the Constructions</h2>
						<p class="rp_original">
							For the intuitive sketch given in this section, we wdl make some simplifications. We will consider only two parties, \(A\) and \(B\) and we will do a computation on one AND-gate only. At the end of the section we will see how this method can be generalised to more parties, and to a computation consisting of many gates.
						</p>
						<p class="rp_original">
							Note that this AND-gate computation, where both parties want to hide their input from each other, has a meaningful application: consider the situation where Alice and Bob have just met, and each considers dating the other. Neither wishes to lose face in the following sense: if Alice wants a date but Bob doesn't, Alice does not want to let Bob know that she wanted the date. And the same holds for Bob. In other words: if a party does not want the date, they do not find out the other party's decision.
						</p>
						<p class="rp_original">
							Note that sometimes a party can derive the other's input just by combining his own input and the output of the joint computation. This can never be avoided, however.
						</p>
						<p class="rp_original">
							The AND-gate is represented by a truth-table \(T\). We will show what transformations \(A\) and \(B\) have to apply to \(T\) in order to compute the logical AND, such that
						</p>
						<ul class="rp_original">
							<li>both parties can be sure (with very high probability) that the transformations are done correctly;</li>
							<li>both parties can keep their input hidden from the other party; and</li>
							<li>both parties can be sure the result of the computation is correct.</li>
						</ul>
						<h3>The Protocol</h3>
						<ol class="rp_original">
							<li>
								<ol class="rp_original">
									<li>\(A\)(lice) applies a randomly chosen permutation, \(\sigma_j\), to the rows of \(T\).</li>
									<li>\(A\) chooses two bits \(b_1\) and \(b_3\), and uses these to compute the XOR of the \(k\)th column and \(b_k\). This procedure is known as <i>inversion of columns</i>.</li>
									<li>\(A\) chooses four bits \(d_1\cdots d_4\), and computes the XOR of the \(l\)th entry in the last column and \(d_l\). This procedure is known as <i>encryption the output column</i>.</li>
									<li>\(A\) encrypts \(b_1,b_3,d_1\cdots d_4\) in such a way that she cannot disavow these values later, while \(B\)(ob) cannot see what the values are without \(A\)'s help. This is known as <i>committing to the bits</i>.</li>
								</ol>
							</li>
						</ol>
						<p class="rp_original">
							We will indicate the final result of these steps with \(\hat{T}\). \(B\) will verify whether \(\hat{T}\) was constructed correctly in the next steps:
						</p>
						<ol class="rp_original">
							<li value="2">\(A\) creates a transformed truthtable \(T'\) in exactly the same way as she created \(\hat{T}\).</li>
						</ol>
						<img class="rp_original" src="../../img/82.fig1.jpg" alt="Steps 1.1 through 1.4" />
						<ol class="rp_original">
							<li value="3">
								\(B\) flips a coin.
								<ul class="rp_original">
									<li>If the coin came out heads, \(A\) must reveal exactly how she constructed \(T'\), so that \(B\) can verify that this was done correctly.</li>
									<li>If the coin came out tails, \(A\) must show a special relation between \(\hat{T}\) and \(T'\). Details on this can be found in <a href="#sec6.1">Section 6.1</a>. Here, it suffices to know that if the relation holds, it implies that \(\hat{T}\) was correctly constructed if and only if \(T'\) was.</li>
								</ul>
							</li>
						</ol>
						<p class="rp_original">
							After \(m\) repetitions of steps 2 and 3, \(B\) is convinced with very high probability that \(A\) constructed \(\hat{T}\) correctly. Now \(B\) will do to \(\hat{T}\) what \(A\) did to \(T\), and even more:
						</p>
						<ol class="rp_original">
							<li value="4">
								<ol class="rp_original">
									<li>
										\(B\) permutes the rows of \(\hat{T}\), together with the commitments of the output column entries.
										<img alt="The row-permutation performed by \(B\)" class="rp_original" src="../../img/82.fig2.jpg" />
									</li>
									<li>\(B\) flips a coin for each output column entry and applies the XOR.</li>
									<li>
										\(B\) computes, <i>using \(A\)'s bit commitment scheme</i>, a commitment containing the XOR of his own bit and the one chosen and committed to by \(A\) for this output column entry. Although \(A\) can later open the resulting commitment, he will have no idea which of his original commitments it was computed from. This requires special properties of the commitment scheme used.
										<img alt="The blinding" class="rp_original" src="../../img/82.fig3.jpg" />
									</li>
								</ol>
							</li>
						</ol>
						<p class="rp_original">
							This <i>blinding</i> is necessary to hide \(B\)'s permutation. \(B\) also has to do a transformation corresponding exactly to the one of \(A\):
						</p>
						<ol class="rp_original">
							<li value="4">
								<ol class="rp_original">
									<li value="4">\(B\) chooses bits for inversion of his own input column, and for the output column.</li>
									<li>\(B\) chooses bits for inversion of each output column entry</li>
									<li>\(B\) commits to the bits chosen in steps 4.4 and 4.5. He then sends his final result, \(T^*\), to \(A\).
									<img alt="The final part of \(B\)'s transformation." class="rp_original" src="../../img/82.fig4.jpg" /></li>
								</ol>
							</li>
							<li>In the same way as in steps 2 and 3, \(B\) convinces \(A\) that \(T^*\) was constructed correctly.</li>
						</ol>
						<p class="rp_original">
							Now \(A\) and \(B\) have together constructed a double-blinded version \(T^*\) of the gate that satisfies the conditions listed before step 1. They will use \(T^*\) in performing the computation as follows:
						</p>
						<ol class="rp_original">
							<li value="6">Together they select the correct row of \(T^*\) by announcing their choice of input bits for \(T^*\). These input bits are the XOR sum of the "real" input bits, and the inversion bits for the corresponding columns.</li>
							<li>\(A\) and \(B\) both reveal the inversion bit for the output column, and the inversion bit for the entry in the output column which is in the selected row. By XORing this output column entry with the revealed inversion bits, they can both compute the bit that is the result of the computation.</li>
						</ol>
						<p class="rp_original">
							This basic protocol can be generalized in several ways:
						</p>
						<ul class="rp_original">
							<li>Instead of using an AND-gate, any type of gate can be used.</li>
							<li>Instead of two parties, any number of parties can participate in the protocol. Each new party just has to follow \(B\)'s part of the protocol, and will thus have to blind the commitments of each participant who went before.</li>
							<li>Instead of using only one gate, a computation involving arbitrarily many gates can be done with the protocol. The only condition is that when gate \(T_1\) is connected to \(T_2\), then their corresponding output column and input column were inverted using the <i>same</i> bits. When later a row is selected in the encrypted version of \(T_1\), the inversion bits that apply to the single output column entry will be revealed, while the column inversion bits will remain secret. The revealed inversion bits are now XORed with the output column entry selected, and the result can be used directly as an input bit to the encryption version of \(T_2\).</li>
						</ul>
					</section>
					<section id="sec3">
						<h2>3. Bit Commitment Schemes</h2>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color8">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="citation1">Y1</li>
					<li id="citation2">GoMiWi</li>
					<li id="citation3">GaHaYu</li>
					<li id="citation4">Y2</li>
					<li id="citation5">GoVa</li>
					<li id="citation6">GoMiWi2</li>
					<li id="citation7">BrCr</li>
					<li id="citation8">Ch</li>
					<li id="citation9">GoMi</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+82@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Created by Nicolas Schank 2014, Brown University</p>
				<p>All original work is free for any use by anyone whatsoever.</p>
				<p>For more information about liability and licensing Yao's original paper, see <a href="../liability.html">Liability</a>.</p>
            </div>
        </div>
    </body>
</html>