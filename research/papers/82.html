<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result - David Chaum, Ivan B. Damgård, Jeroen van de Graaf, 1988</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					default:
						return "No info on this equation yet.";
				}
			}

			function authorLink(ref)
			{
				switch (ref)
				{
					default:
						return "#";
				}
			}

			self_def["non-general word"] = "definition";
			//-->
        </script>
    </head>
    <body>
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth" id="_A">
                    <div class="rp_linkbox"><a href="pdf/82.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result</span>
                    <span class="rp_info">1988
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/David Chaum.html">David Chaum</a>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/Ivan Damgård.html">Ivan Damgård</a>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/Jeroen van de Graaf.html">Jeroen van de Graaf</a>
					</span>
					
					<div class="rp_snippet">
						&ldquo;&rdquo;
					</div>
						
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a>
								<ol>
									<li><a href="#intro">Introduction</a></li>
									<li><a href="#goals">Goals and Results</a></li>
									<li><a href="#assumptions">Assumptions</a></li>
									<li><a href="#defs">Definitions</a></li>
									<li><a href="#theorems">Theorems</a></li>
									<li><a href="#protocols">Protocols</a></li>
									<li><a href="#further">Further Reading</a></li>
									<li><a href="#ref">Referencing This Paper</a></li>
								</ol>
							</li>
                            <li><a href="#_B">Annotated Paper</a></li>
                        </ol>
                    </div>
					
					<h1>Overview</h1>	
                    <section id="intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Paper Title</b> is...
						</p>
					</section>
					<section id="goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							Some goals that they had.
						</p>
						<p class="rp_analysis">
							Don't forget some results, too!
						</p>
					</section>
					<section id="assumptions">
						<h2>Assumptions</h2>
					</section>
					<section id="defs">
						<h2>Definitions</h2>
						<a href="#def1"><span class="rp_definition_header">Definition 1 - </span></a>
						<p class="rp_original rp_definition">
							A definition 
						</p>
					</section>
					<section id="theorems">
						<h2>Theorems</h2>
						<p class="rp_original">Some general definitions used by several theorems</p>
						<a href="#theorem1"><span class="rp_theorem_header">Theorem 1</span></a>
						<p class="rp_original rp_theorem">
							A theorem
						</p>
					</section>
					<section id="protocol">
						<h2>Protocols</h2>
						<h3><a href="#secxx">Some Protocol Defined</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b></li>
							<li><b>Function(s): </b></li>
							<li><b>Privacy constraints: </b></li>
							<li><b>Security constraints: </b></li>
							<li><b>Cheating: </b></li>
							<li><b>Bits exchanged: </b></li>
							<li><b>Subprotocols: </b></li>
							<li><b>Runtime:</b></li>
							<li><b>Assumptions:</b></li>
						</ul>
					</section>
					<section id="further">
						<h2>Further Reading</h2>
					</section>
					<section id="ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							A reference for this paper
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5" id="_B">
                <div class="main_window main_fullwidth">
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a></li>
                            <li>
                                <a href="#_B">Annotated Paper</a>
                                <ol>
                                    <li><a href="#sec1">Introduction</a></li>
									<li><a href="#sec2">Overview of the Protocol</a></li>
									<li><a href="#sec3">Bit Commitment Schemes</a>
										<ol>
											<li><a href="#sec3.1">Examples</a></li>
										</ol>
									</li>
									<li><a href="#sec4">Protocols: notation and definitions</a>
										<ol>
											<li><a href="#sec4.1">Correctness and Security</a></li>
										</ol>
									</li>
									<li><a href="#sec5">Circuits, terminology, and notation</a></li>
                                </ol>
                            </li>
                        </ol>
                    </div>
					<section id="summary">
						<h2>Summary</h2>
						<p class="rp_original">
							A protocol is presented that allows a set of parties to collectively perform any agreed computation, where every party is able to choose secret inputs and verify that the resulting output is correct, and where all secret inputs are optimally protected.
						</p>
						<p class="rp_original">
							The protocol has the following properties:
						</p>
						<ul class="rp_original">
							<li>One participant is allowed to hide his secrets <i>unconditionally</i>, i.e. the protocol releases no Shannon information about these secrets. This means that a participant with bounded resources can perform computations securely with a participant who may have unlimited computing power. To the best of our knowledge, our protocol is the first of its kind to provide this possibility.</li>
							<li>The cost of our protocol is linear in the number of gates in a circuit performing the computation, and in the number of participants. We believe it is conceptually simpler and more efficient than other protocols solving related problems<sup class="reference" data-citation="1"><a href="#citation1">[1]</a></sup><sup class="reference" data-citation="2"><a href="#citation2">[2]</a></sup><sup class="reference" data-citation="3"><a href="#citation3">[3]</a></sup>. It therefore leads to practical solutions on problems involving small circuits.</li>
							<li>The protocol is <i>openly verifiable</i>, i.e. any number of people can later come in and rechallenge any participant to verify that no cheating has occurred.</li>
							<li>The protocol is optimally secure against conspiracies: even if \(n-1\) out of the \(n\) participants collude, they will not find out more about the remaining participants' secrets than what they could already infer from their own input and the public output.</li>
							<li>Each participant has a chance of undetected cheating that is only exponentially small in the amount of time and space needed for the protocol.</li>
							<li>The protocol adapts easily, and with negligible extra cost, to various additional requirements, e.g. making part of the output private to some participant, ensuring that the participants learn the output simultaneously, etc.</li>
							<li>Participants can prove relations between data used in different instances of the protocol, even if those instances involve different groups of participants. For example, it can be proved that the output of one computation was used as input to another, without revealing more about this data.</li>
							<li>The protocol can be used as an essential tool in proving that all languages in IP have zero knowledge proof systems, i.e. any statement which can be proved interactively can also be proved in zero knowledge.</li>
						</ul>
						<p class="rp_original">
							The rest of this paper is organized as follows: First we survey some related results. Then <a href="#sec2">Section 2</a> gives an intuitive introduction to the protocol. In <a href="#sec3">Section 3</a>, we present one of the main tools used in this paper: bit commitment schemes. Sections <a href="#sec4">4</a> and <a href="#sec5">5</a> contain the notation, terminology, etc. used in the paper. In <a href="#sec6">Section 6</a>, the protocol is presented, along with proofs of its security and correctness. In <a href="#sec7">Section 7</a>, we show how to adapt the protocol to various extra requirements and discuss some generalizations and optimizations. Finally, <a href="#sec8">Section 8</a> contains some remarks on how to construct zero knowledge proof systems for any language in IP.
						</p>
					</section>
                    <section id="sec1">
                        <h2>1. Related Work</h2>
						<p class="rp_original">
							The problem of multiparty secure computations is an important one. When stated in its most general form, its solution implies a solution&mdash;at least a theoretical one&mdash;to almost any protocol construction problem. The first to consider this problem was Yao<sup class="reference" data-citation="4"><a href="#citation4">[4]</a></sup>. He devised protocols that, under various cryptographic assumptions, could keep the inputs secret while allowing each participant only a negligible chance of cheating. He did not, however, address the problem of "fairness", i.e. ensuring that the participants learn the output simultaneously. Layer, Yao<span class="reference" data-citation="1"><a href="#citation1">[1]</a></span> solved also this problem for the two-party case. Recently, in work done independently from (but earlier than) ours, Goldreich, Micali, and Wigderson<sup class="reference" data-citation="2"><a href="#citation2">[2]</a></sup> used Yao's two-party construction to devise a multiparty solution, based on the existence of a trapdoor one-way function. This protocol implements a multiparty simulation of the computation in a circuit. Each participant holds a share of each bit in the real computation, and these shares are manipulated by using Yao's two-party construction \(O(n^2)\) times, where \(n\) is the number of participants. In other work done independently from and almost simultaneously with ours, Galil, Haber, and Yung generalize all the properties of Yao's construction to the multiparty case, and simplify the use of Yao's protocol in the multiparty simulation. Also, they give a concrete construction based on Diffie-Hellman key exchange rather than the existence of a trapdoor one way function. Very recently, Goldreich and Vainish<sup class="reference" data-citation="5"><a href="#citation5">[5]</a></sup> found another simplification by designing a special purpose two-party protocol which could replace Yao's protocol in the multiparty construction.
						</p>
						<p class="rp_original">
							In comparison, our protocol solves the multiparty case using a totally different concept. It attacks the problem "directly", without using Yao's two-party protocol, and without using reductions to 3-colorability<sup class="reference" data-citation="6"><a href="#citation6">[6]</a></sup> or to SAT<sup class="reference" data-citation="7"><a href="#citation7">[7]</a></sup><sup class="reference" data-citation="8"><a href="#citation8">[8]</a></sup> to prove the validity of messages. We rely on a stronger cryptographic assumption than <span class="reference" data-citation="2"><a href="#citation2">[2]</a></span>, namely the <i>Quadratic Residuosity Assumption</i><sup class="reference" data-citation="9"><a href="#citation9">[9]</a></sup>. This, however, allows a simpler and more efficient construction, capable of implementing all the "primitives for cryptographic computations", defined in <span class="reference" data-citation="3"><a href="#citation3">[3]</a></span>. Although our protocol could also be based only on the existence of a trapdoor one-way function, this would reduce the efficiency considerably. Some of the techniques upon which our protocol is based were previously developed and used in the work of Chaum<sup class="reference" data-citation="8"><a href="#citation8">[8]</a></sup> and Brassard and Crépeau<sup class="reference" data-citation="7"><a href="#citation7">[7]</a></sup>. By specializing to the case where only one participant supplies the inputs, our protocol can provide slightly more efficient solutions to the problems solved there.
						</p>
						<p class="rp_original">
							An interesting consequence of our work is that any statement which can be proved interactively, can also be proved in zero knowledge, provided that our cryptographic assumption holds (one assumption which will do in this case is the existence of clawfree trapdoor functions). More formally: any language in IP has a zero knowledge proof system. This result was already proved for protocols with a constant number of rounds in <span class="reference" data-citation="6"><a href="#citation6">[6]</a></span>, where a proof of the result in full generality is attributed to Ben-Or. As far as we know, this last proof is still unpublished, so we cannot comment on possible differences between this proof and ours.
						</p>
                    </section>
					<section id="sec2">
						<h2>2. Overview of the Constructions</h2>
						<p class="rp_original">
							For the intuitive sketch given in this section, we wdl make some simplifications. We will consider only two parties, \(A\) and \(B\) and we will do a computation on one AND-gate only. At the end of the section we will see how this method can be generalised to more parties, and to a computation consisting of many gates.
						</p>
						<p class="rp_original">
							Note that this AND-gate computation, where both parties want to hide their input from each other, has a meaningful application: consider the situation where Alice and Bob have just met, and each considers dating the other. Neither wishes to lose face in the following sense: if Alice wants a date but Bob doesn't, Alice does not want to let Bob know that she wanted the date. And the same holds for Bob. In other words: if a party does not want the date, they do not find out the other party's decision.
						</p>
						<p class="rp_original">
							Note that sometimes a party can derive the other's input just by combining his own input and the output of the joint computation. This can never be avoided, however.
						</p>
						<p class="rp_original">
							The AND-gate is represented by a truth-table \(T\). We will show what transformations \(A\) and \(B\) have to apply to \(T\) in order to compute the logical AND, such that
						</p>
						<ul class="rp_original">
							<li>both parties can be sure (with very high probability) that the transformations are done correctly;</li>
							<li>both parties can keep their input hidden from the other party; and</li>
							<li>both parties can be sure the result of the computation is correct.</li>
						</ul>
						<h3>The Protocol</h3>
						<ol class="rp_original">
							<li>
								<ol class="rp_original">
									<li>\(A\)(lice) applies a randomly chosen permutation, \(\sigma_j\), to the rows of \(T\).</li>
									<li>\(A\) chooses two bits \(b_1\) and \(b_3\), and uses these to compute the XOR of the \(k\)th column and \(b_k\). This procedure is known as <i>inversion of columns</i>.</li>
									<li>\(A\) chooses four bits \(d_1\cdots d_4\), and computes the XOR of the \(l\)th entry in the last column and \(d_l\). This procedure is known as <i>encryption the output column</i>.</li>
									<li>\(A\) encrypts \(b_1,b_3,d_1\cdots d_4\) in such a way that she cannot disavow these values later, while \(B\)(ob) cannot see what the values are without \(A\)'s help. This is known as <i>committing to the bits</i>.</li>
								</ol>
							</li>
						</ol>
						<p class="rp_original">
							We will indicate the final result of these steps with \(\hat{T}\). \(B\) will verify whether \(\hat{T}\) was constructed correctly in the next steps:
						</p>
						<ol class="rp_original">
							<li value="2">\(A\) creates a transformed truthtable \(T'\) in exactly the same way as she created \(\hat{T}\).</li>
						</ol>
						<img class="rp_original" src="../../img/82.fig1.jpg" alt="Steps 1.1 through 1.4" />
						<ol class="rp_original">
							<li value="3">
								\(B\) flips a coin.
								<ul class="rp_original">
									<li>If the coin came out heads, \(A\) must reveal exactly how she constructed \(T'\), so that \(B\) can verify that this was done correctly.</li>
									<li>If the coin came out tails, \(A\) must show a special relation between \(\hat{T}\) and \(T'\). Details on this can be found in <a href="#sec6.1">Section 6.1</a>. Here, it suffices to know that if the relation holds, it implies that \(\hat{T}\) was correctly constructed if and only if \(T'\) was.</li>
								</ul>
							</li>
						</ol>
						<p class="rp_original">
							After \(m\) repetitions of steps 2 and 3, \(B\) is convinced with very high probability that \(A\) constructed \(\hat{T}\) correctly. Now \(B\) will do to \(\hat{T}\) what \(A\) did to \(T\), and even more:
						</p>
						<ol class="rp_original">
							<li value="4">
								<ol class="rp_original">
									<li>
										\(B\) permutes the rows of \(\hat{T}\), together with the commitments of the output column entries.
										<img alt="The row-permutation performed by \(B\)" class="rp_original" src="../../img/82.fig2.jpg" />
									</li>
									<li>\(B\) flips a coin for each output column entry and applies the XOR.</li>
									<li>
										\(B\) computes, <i>using \(A\)'s bit commitment scheme</i>, a commitment containing the XOR of his own bit and the one chosen and committed to by \(A\) for this output column entry. Although \(A\) can later open the resulting commitment, he will have no idea which of his original commitments it was computed from. This requires special properties of the commitment scheme used.
										<img alt="The blinding" class="rp_original" src="../../img/82.fig3.jpg" />
									</li>
								</ol>
							</li>
						</ol>
						<p class="rp_original">
							This <i>blinding</i> is necessary to hide \(B\)'s permutation. \(B\) also has to do a transformation corresponding exactly to the one of \(A\):
						</p>
						<ol class="rp_original">
							<li value="4">
								<ol class="rp_original">
									<li value="4">\(B\) chooses bits for inversion of his own input column, and for the output column.</li>
									<li>\(B\) chooses bits for inversion of each output column entry</li>
									<li>\(B\) commits to the bits chosen in steps 4.4 and 4.5. He then sends his final result, \(T^*\), to \(A\).
									<img alt="The final part of \(B\)'s transformation." class="rp_original" src="../../img/82.fig4.jpg" /></li>
								</ol>
							</li>
							<li>In the same way as in steps 2 and 3, \(B\) convinces \(A\) that \(T^*\) was constructed correctly.</li>
						</ol>
						<p class="rp_original">
							Now \(A\) and \(B\) have together constructed a double-blinded version \(T^*\) of the gate that satisfies the conditions listed before step 1. They will use \(T^*\) in performing the computation as follows:
						</p>
						<ol class="rp_original">
							<li value="6">Together they select the correct row of \(T^*\) by announcing their choice of input bits for \(T^*\). These input bits are the XOR sum of the "real" input bits, and the inversion bits for the corresponding columns.</li>
							<li>\(A\) and \(B\) both reveal the inversion bit for the output column, and the inversion bit for the entry in the output column which is in the selected row. By XORing this output column entry with the revealed inversion bits, they can both compute the bit that is the result of the computation.</li>
						</ol>
						<p class="rp_original">
							This basic protocol can be generalized in several ways:
						</p>
						<ul class="rp_original">
							<li>Instead of using an AND-gate, any type of gate can be used.</li>
							<li>Instead of two parties, any number of parties can participate in the protocol. Each new party just has to follow \(B\)'s part of the protocol, and will thus have to blind the commitments of each participant who went before.</li>
							<li>Instead of using only one gate, a computation involving arbitrarily many gates can be done with the protocol. The only condition is that when gate \(T_1\) is connected to \(T_2\), then their corresponding output column and input column were inverted using the <i>same</i> bits. When later a row is selected in the encrypted version of \(T_1\), the inversion bits that apply to the single output column entry will be revealed, while the column inversion bits will remain secret. The revealed inversion bits are now XORed with the output column entry selected, and the result can be used directly as an input bit to the encryption version of \(T_2\).</li>
						</ul>
					</section>
					<section id="sec3">
						<h2>3. Bit Commitment Schemes</h2>
						<p class="rp_original">
							A bit commitment scheme is a tool allowing protocol participant \(A\) to "commit" to a bit \(b\in\{0,1\}\) by releasing some information related to \(b\) such that:
						</p>
						<ul class="rp_original">
							<li>She cannot later convincingly claim that \(b\) had the opposite value.</li>
							<li>No other participant can find the value of \(b\) unless \(A\) allows this (opens the commitment)</li>
						</ul>
						<p class="rp_original">
							More formally, a bit commitment scheme is a family of finite sets $$\{I_m\}_{m=1}^\infty$$ such that a member of \(I_m\) is a pair of functions $$(f_m^{(0)},f_m^{(1)}),$$ where $$f_m^{(0)}:\;R_m^{(0)}\;\;\rightarrow\;\;S_m\quad and\quad f_m^{(0)}:\;R_m^{(1)}\;\;\rightarrow\;\;S_m$$ where \(R_m^{(i)}\) and \(S_m\) are finite sets, and the function are polynomial (in \(m\)) time computable.
						</p>
						<p class="rp_original">
							Further, there exists a probabilistic polynomial time algorithm \(\Omega\), which on input a value of the security parameter \(m\) outputs a member chosen randomly and uniformly from \(I_m\).
						</p>
						<p class="rp_original">
							To use the commitment scheme, \(A\) will choose an instance, i.e. she will choose a value of \(m\), run \(\Omega\) and make \(m,\,f_m^{(0)}\) and \(f_m^{(1)}\) public.
						</p>
						<p class="rp_original">
							To commit to a bit \(b,\,A\) chooses an element \(r\) uniformly in \(R_m^{(b)}\) and makes public $$BCS_{A,m}(b,r)=f_m^{(b)}(r).$$
						</p>
						<p class="rp_original">
							Below, we list the properties of bit commitment schemes that are of interest in our protocol:
						</p>
						<span class="rp_sub_header">Hiding the bit:</span>
						<p class="rp_original rp_sub">
							Let \(\Delta\) be any probabilistic polynomial time algorithm which takes as input a commitment \(BCS_{A,m}(b,r)\) and gives a one bit output \(\Delta(BCS_{A,m}(b,r))\). Then for all constants \(c\),$$|Prob(\Delta(BCS_{A,m}(b,r))=b-\frac 1 2|\lt m^{-c}$$ for all sufficiently large \(m\). This holds for all but a fraction \(\epsilon(m)\) of the instances in \(I_m\), and as a function of \(m,\,\epsilon(m)\) vanishes faster than any polynomial fraction.
						</p>
						<p class="rp_original rp_sub">
							Thus, guessing from a commitment which bit it contains is a hard problem. Note that \(b\) must be uniquely determined from \(BCS_{A,m}(b,r)\) and \(r\), but not necessarily from \(BCS_{A,m}(b,r)\) alone. This also means that \(b\) may be impossible to find from a commitment to \(b\), even wit infinite computing power.
						</p>
						<span class="rp_sub_header">Unforgeability:</span>
						<p class="rp_original rp_sub">
							Let \(\Delta\) be a probabilistic polynomial time algorithm which takes as input a commitment \(BCS_{A,m}(b,r),\,b\) and \(r\), and gives as output an element \(r_\Delta\) in \(R_m^{(b\oplus 1)}\). Then, for any constant \(c\), $$Prob(BCS_{A,m}(b,r)=BCS_{A,m}(b\oplus 1,r_\Delta))\lt m^{-c}$$ for all sufficiently large \(m\). Again this holds for all but a fraction \(\epsilon(m)\) of the instances in \(I_m\), and as a function of \(m,\,\epsilon(m)\) vanishes faster than any polynomial fraction.
						</p>
						<p class="rp_original rp_sub">
							Thus it is not possible for a polynomially bounded \(A\) to lie about the contents of her commitments. But note that an \(r_\Delta\) satisfying the condition above may not exist at all, in which case it is impossible to lie, even with infinite computing power.
						</p>
						<span class="rp_sub_header">Opening a commitment:</span>
						<p class="rp_original rp_sub">
							Given \(BCS_{A,m}(b,r),\,A\) can convince anyone that, for a given value of \(n\), she knows an \(r\) which will produce the given commitment. Typically, she will just reveal \(r\).
						</p>
						<span class="rp_sub_header">Comparability:</span>
						<p class="rp_original rp_sub">
							Given two commitments, \(BCS_{A,m}(b,r)\) and \(BCS_{A,m}(b',r')\), there exists a Minimum Knowledge Interactive Proof (MKIP) by which \(A\) can convince anyone about the value of \(b\oplus b'\).
						</p>
						<span class="rp_sub_header">Blinding:</span>
						<p class="rp_original rp_sub">
							Given a commitment \(BCS_{A,m}(b,r)\), <i>another</i> participant, \(B\), can choose \(b'\in\{0,1\}\) and compute from this a blinded commitment \(BCS_{A,m}(b\oplus b',r')\), where \(r'\) is uniformly distributed in \(R_m^{(b\oplus b')}\). There exists a MKIP such that, given these two commitments, \(B\) can convince anyone about the value of \(b'\).
						</p>
						<p class="rp_original rp_sub">
							Moreover, we require that given two commitments \(BCS_{A,m}(b\oplus b',r')\) and \(BCS_{A,m}(b\oplus b",r")\), which have been computed by \(B\) as above, there exists a MKIP by which B can convince anyone about the value of \((b\oplus b')\oplus(b\oplus b")=b'\oplus b"\).
						</p>
						<p class="rp_original rp_sub">
							Finally, it must be possible for \(A\) to open commitments which have been blinded as above, just as if she had computed them herself.
						</p>
						<p class="rp_original">
							From a theoretical point of view, the opening and comparability properties do not represent demanding assumptions, since the required proofs can always be produced by using standard reductions to 3COL or SAT<sup class="reference" data-citation="2"><a href="#citation2">[2]</a></sup><sup class="reference" data-citation="8"><a href="#citation8">[8]</a></sup><sup class="reference" data-citation="7"><a href="#citation7">[7]</a></sup>. We will only be concerned, however, with bit commitment schemes allowing the proofs to be produced directly and efficiently. As a consequence, the main protocol will be much more efficient. 
						</p>
						<section id="sec3.1">
							<h3>3.1. Examples</h3>
							<p class="rp_original">
								The protocol presented in this paper relies on the existence of bit commitment schemes satisfying the properties defined above. In this subsection, we give three examples of commitment schemes which could be used in the protocol, namely the <i>Quadratic Residuosity Scheme</i> (QRS), <i>the Jacobi Symbol Scheme</i> (JSS), and <i>the Discrete Log Scheme</i> (DLS), of which DLS has not been used in published protocols before.
							</p>
							<p class="rp_original">
								In QRS, \(A\) uses the algorithm \(\Omega\) to select at random two \(m\)-bit primes, \(p\) and \(q\) with \(p\equiv q\equiv -1\pmod 4\). She then puts \(N=pq,\,R_m^{(0)}=R_m^{(1)}=Z_N^*\) and \(S_m=\left\{x\in Z_N^*\,\middle|\,\left(\frac x N\right)=1\right\}\). She makes public \(N\) and uses for example the zero knowledge protocol from <span class="reference" data-citation="10"><a href="#citation10">[10]</a></span> to convince everyone that \(N\) is of the right form. In particular, this implies that -1 is a <span class="definable" data-define="quadratic residue">quadratic nonresidue</span> modulo \(N\) of <span class="definable">Jacobi symbol</span> 1. If we define $$f_m^{(b)}(r)=(-1)^br^2\bmod N$$ it is easy to see that a commitment will contain a 1 if and only if the commitment is a quadratic nonresidue modulo \(N\).
							</p>
							<p class="rp_original">
								The "hiding" condition above now translates into the well known <i>quadratic residuosity assumption</i>: it is hard, even probabilistically, to distinguish quadratic residues from quadratic nonresidues modulo \(N\) (a formal statement can be found in <span class="reference" data-citation="2"><a href="#citation2">[2]</a></span>). Moreover, even with infinite computing power, clearly \(A\) cannot lie about the contents of a commitment.
							</p>
							<p class="rp_original">
								The opening and comparability properties are easily verified for QRS: \(A\) simply makes public a square root modulo \(N\) of $$(-1)^bBCS_{A,m}(b,r)\quad resp.\quad(-1)^{b\oplus b'}BCS_{A,m}(b,r)BCS_{A,m}(b',r')^{-1}.$$ These proofs will be MKIPs because the commitments were chosen by \(A\) herself at random.
							</p>
							<p class="rp_original">
								Blinding is also a simple process: having chosen \(b',\,B\) computes the new commitment as $$(-1)^{b'}s^2BCS_{A,m}(b,r)=BCS_{A,m}(b\oplus b',rs),$$ where \(s\) is randomly chosen from \(Z_n^*.\,B\) can show the value of \(b'\) by showing a square root of $$(-1)^(b')BCS_{A,m}(b\oplus b',rs)(BCS_{A,m}(b,r))^{-1},$$ which equals \(s.\,s\) is called <i>the blinding factor</i>.
							</p>
							<p class="rp_original">
								Also, given two blinded commitments as above, \(B\) can show a square root of $$(-1)^{b'\oplus b"}BCS_{A,m}(b\oplus b',r')(BCS_{A,m}(b\oplus b",r"))^{-1}$$ to convince everyone about the value of \(b'\oplus b"\).
							</p>
							<p class="rp_original">
								Clearly, \(A\) can compute any commitment by using her knowledge of the factors of \(N\) to compute square roots. But it is important to note that it will only be safe for her to do so, if she is convinced that she will always be opening blinded forms of commitments chosen by <i>herself</i>. This will be ensured by the construction of our main protocol.
							</p>
							<p class="rp_original">
								In the JSS (first introduced by Blum<sup class="reference" data-citation="11"><a href="#citation11">[11]</a></sup>), some participant \(B\) chooses a modulus \(N\) of the same form as above, such that the factorization is unknown to \(A\), and convinces her as above that \(N\) was correctly chosen. We then put $$R_m^{(0)}\;=\;\left\{x\in Z_N^*\,\middle|\,\left(\frac x N\right)=1\right\},$$ $$R_m^{(1)}\;=\;\left\{x\in Z_N^*\,\middle|\,\left(\frac x N\right)=-1\right\},$$ $$and\quad S_m\;=\;QR(N),$$ where \(QR(N)\) denotes the set of wuadratic residues modulo \(N\). Finally, we set $$f_m^{(b)}(r)\;=\;r^2\bmod N,$$ where \(r\in R_m^{(b)}\).
							</p>
							<p class="rp_original">
								This scheme hides the bits unconditionally: since each square modulo \(N\) has two square roots of Jacobi symbol +1 and two of Jacobi symbol -1, release by \(A\) of \(BCS_{A,m}(b,r)\) gives away no Shannon information about \(b\). On the other hand, the unforgeability property only holds conditionally here: if \(A\) could factor \(N\), she could lie about the value of \(b\).
							</p>
							<p class="rp_original">
								JSS also satisfies the comparability property: Given two commitments \(s_1\,=\,BCS_{A,m}(b,r)\) and \(s_2\,=\,BCS_{A,m}(b',r'),\,A\) can make public a square root of \(s_1(s_2)^{-1}\) of Jacobi symbol \((-1)^{b\oplus b'}\) to convince everybody about the value of \(b\oplus b'\). Note that this is still information theoretically secure: after having seen a proof that \(b\oplus b'\,=\,1\), say, the two possibilities \((b,b')\,=\,(1,0)\) and \((b,b')\,=\,(0,1)\) remain equally likely, even to someone who knows the factorization of \(N\).
							</p>
							<p class="rp_original">
								Note that if \(A\) is going to commit to bits using JSS in a multiparty protocol, every participant except \(A\) must supply a different modulus, and when committing to a bit, \(A\) must make public a set of commitments to this bit, one for each modulus supplied. This is to prevent the possibility that \(A\) breaks the unforgeability property by conspiring with somebody who knows the factorizations. This of course means that the other participants must be convinced that the same bit is contained in all commitments in a given set. Fortunately, the construction of our main protocol is such that this automatically ensured whenever JSS is used.
							</p>
							<p class="rp_original">
								Note also that if absolute certainty is needed about the correctness of the choice of \(N,\,B\) could be required to simply reveal the factorization of \(N\) after the protocol has been executed. IT would be too late for \(A\) by them to use this knowledge in the protocol. Another possibility is for \(B\) to prove to \(A\) in zero knowledge that the modulus has the right form. However, all the known proofs of this leave an exponentially small probability that \(B\)'s claim is false, in which case \(A\) <i>would</i> be giving away information about her secrets. Thus it seems that with this scheme, \(A\) will never be quite sure that her secrets have not been betrayed until after it happened!
							</p>
							<p class="rp_original">
								The next example, the <span class="definable" data-define="Discrete Log Problem">Discrete Log Scheme</span>, solves this problem. Here, \(B\) chooses an \(m\)-bit prime \(p\), a generator \(g\) of \(Z_p^*\), and an element \(a\in Z_p^*\) at random and reveals them to \(A\). We now put \(R_m^{(1)}\,=\,R_m^{(0)}\,=\,S_m\,=\,Z_p^*\), and $$f_m^{(b)}(r)\,=\,a^bg^r.$$
							</p>
							<p class="rp_original">
								This scheme also hides the bits unconditionally, since the bit contained in a commitment is not uniquely determined, if the random choice made by \(A\) is unknown. Note that if \(p\) is determined such that the factorization of \(p-1\) is known, \(A\) can easily check for herself that \(p\) is a prime and that \(g\) is a generator.
							</p>
							<p class="rp_original">
								To open a commitment, \(A\) must show the discrete log base \(g\) of $$a^{-b}BCS_{A,m}(b,r),$$ namely \(r\). IT is also easy to see that the unforgeability property holds, assuming that \(A\) cannot find the discrete log of \(a\).
							</p>
							<p class="rp_original">
								Given two commitments \(BCS_{A,m}(b,r)\) and \(BCS_{A,m}(b',r'),\,A\) can prove that \(b\oplus b'=0\) by showing the discrete log of $$BCS_{A,m}(b,r)(BCS_{A,m}(b',r'))^{-1}$$ and to show that \(b\oplus b'=1\), she shows the discrete log of $$a^{-1}BCS_{A,m}(b,r)BCS_{A,m}(b',r').$$ Once again, it is easy to see that \(A\) cannot make a false claim about \(b\oplus b'\) unless she can find the discrete log of \(a\).
							</p>
							<p class="rp_original">
								An additional advantage of DLS compared to JSS is that it is not necessary in a multiparty application that all participants different from \(A\) choose their own instances, and that \(A\) then must commit to a bit "in parallel" using all the published instances. Since there is no trapdoor present in DLS, all participants can collaborate in choosing \(p,\,g\) and \(a\) using some multiparty coinflipping protocol.
							</p>
						</section>
					</section>
					<section id="sec4">
						<h2>4. Protocols: notation and definitions</h2>
						<p class="rp_original">
							We think of a protocol as occurring among a set of communicating probabilistic <span class="definable" data-define="Turing machine">Turing machines</span> \(\{P_1,\dots,P_n\}\) called the participants. The protocol is described as a specification of the program each participant should follow.
						</p>
						<p class="rp_original">
							Each machine has private input, output, and random tapes, and one communication tape. The contents of the input tape of \(P_i\) is called \(ip_i\), the contents of the output tape after execution of the protocol is called \(op_i\). All machines are clocked by a common clock, and the protocol proceeds in rounds. In each round, exactly one machine can do some computation and perhaps write a message on the other machines' communication tapes. By definition, all messages sent in the protocol are written simultaneously on all communication tapes. IF a machine receives a message which does not obey the constraints specified in the protocol, it stops immediately, and we say that <i>cheating has been detected</i>.
						</p>
						<p class="rp_original">
							We assume the existence of a mutually trusted source of random bits. Such a source could easily be implemented using e.g. Blum's coin flipping problem<sup class="reference" data-citation="11"><a href="#citation11">[11]</a></sup>. But since the construction of such a subprotocol is independent of our main protocol, we have chosen to abstract away the fact that a subprotocol is used.
						</p>
						<p class="rp_original">
							The protocol takes some global input, known to all machines:
						</p>
						<ul class="rp_original">
							<li>A specification of the computation to be performed, in the form of a boolean circuit \(C\).</li>
							<li>The cryptographic security parameter \(m\).</li>
						</ul>
						<p class="rp_original">
							Note that the security and the certainty of correctness may be varies <i>independently</i> of the complexity of the computation modelled by \(C\). Moreover, the protocol never uses any special properties of \(C\), such as membership of a polynomial size family. For these reasons, we look at \(C\) just as a single fixed circuit.
						</p>
						<p class="rp_original">
							Of course, this does not mean that the behavior of e.g. the running time of the protocol as a function of \(C\) is not interesting, only that such dependencies should be considered independently of the security level.
						</p>
						<section id="sec4.1">
							<h3>4.1. Correctness and Security</h3>
							<p class="rp_original">
								The definitions in this section are straightforward generalizations of the definition of "zero knowledge proof systems" found in <span class="reference" data-citation="12"><a href="#citation12">[12]</a></span>. This becomes clear if one takes a slightly different point of view of the situation where a prover convinces a verifier about the membership of a string \(x\) in an <span class="definable">NP</span>-language \(L\).
							</p>
							<p class="rp_original">
								In fact the prover and the verifier are doing an interactive computation, where only the prover supplies input, namely a certificate of membership for \(x\). The notion of correctness of the protocol they execute corresponds to the fact that we have a proof system: we want the protocol to produce the correct output of the computation, namely "accept" if indeed the prover put in a valid certificate of membership for \(x\). The notion of security corresponds to the fact that the proof system is zero knowledge: we want the verifier to gain nothing useful about the secrets of the prover, other than the fact that \(x\) is in \(L\).
							</p>
							<p class="rp_original">
								If we model the computation needed to verify membership for \(x\) by a boolean circuit \(C\), it is clear that this is just a special case of the general problem addressed in this paper.
							</p>
							<p class="rp_original">
								We allow \(C\) to be a probabilistic circuit, i.e. take as input a number of bits chosen uniformly from \(\{0,1\}\). Thus, given as inputs \(I=(ip_1,\dots,ip_n),\,C\) determines a probability distribution \(OP_I^C\) on the output. We assume for simplicity that the output is public, i.e. the same output string will appear on the output tape of any participant following the protocol (the generalization to different (private) outputs is easy and will be discussed later). Given a choice of inputs as above, we let \(OP_{I,m}^{prot}\) denote the probability distribution according to which the output string of a participant following the protocol is distributed, when the protocol is executed with security parameter value \(m\) and no cheating is detected. We would like this distribution to be essentially equal to \(OP_I^C\). In other words, the only way for (a set of) dishonest participant(s) to prevent the correct result from being computed is to stop the protocol, e.g. by deliberately sending an incorrect message.
							</p>
							<p class="rp_original">
								We let \(OP_I^C(op)\) (resp. \(OP_{I,m}^{prot}(op)\)) denote the probability that the binary string \(op\) is produced as output.
							</p>
							<span class="rp_definition_header">Definition 4.1</span>
							<p class="rp_original rp_definition">
								A protocol is said to be <i>correct</i> if for any choice of inputs \(I=(ip_1,\dots,ip_n)\), and any binary string \(op\) and constant \(c,\) $$|OP_I^C(op)-OP_{I,m}^{prot}(op)|\lt m^{-c}$$ for all sufficiently large \(m\).
							</p>
							<p class="rp_original">
								A <i> conspiracy</i> is a subset \(X\) of \(\{P_1,\dots,P_n\}\) with \(|X|\lt n\). The machines in a conspiracy may follow any (polynomial time) program, and they may establish private communication channels to share all the information available to them.
							</p>
							<p class="rp_original">
								Intuitively, we will consider the protocol secure if no conspiracy will learn more from the protocol than what could already have been inferred from the output of the computation and the part of the input known to the conspiracy.
							</p>
							<p class="rp_original">
								To state this more formally, we need some definitions:
							</p>
							<p class="rp_original">
								The binary string which is that concatenation of all messages sent during an execution of the protocol is called a <i>protocol conversation</i>.
							</p>
							<p class="rp_original">
								Let \(ra\) be a binary string containing as many bits as there are random input bits to \(C\). Then by \(f_C(ip_1,\dots,ip_n,ra)\) we denote the output of \(C\) resulting from inputs \((ip_1,\dots,ip_n)\) and random choice \(ra\).
							</p>
							<p class="rp_original">
								We let \(P_{prot}^{(m)}(ip_1,\dots,ip_n,ra)\) denote the probability distribution according to which a protocol conversation with security parameter \(m\) and inputs \((ip_1,\dots,ip_n,ra)\) is distributed.
							</p>
							<p class="rp_original">
								Note that this distribution is conditional on the program followed by the machines in \(X\), i.e. the conspiracy's strategy. Note also that the definition talks about the inputs of machines in \(X\). This is not necessarily a meaningful concept: nothing prevents a dishonest participant from pretending that the contents of its input tape are different from what they are in fact. This "problem" is easily solved, however, if we jump ahead in the protocol description a little: each participant must publish bit commitments which determine a particular choice of input. We therefore <i>define</i> the input of a participant to be the bit string committed to during the execution of the protocol.
							</p>
							<p class="rp_original">
								A <i>simulator for \(X\)</i> is a polynomial time Turing machine \(M_X\) which, on input \(\left(m, f_C(ip_1,\dots,ip_n,ra), \left\{ip_i,\,\middle|\,P_i\in X\right\}\right)\) will generate a protocol conversation distributed according to the distribution \(P_{M_X}^{(m)}\left(f_C(ip_1,\dots,ip_n,ra), \left\{ip_i,\,\middle|\,P_i\in X\right\}\right)\).
							</p>
							<span class="rp_definition_header" id="#def4.2">Definition 4.2</span>
							<p class="rp_original rp_definition">
								The protocol is said to be <i>secure against the conspiracy \(X\)</i> if there exists a simulator for \(X,\,M_X\), such that for any \((ip_1,\dots,ip_n)\) and \(ra\), the two ensembles of probability distributions $$\left\{P_{M_X}^{(m)}\left(f_C(ip_1,\dots,ip_n,ra), \left\{ip_i,\,\middle|\,P_i\in X\right\}\right)\right\}_{m=1}^\infty$$ and $$\left\{P_{prot}^{(m)}(ip_1,\dots,ip_n,ra)\right\}_{m=1}^\infty $$ are polynomially (in \(m\)) indistinguishable.
							</p>
							<p class="rp_original">
								We assume that the reader is familiar with this notion. For details, refer to <span class="reference" data-citation="12"><a href="#citation12">[12]</a></span>.
							</p>
							<p class="rp_original">
								The protocol is said to be <i>secure</i> if it is secure against any conspiracy.
							</p>
							<p class="rp_original">
								This definition means that no matter which type of hostile behavior is exhibited by \(X\), the private inputs of all honest participants <i>and</i> the random inputs are optimally protected. But note that providing the protocol secure under this definition does not exclude the possibility that a conspiracy, by stopping the protocol in some clever way, could find out about the output, while preventing honest participants from getting at it. The basic protocol as described in <a href="#sec5">Section 5</a> already offers protection against this, but a lot of variations on the theme are possible. More details will be given in <a href="#sec6">Section 6</a>.
							</p>
						</section>
					</section>
					<section id="sec5">
						<h2>5. Circuits, terminology, and notation</h2>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color8">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="citation1">Y1</li>
					<li id="citation2">GoMiWi</li>
					<li id="citation3">GaHaYu</li>
					<li id="citation4">Y2</li>
					<li id="citation5">GoVa</li>
					<li id="citation6">GoMiWi2</li>
					<li id="citation7">BrCr</li>
					<li id="citation8">Ch</li>
					<li id="citation9">GoMi</li>
					<li id="citation10">PeGr</li>
					<li id="citation11">Bl</li>
					<li id="citation12">GoMiRa</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+82@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Created by Nicolas Schank 2014, Brown University</p>
				<p>All original work is free for any use by anyone whatsoever.</p>
				<p>For more information about liability and licensing Yao's original paper, see <a href="../liability.html">Liability</a>.</p>
            </div>
        </div>
    </body>
</html>