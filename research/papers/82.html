<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result - David Chaum, Ivan B. Damg&aring;rd, Jeroen van de Graaf, 1988</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
		<script type="text/javascript" src="../../script/toc.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					case "fC":
						return "<p>\\(f_{C}\\) represents the output of \\(C\\), taking as input the inputs and the randomness supplied to the circuit.</p>";
					case "ip":
						return "<p>\\(ip_i\\) represents the contents of the input tape of participant \\(P_i\\). \\(I_i\\) is a partition of the input wires into the gate such that there is exactly one input wire per bit of \\(ip_i\\).</p>";
					case "JacobiSymbol":
						return "<p>\\(\\left(\\frac m n\\right)\\) represents the <span class=\"definable\">Jacobi symbol</span> of \\(m\\bmod n\\).</p>";
					case "op":
						return "<p>\\(op_i\\) represents the contents of the output tape of participant \\(P_i\\).</p>";
					case "Pprot":
						return "<p>\\(P_{prot}^{(m)}\\) represents the probability distribution of a protocol conversation of \\(prot\\) with security parameter \\(m\\), taking as input the inputs to the protocol and the randomness used by all parties.</p>";
					case "R_m^b":
						return "<p>\\(R_m^b\\) is a finite set containing all elements \\(r\\) such that \\(\\operatorname{BCS}_(b,r)\\) will be a valid commitment for \\(b\\).</p>";
					case "ra":
						return "<p>\\(ra\\) represents a (fixed) string of random bits used by a protocol or circuit. The set of input wires in the circuit which correspond to these random bits is \\(R\\).</p>";
					case "Sm":
						return "<p>\\(S_m\\) is a finite set containing all valid commitments for both 0 and 1 within a particular signature scheme.</p>";
					case "X":
						return "<p>The set of all conspirators.</p>";
					default:
						return "No info on this equation yet.";
				}
			}

			self_def["conspiracy"] = "Any subset of the participants that does not include every participant (or no participants).  We denote this subset by \\(X\\). Machines in a conspiracy may follow any PPT program or establish private communication channels amongst themselves in order to share information.";
			self_def["openly verifiable"] = "A protocol is openly verifiable if participants can be challenged after the termination of the protocol in order to determine no cheating has occurred.";
			self_def["protocol conversation"] = "The binary string which is the concatenation of all messages sent during an execution of a protocol.";
			self_def["simulator for X"] = "A polynomial time Turing machine which, when given the security parameter, the inputs of all the conspirators, and the output of the circuit, generates a protocol conversation.";
			//-->
        </script>
    </head>
    <body>
		<div class="main_hidden">
			$$\require{cancel}$$
		</div>
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1" id="overview">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth">
                    <div class="rp_linkbox"><a href="pdf/82.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result</span>
                    <span class="rp_info">1988
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/David Chaum.html">David Chaum</a>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/Ivan Damg&aring;rd.html">Ivan Damg&aring;rd</a>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<a class="rp_author" href="../authors/Jeroen van de Graaf.html">Jeroen van de Graaf</a>
					</span>
					
					<div class="rp_snippet">
						&ldquo;[A] participant with bounded resources can perform computations securely with a participant who may have unlimited computing power.&rdquo;
					</div>
					
					<h1>Overview</h1>						
                    <div class="main_toc"></div>
					
                    <section id="intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result</b> is a 1988 paper by Chaum, Damg&aring;rd, and van de Graaf which presented the first example of a protocol offering <span class="definable">information theoretic security</span>, even if only to a single participant. Later that same year, Chaum and Damg&aring;ard (along with Claude Cr&eacute;peau) would follow up this work with a <a href="34.html">feasibility result</a> demonstrating that it was possible to offer information theoretic security to <i>all participants</i> (under certain assumptions). While this paper is important in its own right, the results of that following paper had a much larger effect on multiparty computation research as a whole.
						</p>
						<p class="rp_analysis">
							The protocol presented offers a different perspective to computation than the papers before it. It is in some ways similar to Yao's garbled circuit construction, but offers very different characteristics (e.g. the information theoretic security of one party) and operates in an \(n\) party case as opposed to the 2 party case.
						</p>
					</section>
					<section id="goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							The authors were largely attempting to offer a more efficient and usable construction for multiparty computation. In this, historically, they failed; this protocol is of comparable efficiency to most other constructions already known at the time, except perhaps for very small circuits. They <i>did</i> succeed in making a protocol that was immensely extensible and private, much more so than a garbled circuit or the <a href="81.html">GMW construction</a>. This protocol easily tolerates multiple outputs, allows for optimal fairness, and can be composed with other runs of the protocol. Its main drawback is that it requires significant (and <a href="34.html">inherently  obsolescent</a>) alterations in order to become fault tolerant to any degree.
						</p>
						<p class="rp_analysis">
							As a mostly unrelated aside, this paper interestingly shows that any language for which membership can be proven interactively can also be proven in zero knowledge (under the assumption that <span class="definable">clawfree</span> <span class="definable" data-define="trapdoor permutation">trapdoor permutations</span> exist).
						</p>
					</section>
					<section id="assumptions">
						<h2>Assumptions</h2>
						<p class="rp_analysis">
							Minimally, this paper operates under the assumption that <span class="definable">clawfree</span> <span class="definable" data-define="trapdoor permutation">trapdoor permutations</span> exist, as this assumption implies the existence of bit <span class="definable">commitment</span> schemes. (Note that this is not necessarily the minimal assumption implying the existence of bit commitment schemes, but it <i>is</i> the minimal assumption proving the existence of bit commitment schemes with the properties used in this paper.)
						</p>
						<p class="rp_analysis">
							For one of the bit commitment schemes mentioned as an example, the following assumption must be held additionally: 
						</p>
						<span class="rp_sub_header"><a href="#sec3.1">Quadratic Residuosity Assumption</a></span>
						<p class="rp_analysis rp_sub">
							Given any element \(y\in\mathbb Z_N\), where \(N=p\cdot q\) for primes \(p\equiv q\equiv 3\bmod4\), there does not exist a probabilistic polynomial-time method of determining whether \(\exists\,x\in\mathbb Z_N\) such that \(x^2\equiv y\pmod N\). 
						</p>
						<p class="rp_analysis">
							The quadratic residuosity assumption is known to imply that factoring is hard<sup class="reference" data-citation="QRtoF">[?]</sup>; in turn, the hardness of factoring is known to imply that clawfree permutations exist<sup class="reference" data-citation="GB">[?]</sup>. As such, we can make <i>either</i> assumption, as opposed to needing both in the case that we want to use the QRS commitment scheme.
						</p>
						<p class="rp_analysis">
							In terms of what network this protocol requires, <span class="definable" data-define="synchronous network">synchrony</span> is assumed. While not declared outright, a <span class="definable">broadcast channel</span> is implicitly assumed based on the definition of rounds and messages presented in <a href="#sec4">Section 4</a>.
						</p>
					</section>
					<section id="defs">
						<h2>Definitions</h2>
						<a href="#def4.1"><span class="rp_definition_header">Definition 4.1</span></a>
						<p class="rp_annotation rp_definition">
							We define \(OP^{X}\) to be a probability distribution on outputs when running \(X\), where \(X\) could be \(C\) (a particular circuit definition) or \(prot\) (a multiparty protocol meant to emulate \(C\)).
						</p>
						<p class="rp_original rp_definition">
							A protocol is said to be <i>correct</i> if for any choice of inputs \(I=\)<span class="equation" data-equation="ip">\((ip_1,\dots,ip_n)\)</span>, and any binary string \(op\) and constant \(c,\) $$\left|OP_I^C(op)-OP_{I,m}^{prot}(op)\right|\lt m^{-c}$$ for all sufficiently large \(m\).
						</p>
						<a href="#def4.2"><span class="rp_definition_header">Definition 4.2</span></a>
						<p class="rp_original rp_definition">
							The protocol is said to be <i>secure against the conspiracy <span class="equation" data-equation="X">\(X\)</span></i> if there exists a <span class="definable" data-define="simulator for X">simulator for \(X\)</span>, \(M_X\), such that for any <span class="equation" data-equation="ip">\((ip_1,\dots,ip_n)\)</span> and <span class="equation" data-equation="ra">\(ra\)</span>, the two ensembles of probability distributions $$\left\{P_{M_X}^{(m)}\left(f_C(ip_1,\dots,ip_n,ra), \left\{ip_i,\,\middle|\,P_i\in X\right\}\right)\right\}_{m=1}^\infty$$ and $$\left\{P_{prot}^{(m)}(ip_1,\dots,ip_n,ra)\right\}_{m=1}^\infty $$ are polynomially (in \(m\)) <span class="definable">indistinguishable</span>.
						</p>
						<a href="#def5.1"><span class="rp_definition_header">Definition 5.1</span></a>
						<p class="rp_original rp_definition">
							A <i>computation</i> \(\Gamma\) in \(C\) consists of a <i>selection</i> of exactly one row in each truth table. The <i>input</i> of \(\Gamma\) is the corresponding assignment of bits to the input wires of \(C\), the <i>output</i> of \(\Gamma\) is the corresponding assignment of bits to the output wires.
						</p>
						<a href="#def5.2"><span class="rp_definition_header">Definition 5.2</span></a>
						<p class="rp_original rp_definition">
							Let \(g\) be a gate in \(C\) with \(t\) input wires. For \(i=1\cdots n\), we define an <i>\(i\)-transform \(T\) of \(T(G)\)</i> to be a \((t+1)\) by \(2^t\), 0-1 matrix with a list of bit commitments attached to each row and each column. The list attached to row \(l\) is called \(rlist(l,T)\). The list attached to column \(k\) is called \(clist(k,T)\).
						</p>
						<p class="rp_original rp_definition">
							Each list contains one commitment from each participant \(P_j\), for which \(j\leq i\), except \(clist(k,T)\), when the \(k\)-th column corresponds to an input wire in some \(I_j\). These lists are empty if \(j\gt i\), and contain one bit commitment from \(P_j\) if \(j\leq i\).
						</p>
						<p class="rp_original rp_definition">
							By \(rsum(l,T)\) (resp. \(csum(k,T)\)), we denote the XOR sum of all bits commited to in \(rlist(l,T)\) (resp. \(clist(k,T)\)). The sum of an empty list is defined to be 0.
						</p>
						<p class="rp_original rp_definition">
							A 0-transform of \(T(G)\) is defined to be simply \(T(G)\) itself.
						</p>
						<a href="#def5.3"><span class="rp_definition_header">Definition 5.3</span></a>
						<p class="rp_annotation rp_definition">
							Where \(1\leq l\leq2^t,\,1\leq k\leq t+1\).
						</p>
						<p class="rp_original rp_definition">
							A <i>valid \(i\)-transform \(T\) of \(T(G)\)</i> is an \(i\)-transform of \(T(G)\) which satisfies that:
						</p>
						<p class="rp_original rp_definition">
							There exists a permutation \(\sigma\) of \((1,\dots,2^t)\) such that: $$\begin{split}
							T_{lk}&=T(G)_{\sigma(l)k}\oplus csum(k,T),\quad\,&\mbox{if}\;k\lt t+1,\\
							T_{lk}&=T(G)_{\sigma(l)k}\oplus csum(k,T)\oplus rsum(l,T),\quad &\mbox{if}\;k= t+1,
							\end{split} $$ where \(T_{lk}\) (resp. \(T(G)_{lk}\)) is the entry in the \(l\)-th row and \(k\)-th column of \(T\) (resp. \(T(G)\)).
						</p>
						<a href="#def6.1"><span class="rp_definition_header">Definition 6.1</span></a>
						<p class="rp_original rp_definition">
							By a <i>computation \(\Gamma^*\) in \(C^*\)</i>, we mean a selection of exactly one row in each \(n\)-transform in \(C^*\).
						</p>
						<p class="rp_original rp_definition">
							A computation \(\Gamma^*\) is said to be <i>consistent</i>, if the following is satisfied: Suppose output column \(k_1\) in the transform \(T^*_1\) is connected with column \(k_2\) in the transform \(T_2^*\), and let \(\Gamma^*(k_1)\) and \(\Gamma^*(k_2)\) be the entries selected by \(\Gamma^*\) in the two columns then $$\Gamma^*(k_1)\oplus rsum(l_1,T_1)\;=\;\Gamma^*(k_2),$$ where \(l_1\) is the index of the row selected by \(\Gamma^*\) in \(T_1^*\).
						</p>
					</section>
					<section id="theorems">
						<h2>Theorems</h2>
						<p class="rp_annotation rp_theorem">
							We define 'the protocol' to be the multiparty computation protocol consisting of procedures <a href="#protocol1"><span class="main_language">Transform Circuit</span></a>, <a href="#protocol2"><span class="main_language">Check Transformation</span></a>, and <a href="#protocol3"><span class="main_language">Construct Computation</span></a>.
						</p>
						<a href="#theorem6.1"><span class="rp_theorem_header">Theorem 6.1</span></a>
						<p class="rp_original rp_theorem">
							For every \(i=1\cdots n\), the probability that \(P_i\) has cheated (i.e. sent incorrect messages) anywhere in the protocol is smaller than \(m^{-c}\) for any constant \(c\) and all sufficiently large \(m\). If no cheating occurs, then the encryption phase ends with \(P_n\) outputting a valid \(n\)-transform of every truth table in \(C\).
						</p>
						<a href="#lemma6.2"><span class="rp_theorem_header">Lemma 6.2</span></a>
						<p class="rp_original rp_theorem">
							Let \(\Gamma^*\) be a computation in \(C^*\) and suppose all transforms in \(C^*\) are valid. Then the corresponding computation \(\Gamma\) in \(C\) is consistent if and only if \(\Gamma^*\) is consistent.
						</p>
						<a href="#theorem6.3"><span class="rp_theorem_header">Theorem 6.3</span></a>
						<p class="rp_original rp_theorem">
							The protocol is correct, as defined in <a href="#def4.1">definition 4.1</a>.
						</p>
						<a href="#theorem6.4"><span class="rp_theorem_header">Theorem 6.4</span></a>
						<p class="rp_original rp_theorem">
							The protocol is secure.
						</p>
						<a href="#theorem6.5"><span class="rp_theorem_header">Theorem 6.5.</span></a>
						<p class="rp_original rp_theorem">
							If \(P_n\) is honest and uses DLS for bit <span class="definable" data-define="commitment">commitments</span>, then the protocol releases no information in the Shannon sense about the private input of \(P_n\) and all intermediate results in the computation.
						</p>
						<a href="#theorem8.1"><span class="rp_theorem_header">Theorem 8.1</span></a>
						<p class="rp_original rp_theorem">
							Assume that pairs of <span class="definable">clawfree</span> trapdoor functions exist. Then any language in IP has a zero knowledge proof system.
						</p>
					</section>
					<section id="protocol">
						<h2>Protocols</h2>
						<h3><a href="#sec6.1">The Encryption Phase</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b> Any \(n\) parties</li>
							<li><b>Function(s): </b> Takes in the description of a circuit \(C\) that the \(n\) parties wish to collectively determine. We define the circuit to have \(c\) gates with maximum \(t\) fan-in, and each party has an equal number of input bits (plus an also-equal set of random input bits). The parties collectively create a new, encrypted version of the circuit.</li>
							<li><b>Privacy constraints: </b>No party learns the input bits of any other party.</li>
							<li><b>Cheating: </b>No party can incorrectly create the circuit without being caught, except negligibly often.</li>
							<li><b>Subprotocols: </b> Procedure <span class="main_language">Transform Circuit</span> is done once per party. Procedure <span class="main_language">Check Transform</span> is done \(m\) times per party, where \(m\) is the security parameter.</li>
							<li><b>Bits exchanged: </b>\(\operatorname{O}(cmn2^t(t+m+n))\), where \(m\) is the security parameter, \(n\) is the number of parties, \(c\) is the number of gates in the circuit, and \(t\) is the maximum fan-in of those gates.</li>
							<li><b>Runtime: </b>\(\operatorname{O}(cm2^t(t+n^2))\), where \(m\) is the security parameter, \(n\) is the number of parties, \(c\) is the number of gates in the circuit, and \(t\) is the maximum fan-in of those gates.</li>
							<li><b>Assumptions: </b>A broadcast channel was implicitly defined in <a href="#sec4">Section 4</a>. Due to this, both bits exchanged and runtime are slightly simplified (in particular by not using Byzantine agreement, and by dividing bits exchanged by \(n\)).</li>
						</ul>
						
						<h4><a href="#protocol1">Procedure <span class="main_language">Transform Circuit</span></a></h4>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b> Performed by 1 party at a time, with the result being sent to all \(n\) parties after completion.</li>
							<li><b>Function(s): </b> Takes in the description of a circuit \(C\) that the \(n\) parties wish to collectively determine. We define the circuit to have \(c\) gates with maximum \(t\) fan-in, and each party has an equal number of input bits (plus an also-equal set of random input bits). The party performing the procedure encrypts the circuit in a special, composable way.</li>
							<li><b>Privacy constraints: </b>No party learns the performing party's input bits or in what way the performing party changed the circuit.</li>
							<li><b>Cheating: </b>Cheating is dealt with by procedure <span class="main_language">Check Transform</span>, which is done as part of the overall Encryption Phase (above).</li>
							<li><b>Bits exchanged: </b>\(\operatorname{O}(c2^t(t+m))\), where \(m\) is the security parameter, \(c\) is the number of gates in the circuit, and \(t\) is the maximum fan-in of those gates.</li>
							<li><b>Runtime: </b>\(\operatorname{O}(c2^t(\frac t n + i))\), where \(n\) is the number of parties, \(c\) is the number of gates in the circuit, \(t\) is the maximum fan-in of those gates, and \(i\) is which iteration of this protocol is being run (e.g. the first participant has \(i=1\), the final one has \(i=n\)).</li>
							<li><b>Assumptions: </b>A broadcast channel was implicitly defined in <a href="#sec4">Section 4</a>. Due to this, both bits exchanged and runtime are slightly simplified (in particular by not needing Byzantine agreement, and by dividing bits exchanged by \(n\)).</li>
							<li><b>Notes: </b>We are operating under the simplifying assumption that each party has a \(\frac 1 n\) probability of using one of their input bits as any given input bit to a gate. We additionally assume that the bit commitments (and their openings) are each \(m\) bits.</li>
						</ul>
						
						<h4><a href="#protocol1">Procedure <span class="main_language">Check Transform</span></a></h4>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b> Performed by 1 prover and \(n-1\) verifiers.</li>
							<li><b>Function(s): </b> The prover proves to all the verifiers (in zero knowledge) that the prover performed the above <span class="main_language">Transform Circuit</span> protocol correctly.</li>
							<li><b>Privacy constraints: </b>No party learns how the prover transformed the circuit originally.</li>
							<li><b>Cheating: </b>After one run of this procedure, the verifiers know with probability &frac12; that the prover performed the above protocol correctly. After \(m\) runs, this probability is \(1-2^{-m}\).</li>
							<li><b>Subprotocols: </b>A single (additional) run of the <span class="main_language">Transform Circuit</span> protocol is performed for each run of this proof.</li>
							<li><b>Bits exchanged: </b>\(\operatorname{O}(c2^t(t+m+i))\), where \(m\) is the security parameter, \(c\) is the number of gates in the circuit, \(t\) is the maximum fan-in of those gates, and \(i\) is which iteration of the <span class="main_language">Transform Circuit</span> protocol is being checked (e.g. the first participant has \(i=1\), the final one has \(i=n\)).</li>
							<li><b>Runtime: </b>\(\operatorname{O}(c2^t(\frac t n + i))\), where \(n\) is the number of parties, \(c\) is the number of gates in the circuit, \(t\) is the maximum fan-in of those gates, and \(i\) is which iteration of the <span class="main_language">Transform Circuit</span> protocol is being checked (e.g. the first participant has \(i=1\), the final one has \(i=n\)).</li>
							<li><b>Assumptions: </b>A broadcast channel was implicitly defined in <a href="#sec4">Section 4</a>. Due to this, both bits exchanged and runtime are slightly simplified (in particular by not needing Byzantine agreement, and by dividing bits exchanged by \(n\)).</li>
						</ul>
						
						<h3><a href="#protocol3">The Computation Phase (i.e. Procedure <span class="main_language">Construct Computation</span>)</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b> Any \(n\) parties</li>
							<li><b>Function(s): </b> Takes in the encrypted version of a circuit created by the Encryption Phase above. Output is identical to the output of the circuit input to the Encryption Phase.</li>
							<li><b>Privacy constraints: </b>No party learns the input bits of any other party.</li>
							<li><b>Cheating: </b>No party can alter the output of the circuit without claiming a commitment has a different value than intended.</li>
							<li><b>Bits exchanged: </b>\(\operatorname{O}(cmn)\), where \(m\) is the security parameter, \(n\) is the number of parties, and \(c\) is the number of gates in the circuit.</li>
							<li><b>Runtime: </b>\(\operatorname{O}(cmn)\), where \(m\) is the security parameter, \(n\) is the number of parties, and \(c\) is the number of gates in the circuit.</li>
							<li><b>Assumptions: </b>A broadcast channel was implicitly defined in <a href="#sec4">Section 4</a>. Due to this, both bits exchanged and runtime are slightly simplified (in particular by not using Byzantine agreement, and by dividing bits exchanged by \(n\)).</li>
						</ul>
					</section>
					<section id="further">
						<h2>Further Reading</h2>
						<p class="rp_analysis">
							 This paper had a sequel later the same year which is essentially required reading in order to see how the ideas presented here developed: it can be found <a href="34.html">here</a>.
						</p>
						<p class="rp_analysis">
							For the foundations of the circuit building construction presented here, see Yao's <a href="24.html">1986 paper</a> that analyzed the two party case.
						</p>
					</section>
					<section id="ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							D. Chaum, I. Damg&aring;rd, and J. van de Graaf. Multiparty Computation Ensuring Privacy of Each Party's Input and Correctness of the Result. <i>Advances in Cryptology&mdash;CRYPTO '87 Proceedings</i>, pp. 87-119. Springer. 1987.
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5" id="annotated_paper">
                <div class="main_window main_fullwidth">
					<h1>Annotated Paper</h2>
                    <div class="main_toc"></div>
					<section id="summary" data-section-number="0">
						<h2>Summary</h2>
						<p class="rp_original">
							A protocol is presented that allows a set of parties to collectively perform any agreed computation, where every party is able to choose secret inputs and verify that the resulting output is correct, and where all secret inputs are optimally protected.
						</p>
						<p class="rp_original">
							The protocol has the following properties:
						</p>
						<ul class="rp_original">
							<li>One participant is allowed to hide his or her secrets <i>unconditionally</i>, i.e. the protocol releases no Shannon information about these secrets. This means that a participant with bounded resources can perform computations securely with a participant who may have unlimited computing power. To the best of our knowledge, our protocol is the first of its kind to provide this possibility.</li>
							<li>The cost of our protocol is linear in the number of gates in a circuit performing the computation, and in the number of participants. We believe it is conceptually simpler and more efficient than other protocols solving related problems<sup class="reference" data-citation="Y1">[?]</sup><sup class="reference" data-citation="GMW">[?]</sup><sup class="reference" data-citation="GHY">[?]</sup>. It therefore leads to practical solutions on problems involving small circuits.</li>
						</ul>
						<p class="rp_annotation">
							The above (being linear in the number of gates and in the number of participants) is inaccurate; it is actually quadratic in the number of participants, because the procedure <span class="main_language">Transform Circuit</span> has an \(i\) term in it, where \(i\) is the number of participants who have participated so far, which of course sums to \(\frac{n(n-1)}2\).
						</p>
						<ul class="rp_original">
							<li>The protocol is <span class="definable">openly verifiable</span>, i.e. any number of people can later come in and rechallenge any participant to verify that no cheating has occurred.</li>
							<li>The protocol is optimally secure against conspiracies: even if \(n-1\) out of the \(n\) participants <span class="definable" data-define="collusion">collude</span>, they will not find out more about the remaining participants' secrets than what they could already infer from their own input and the public output.</li>
							<li>Each participant has a chance of undetected cheating that is only exponentially small in the amount of time and space needed for the protocol.</li>
							<li>The protocol adapts easily, and with negligible extra cost, to various additional requirements, e.g. making part of the output private to some participant, ensuring that the participants learn the output simultaneously, etc.</li>
							<li>Participants can prove relations between data used in different instances of the protocol, even if those instances involve different groups of participants. For example, it can be proved that the output of one computation was used as input to another, without revealing more about this data.</li>
							<li>The protocol can be used as an essential tool in proving that all languages in IP have zero knowledge proof systems, i.e. any statement which can be proved interactively can also be proved in zero knowledge.</li>
						</ul>
						<p class="rp_original">
							The rest of this paper is organized as follows: First we survey some related results. Then <a href="#sec2">Section 2</a> gives an intuitive introduction to the protocol. In <a href="#sec3">Section 3</a>, we present one of the main tools used in this paper: <span class="definable" data-define="commitment">bit commitment schemes</span>. Sections <a href="#sec4">4</a> and <a href="#sec5">5</a> contain the notation, terminology, etc. used in the paper. In <a href="#sec6">Section 6</a>, the protocol is presented, along with proofs of its security and correctness. In <a href="#sec7">Section 7</a>, we show how to adapt the protocol to various extra requirements and discuss some generalizations and optimizations. Finally, <a href="#sec8">Section 8</a> contains some remarks on how to construct zero knowledge proof systems for any language in IP.
						</p>
					</section>
                    <section id="sec1">
                        <h2>1. Related Work</h2>
						<p class="rp_original">
							The problem of multiparty secure computations is an important one. When stated in its most general form, its solution implies a solution&mdash;at least a theoretical one&mdash;to almost any protocol construction problem. The first to consider this problem was Yao<sup class="reference" data-citation="Y2">[?]</sup>. He devised protocols that, under various cryptographic assumptions, could keep the inputs secret while allowing each participant only a <span class="definable">negligible</span> chance of cheating. He did not, however, address the problem of "fairness", i.e. ensuring that the participants learn the output simultaneously. Later, Yao<sup class="reference" data-citation="Y1">[?]</sup> solved also this problem for the two-party case. Recently, in work done independently from (but earlier than) ours, Goldreich, Micali, and Wigderson<sup class="reference" data-citation="GMW">[?]</sup> used Yao's two-party construction to devise a multiparty solution, based on the existence of a trapdoor one-way function. This protocol implements a multiparty simulation of the computation in a circuit. Each participant holds a share of each bit in the real computation, and these shares are manipulated by using Yao's two-party construction \(O(n^2)\) times, where \(n\) is the number of participants. In other work done independently from and almost simultaneously with ours, Galil, Haber, and Yung generalize all the properties of Yao's construction to the multiparty case, and simplify the use of Yao's protocol in the multiparty simulation. Also, they give a concrete construction based on Diffie-Hellman key exchange rather than the existence of a trapdoor one way function. Very recently, Goldreich and Vainish<sup class="reference" data-citation="GV">[?]</sup> found another simplification by designing a special purpose two-party protocol which could replace Yao's protocol in the multiparty construction.
						</p>
						<p class="rp_annotation">
							Indeed, Yao's original two-party construction was very distinctly <i>un</i>fair: one party was guaranteed to learn the output before the other party, and could easily make the other party believe anything.
						</p>
						<p class="rp_original">
							In comparison, our protocol solves the multiparty case using a totally different concept. It attacks the problem "directly", without using Yao's two-party protocol, and without using reductions to 3-colorability<sup class="reference" data-citation="GMW2"></sup> or to SAT<sup class="reference" data-citation="BC">[?]</sup><sup class="reference" data-citation="C">[?]</sup> to prove the validity of messages. We rely on a stronger cryptographic assumption than <span class="reference" data-citation="GMW">[?]</span>, namely the <i><span class="definable" data-define="quadratic residue">Quadratic Residuosity</span> Assumption</i><sup class="reference" data-citation="GM">[?]</sup>. This, however, allows a simpler and more efficient construction, capable of implementing all the "primitives for cryptographic computations", defined in <span class="reference" data-citation="GHY">[?]</span>. Although our protocol could also be based only on the existence of a <span class="definable" data-define="trapdoor function">trapdoor one-way function</span>, this would reduce the efficiency considerably. Some of the techniques upon which our protocol is based were previously developed and used in the work of Chaum<sup class="reference" data-citation="C">[?]</sup> and Brassard and Cr&eacute;peau<sup class="reference" data-citation="BC">[?]</sup>. By specializing to the case where only one participant supplies the inputs, our protocol can provide slightly more efficient solutions to the problems solved there.
						</p>
						<p class="rp_original">
							An interesting consequence of our work is that any statement which can be proved interactively, can also be proved in zero knowledge, provided that our cryptographic assumption holds (one assumption which will do in this case is the existence of <span class="definable" data-define="clawfree">clawfree trapdoor functions</span>). More formally: any language in IP has a zero knowledge proof system. This result was already proved for protocols with a constant number of rounds in <span class="reference" data-citation="GMW2"></span>, where a proof of the result in full generality is attributed to Ben-Or. As far as we know, this last proof is still unpublished, so we cannot comment on possible differences between this proof and ours.
						</p>
                    </section>
					<section id="sec2">
						<h2>2. Overview of the Constructions</h2>
						<p class="rp_original">
							For the intuitive sketch given in this section, we will make some simplifications. We will consider only two parties, \(A\) and \(B\) and we will do a computation on one AND-gate only. At the end of the section we will see how this method can be generalised to more parties, and to a computation consisting of many gates.
						</p>
						<p class="rp_original">
							Note that this AND-gate computation, where both parties want to hide their input from each other, has a meaningful application: consider the situation where Alice and Bob have just met, and each considers dating the other. Neither wishes to lose face in the following sense: if Alice wants a date but Bob doesn't, Alice does not want to let Bob know that she wanted the date. And the same holds for Bob. In other words: if a party does not want the date, they do not find out the other party's decision.
						</p>
						<p class="rp_annotation">
							We have our own version of this in the \(m\)-party case called the <a href="../../learn/ch1.html#sec3">fourth grader problem.</a>
						</p>
						<p class="rp_original">
							Note that sometimes a party can derive the other's input just by combining his or her own input with the output of the joint computation. This can never be avoided, however.
						</p>
						<p class="rp_original">
							The AND-gate is represented by a truth-table \(T\). We will show what transformations \(A\) and \(B\) have to apply to \(T\) in order to compute the logical AND, such that
						</p>
						<ul class="rp_original">
							<li>both parties can be sure (with very high probability) that the transformations are done correctly;</li>
							<li>both parties can keep their input hidden from the other party; and</li>
							<li>both parties can be sure the result of the computation is correct.</li>
						</ul>
						<h3>The Protocol</h3>
						<ol class="rp_original">
							<li><ol class="rp_original">
									<li>\(A\)(lice) applies a randomly chosen permutation, \(\sigma_j\), to the rows of \(T\).</li>
									<li>\(A\) chooses two bits \(b_1\) and \(b_3\), and uses these to compute the XOR of the \(k\)th column and \(b_k\). This procedure is known as <i>inversion of columns</i>.</li>
									<li>\(A\) chooses four bits \(d_1\cdots d_4\), and computes the XOR of the \(l\)th entry in the last column and \(d_l\). This procedure is known as <i>encryption the output column</i>.</li>
									<li>\(A\) encrypts \(b_1,b_3,d_1\cdots d_4\) in such a way that she cannot disavow these values later, while \(B\)(ob) cannot see what the values are without \(A\)'s help. This is known as <i><span class="definable" data-define="commitment">committing</span> to the bits</i>.</li>
								</ol>
							</li>
						</ol>
						<p class="rp_original">
							We will indicate the final result of these steps with \(\hat{T}\). \(B\) will verify whether \(\hat{T}\) was constructed correctly in the next steps:
						</p>
						<ol class="rp_original">
							<li value="2">\(A\) creates a transformed truthtable \(T'\) in exactly the same way as she created \(\hat{T}\).</li>
						</ol>
						<p class="rp_annotation">
							That is to say, using the same method/instructions, <i>not</i> using the same values or the same permutation.
						</p>
						<img class="rp_original" src="../../img/82.fig1.jpg" alt="Steps 1.1 through 1.4" />
						<ol class="rp_original">
							<li value="3">
								\(B\) flips a coin.
								<ul class="rp_original">
									<li>If the coin came out heads, \(A\) must reveal exactly how she constructed \(T'\), so that \(B\) can verify that this was done correctly.</li>
									<li>If the coin came out tails, \(A\) must show a special relation between \(\hat{T}\) and \(T'\). Details on this can be found in <a href="#sec6.1">Section 6.1</a>. Here, it suffices to know that if the relation holds, it implies that \(\hat{T}\) was correctly constructed if and only if \(T'\) was.</li>
								</ul>
							</li>
						</ol>
						<p class="rp_original">
							After \(m\) repetitions of steps 2 and 3, \(B\) is convinced with very high probability that \(A\) constructed \(\hat{T}\) correctly. Now \(B\) will do to \(\hat{T}\) what \(A\) did to \(T\), and even more:
						</p>
						<ol class="rp_original">
							<li value="4">
								<ol class="rp_original">
									<li>
										\(B\) permutes the rows of \(\hat{T}\), together with the commitments of the output column entries.
										<img alt="The row-permutation performed by \(B\)" class="rp_original" src="../../img/82.fig2.jpg" />
									</li>
									<li>\(B\) flips a coin for each output column entry and applies the XOR.</li>
									<li>
										\(B\) computes, <i>using \(A\)'s bit commitment scheme</i>, a commitment containing the XOR of his own bit and the one chosen and committed to by \(A\) for this output column entry. Although \(A\) can later open the resulting commitment, she will have no idea which of her original commitments it was computed from. This requires special properties of the commitment scheme used.
										<img alt="The blinding" class="rp_original" src="../../img/82.fig3.jpg" />
									</li>
								</ol>
							</li>
						</ol>
						<p class="rp_original">
							This <i>blinding</i> is necessary to hide \(B\)'s permutation. \(B\) also has to do a transformation corresponding exactly to the one of \(A\):
						</p>
						<ol class="rp_original">
							<li value="4">
								<ol class="rp_original">
									<li value="4">\(B\) chooses bits for inversion of his own input column, and for the output column.</li>
									<li>\(B\) chooses bits for inversion of each output column entry</li>
									<li>\(B\) commits to the bits chosen in steps 4.4 and 4.5. He then sends his final result, \(T^*\), to \(A\).
									<img alt="The final part of \(B\)'s transformation." class="rp_original" src="../../img/82.fig4.jpg" /></li>
								</ol>
							</li>
							<li>In the same way as in steps 2 and 3, \(B\) convinces \(A\) that \(T^*\) was constructed correctly.</li>
						</ol>
						<p class="rp_original">
							Now \(A\) and \(B\) have together constructed a double-blinded version \(T^*\) of the gate that satisfies the conditions listed before step 1. They will use \(T^*\) in performing the computation as follows:
						</p>
						<ol class="rp_original">
							<li value="6">Together they select the correct row of \(T^*\) by announcing their choice of input bits for \(T^*\). These input bits are the XOR sum of the "real" input bits, and the inversion bits for the corresponding columns.</li>
							<li>\(A\) and \(B\) both reveal the inversion bit for the output column, and the inversion bit for the entry in the output column which is in the selected row. By XORing this output column entry with the revealed inversion bits, they can both compute the bit that is the result of the computation.</li>
						</ol>
						<p class="rp_original">
							This basic protocol can be generalized in several ways:
						</p>
						<ul class="rp_original">
							<li>Instead of using an AND-gate, any type of gate can be used.</li>
							<li>Instead of two parties, any number of parties can participate in the protocol. Each new party just has to follow \(B\)'s part of the protocol, and will thus have to blind the commitments of each participant who went before.</li>
						</ul>
						<p class="rp_original">
							This does, of course, cause exponential blow-up with the number of parties, since we are building a truth table.
						</p>
						<ul class="rp_original">
							<li>Instead of using only one gate, a computation involving arbitrarily many gates can be done with the protocol. The only condition is that when gate \(T_1\) is connected to \(T_2\), then their corresponding output column and input column were inverted using the <i>same</i> bits. When later a row is selected in the encrypted version of \(T_1\), the inversion bits that apply to the single output column entry will be revealed, while the column inversion bits will remain secret. The revealed inversion bits are now XORed with the output column entry selected, and the result can be used directly as an input bit to the encryption version of \(T_2\).</li>
						</ul>
					</section>
					<section id="sec3">
						<h2>3. Bit Commitment Schemes</h2>
						<p class="rp_original">
							A bit <span class="definable">commitment</span> scheme is a tool allowing protocol participant \(A\)(lice) to "commit" to a bit \(b\in\{0,1\}\) by releasing some information related to \(b\) such that:
						</p>
						<ul class="rp_original">
							<li>She cannot later convincingly claim that \(b\) had the opposite value.</li>
							<li>No other participant can find the value of \(b\) unless \(A\) allows this (opens the commitment)</li>
						</ul>
						<p class="rp_original">
							More formally, a bit commitment scheme is a family of finite sets $$\{I_m\}_{m=1}^\infty$$ such that a member of \(I_m\) is a pair of functions $$(f_m^{(0)},f_m^{(1)}),$$ where $$f_m^{(0)}:\;R_m^{(0)}\;\;\rightarrow\;\;S_m\quad and\quad f_m^{(0)}:\;R_m^{(1)}\;\;\rightarrow\;\;S_m$$ where \(R_m^{(i)}\) and \(S_m\) are finite sets, and the function are polynomial (in \(m\)) time computable.
						</p>
						<p class="rp_annotation">
							Notice that, by making \(f_m^{(0)}\) and \(f_m^{(1)}\) public, Alice is allowing any party to commit to bits under her scheme.
						</p>
						<p class="rp_original">
							Further, there exists a probabilistic polynomial time algorithm \(\Omega\), which on input a value of the security parameter \(m\) outputs a member chosen randomly and uniformly from \(I_m\).
						</p>
						<p class="rp_original">
							To use the commitment scheme, \(A\) will choose an instance, i.e. she will choose a value of \(m\), run \(\Omega\) and make \(m,\,f_m^{(0)}\) and \(f_m^{(1)}\) public.
						</p>
						<p class="rp_original">
							To commit to a bit \(b,\,A\) chooses an element \(r\) uniformly in \(R_m^{(b)}\) and makes public $$\operatorname{BCS}_{A,m}(b,r)=f_m^{(b)}(r).$$
						</p>
						<p class="rp_original">
							Below, we list the properties of bit commitment schemes that are of interest in our protocol:
						</p>
						<span class="rp_sub_header">Hiding the bit:</span>
						<p class="rp_original rp_sub">
							Let \(\Delta\) be any probabilistic polynomial time algorithm which takes as input a commitment \(\operatorname{BCS}_{A,m}(b,r)\) and gives a one bit output \(\Delta(\operatorname{BCS}_{A,m}(b,r))\). Then for all constants \(c\),$$\left|\operatorname{Pr}\Big(\Delta\left(\operatorname{BCS}_{A,m}(b,r)\right)=b\Big)-\frac 1 2\right|\lt m^{-c}$$ for all sufficiently large \(m\). This holds for all but a fraction \(\epsilon(m)\) of the instances in \(I_m\), and as a function of \(m,\,\epsilon(m)\) <span class="definable" data-define="negligible">vanishes faster than any polynomial fraction</span>.
						</p>
						<p class="rp_original rp_sub">
							Thus, guessing from a commitment which bit it contains is a hard problem. Note that \(b\) must be uniquely determined from \(\operatorname{BCS}_{A,m}(b,r)\) and \(r\), but not necessarily from \(\operatorname{BCS}_{A,m}(b,r)\) alone. This also means that \(b\) may be impossible to find from a commitment to \(b\), even with infinite computing power.
						</p>
						<span class="rp_sub_header">Unforgeability:</span>
						<p class="rp_original rp_sub">
							Let \(\Delta\) be a probabilistic polynomial time algorithm which takes as input a commitment \(\operatorname{BCS}_{A,m}(b,r),\,b\) and \(r\), and gives as output an element \(r_\Delta\) in \(R_m^{(b\oplus 1)}\). Then, for any constant \(c\), $$\operatorname{Pr}\Big(\operatorname{BCS}_{A,m}(b,r)=\operatorname{BCS}_{A,m}(b\oplus 1,r_\Delta)\Big)\lt m^{-c}$$ for all sufficiently large \(m\). Again this holds for all but a fraction \(\epsilon(m)\) of the instances in \(I_m\), and as a function of \(m,\,\epsilon(m)\) vanishes faster than any polynomial fraction.
						</p>
						<p class="rp_original rp_sub">
							Thus it is not possible for a polynomially bounded \(A\) to lie about the contents of her commitments. But note that an \(r_\Delta\) satisfying the condition above may not exist at all, in which case it is impossible to lie, even with infinite computing power.
						</p>
						<span class="rp_sub_header">Opening a commitment:</span>
						<p class="rp_original rp_sub">
							Given \(\operatorname{BCS}_{A,m}(b,r),\,A\) can convince anyone that, for a given value of \(n\), she knows an \(r\) which will produce the given commitment. Typically, she will just reveal \(r\).
						</p>
						<span class="rp_sub_header">Comparability:</span>
						<p class="rp_original rp_sub">
							Given two commitments, \(\operatorname{BCS}_{A,m}(b,r)\) and \(\operatorname{BCS}_{A,m}(b',r')\), there exists a Minimum Knowledge Interactive Proof (MKIP) by which \(A\) can convince anyone about the value of \(b\oplus b'\).
						</p>
						<span class="rp_sub_header">Blinding:</span>
						<p class="rp_original rp_sub">
							Given a commitment \(\operatorname{BCS}_{A,m}(b,r)\), <i>another</i> participant, \(B\), can choose \(b'\in\{0,1\}\) and compute from this a blinded commitment \(\operatorname{BCS}_{A,m}(b\oplus b',r')\), where \(r'\) is uniformly distributed in \(R_m^{(b\oplus b')}\). There exists a MKIP such that, given these two commitments, \(B\) can convince anyone about the value of \(b'\).
						</p>
						<p class="rp_original rp_sub">
							Moreover, we require that given two commitments \(\operatorname{BCS}_{A,m}(b\oplus b',r')\) and \(\operatorname{BCS}_{A,m}(b\oplus b'',r'')\), which have been computed by \(B\) as above, there exists a MKIP by which B can convince anyone about the value of \((b\oplus b')\oplus(b\oplus b'')=b'\oplus b''\).
						</p>
						<p class="rp_original rp_sub">
							Finally, it must be possible for \(A\) to open commitments which have been blinded as above, just as if she had computed them herself.
						</p>
						<p class="rp_original">
							From a theoretical point of view, the opening and comparability properties do not represent demanding assumptions, since the required proofs can always be produced by using standard reductions to <span class="main_language">3Col</span> or <span class="main_language">Sat</span><sup class="reference" data-citation="GMW">[?]</sup><sup class="reference" data-citation="C">[?]</sup><sup class="reference" data-citation="BC">[?]</sup>. We will only be concerned, however, with bit commitment schemes allowing the proofs to be produced directly and efficiently. As a consequence, the main protocol will be much more efficient. 
						</p>
						<section id="sec3.1">
							<h3>3.1. Examples</h3>
							<p class="rp_original">
								The protocol presented in this paper relies on the existence of bit <span class="definable">commitment</span> schemes satisfying the properties defined above. In this subsection, we give three examples of commitment schemes which could be used in the protocol, namely the <i>Quadratic Residuosity Scheme</i> (QRS), <i>the Jacobi Symbol Scheme</i> (JSS), and <i>the Discrete Log Scheme</i> (DLS), of which DLS has not been used in published protocols before.
							</p>
							<p class="rp_original">
								In QRS, \(A\)(lice) uses the algorithm \(\Omega\) to select at random two \(m\)-bit primes, \(p\) and \(q\) with \(p\equiv q\equiv -1\pmod 4\). She then puts \(N=pq,\,\)<span class="equation" data-equation="R_m^b">\(R_m^{(0)}\)</span>\(=\)<span class="equation" data-equation="R_m^b">\(R_m^{(1)}\)</span>\(=\mathbb Z_N^*\) and <span class="equation" data-equation="Sm">\(S_m\)</span>\(=\Bigg\{x\in\mathbb Z_N^*\,\Bigg|\,\)<span class="equation" data-equation="JacobiSymbol">\(\left(\frac x N\right)\)</span>\(=1\Bigg\}\). She makes public \(N\) and uses for example the zero knowledge protocol from <span class="reference" data-citation="PG">[?]</span> to convince everyone that \(N\) is of the right form. In particular, this implies that -1 is a <span class="definable" data-define="quadratic residue">quadratic nonresidue</span> modulo \(N\) of <span class="definable">Jacobi symbol</span> 1. If we define $$f_m^{(b)}(r)=(-1)^br^2\bmod N$$ it is easy to see that a commitment will contain a 1 if and only if the commitment is a quadratic nonresidue modulo \(N\).
							</p>
							<p class="rp_annotation">
								In particular, \(N\) is a <span class="definable">Blum integer</span> and therefore has the mentioned property that -1 is a nonresidue but must have a Jacobi symbol of 1.
							</p>
							<p class="rp_original">
								The "hiding" condition above now translates into the well known <i>quadratic residuosity assumption</i>: it is hard, even probabilistically, to distinguish quadratic residues from quadratic nonresidues modulo \(N\) (a formal statement can be found in <span class="reference" data-citation="GM">[?]</span>). Moreover, even with infinite computing power, clearly \(A\) cannot lie about the contents of a commitment.
							</p>
							<p class="rp_original">
								The opening and comparability properties are easily verified for QRS: \(A\) simply makes public a square root modulo \(N\) of $$(-1)^b\operatorname{BCS}_{A,m}(b,r)\quad \left(\text{resp.}\quad(-1)^{b\oplus b'}\operatorname{BCS}_{A,m}(b,r)\operatorname{BCS}_{A,m}(b',r')^{-1}\right).$$ These proofs will be MKIPs because the commitments were chosen by \(A\) herself at random.
							</p>
							<p class="rp_original">
								Blinding is also a simple process: having chosen \(b',\,B\)(ob) computes the new commitment as $$(-1)^{b'}s^2\operatorname{BCS}_{A,m}(b,r)=\operatorname{BCS}_{A,m}(b\oplus b',rs),$$ where \(s\) is randomly chosen from \(Z_n^*.\,B\) can show the value of \(b'\) by showing a square root of $$(-1)^{b'}\operatorname{BCS}_{A,m}(b\oplus b',rs)(\operatorname{BCS}_{A,m}(b,r))^{-1},$$ which equals \(s.\,s\) is called <i>the blinding factor</i>.
							</p>
							<p class="rp_original">
								Also, given two blinded commitments as above, \(B\) can show a square root of $$(-1)^{b'\oplus b''}\operatorname{BCS}_{A,m}(b\oplus b',r')(\operatorname{BCS}_{A,m}(b\oplus b'',r''))^{-1}$$ to convince everyone about the value of \(b'\oplus b''\).
							</p>
							<p class="rp_original">
								Clearly, \(A\) can open any commitment by using her knowledge of the factors of \(N\) to compute square roots. But it is important to note that it will only be safe for her to do so if she is convinced that she will always be opening blinded forms of commitments chosen by <i>herself</i>. This will be ensured by the construction of our main protocol.
							</p>
							<p class="rp_annotation">
								Let's quickly specify an attack for if \(A\) opens a commitment that is not a blinded version of one of her own commitments. Let's say \(A\) has released the commitment \((-1)^br^2\bmod N\); \(B\) pretends to blind it with some identical bit and some value \(t^2\), making it \((-1)^b(-1)^b(rt)^2\equiv(rt)^2\pmod N\). Since \(\mathbb Z_N^*\) is a multiplicative ring, if \(B\) simply chooses an \(s\), there must exist some \(t\) such that \(rt=s\) and therefore such that \(s^2=(rt)^2\). \(B\) can therefore give \(A\) the commitment \(s^2\bmod N\) and, without further information, \(A\) cannot tell the difference between the fake commitment and a real one. If \(A\) opens the commitment, returning that a square root of \(s^2\) is \(x\), there is a 50% chance that \(x\not\equiv\pm s\pmod N\) since all quadratic residues have 4 square roots. $$\begin{align}x^2&\equiv s^2&\pmod N \\ x^2-s^2&\equiv0&\pmod N \\ (x-s)(x+s)&\equiv 0&\pmod N\end{align}$$ Since \((x-s)\not\equiv0\), we have factored \(N\).
							</p>
							<p class="rp_original">
								In the JSS (first introduced by Blum<sup class="reference" data-citation="Bl">[?]</sup>), some participant \(B\) chooses a modulus \(N\) of the same form as above, such that the factorization is unknown to \(A\), and convinces her as above that \(N\) was correctly chosen. We then put $$\begin{align}R_m^{(0)}\;&=\;\left\{x\in\mathbb Z_N^*\,\middle|\,\left(\frac x N\right)=1\right\},\\ R_m^{(1)}\;&=\;\left\{x\in\mathbb Z_N^*\,\middle|\,\left(\frac x N\right)=-1\right\},\end{align}\\ \text{and}\quad S_m\;=\;QR(N),$$ where \(QR(N)\) denotes the set of <span class="definable" data-define="quadratic residue">quadratic residues</span> modulo \(N\). Finally, we set $$f_m^{(b)}(r)\;=\;r^2\bmod N,$$ where \(r\in R_m^{(b)}\).
							</p>
							<p class="rp_original">
								This scheme hides the bits unconditionally: since each square modulo \(N\) has two square roots of Jacobi symbol +1 and two of Jacobi symbol -1, release by \(A\) of \(\operatorname{BCS}_{A,m}(b,r)\) gives away no Shannon information about \(b\). On the other hand, the unforgeability property only holds conditionally here: if \(A\) could factor \(N\), she could lie about the value of \(b\).
							</p>
							<p class="rp_original">
								JSS also satisfies the comparability property: Given two commitments \(s_1\,=\,\operatorname{BCS}_{A,m}(b,r)\) and \(s_2\,=\,\operatorname{BCS}_{A,m}(b',r'),\,A\) can make public a square root of \(s_1(s_2)^{-1}\) of Jacobi symbol \((-1)^{b\oplus b'}\) to convince everybody about the value of \(b\oplus b'\). Note that this is still information theoretically secure: after having seen a proof that \(b\oplus b'\,=\,1\), say, the two possibilities \((b,b')\,=\,(1,0)\) and \((b,b')\,=\,(0,1)\) remain equally likely, even to someone who knows the factorization of \(N\).
							</p>
							<p class="rp_original">
								Note that if \(A\) is going to commit to bits using JSS in a multiparty protocol, every participant except \(A\) must supply a different modulus, and when committing to a bit, \(A\) must make public a set of commitments to this bit, one for each modulus supplied. This is to prevent the possibility that \(A\) breaks the unforgeability property by conspiring with somebody who knows the factorizations. This of course means that the other participants must be convinced that the same bit is contained in all commitments in a given set. Fortunately, the construction of our main protocol is such that this automatically ensured whenever JSS is used.
							</p>
							<p class="rp_original">
								Note also that if absolute certainty is needed about the correctness of the choice of \(N,\,B\) could be required to simply reveal the factorization of \(N\) after the protocol has been executed. It would be too late for \(A\) by then to use this knowledge in the protocol. Another possibility is for \(B\) to prove to \(A\) in zero knowledge that the modulus has the right form. However, all the known proofs of this leave an exponentially small probability that \(B\)'s claim is false, in which case \(A\) <i>would</i> be giving away information about her secrets. Thus it seems that with this scheme, \(A\) will never be quite sure that her secrets have not been betrayed until after it happened!
							</p>
							<p class="rp_original">
								The next example, the <span class="definable" data-define="discrete logarithm problem">Discrete Log Scheme</span>, solves this problem. Here, \(B\) chooses an \(m\)-bit prime \(p\), a generator \(g\) of \(\mathbb Z_p^*\), and an element \(a\in\mathbb Z_p^*\) at random and reveals them to \(A\). We now put \(R_m^{(1)}\,=\,R_m^{(0)}\,=\,S_m\,=\,\mathbb Z_p^*\), and $$f_m^{(b)}(r)\,=\,a^bg^r.$$
							</p>
							<p class="rp_original">
								This scheme also hides the bits unconditionally, since the bit contained in a commitment is not uniquely determined, if the random choice made by \(A\) is unknown. Note that if \(p\) is determined such that the factorization of \(p-1\) is known, \(A\) can easily check for herself that \(p\) is a prime and that \(g\) is a generator.
							</p>
							<p class="rp_original">
								To open a commitment, \(A\) must show the discrete log base \(g\) of $$a^{-b}\operatorname{BCS}_{A,m}(b,r),$$ namely \(r\). It is also easy to see that the unforgeability property holds, assuming that \(A\) cannot find the discrete log of \(a\).
							</p>
							<p class="rp_original">
								Given two commitments \(\operatorname{BCS}_{A,m}(b,r)\) and \(\operatorname{BCS}_{A,m}(b',r'),\,A\) can prove that \(b\oplus b'=0\) by showing the discrete log of $$\operatorname{BCS}_{A,m}(b,r)(\operatorname{BCS}_{A,m}(b',r'))^{-1}$$ and to show that \(b\oplus b'=1\), she shows the discrete log of $$a^{-1}\operatorname{BCS}_{A,m}(b,r)\operatorname{BCS}_{A,m}(b',r').$$ Once again, it is easy to see that \(A\) cannot make a false claim about \(b\oplus b'\) unless she can find the discrete log of \(a\).
							</p>
							<p class="rp_original">
								An additional advantage of DLS compared to JSS is that it is not necessary in a multiparty application that all participants different from \(A\) choose their own instances, and that \(A\) then must commit to a bit "in parallel" using all the published instances. Since there is no trapdoor present in DLS, all participants can collaborate in choosing \(p,\,g\) and \(a\) using some multiparty coinflipping protocol.
							</p>
						</section>
					</section>
					<section id="sec4">
						<h2>4. Protocols: notation and definitions</h2>
						<p class="rp_original">
							We think of a protocol as occurring among a set of communicating probabilistic <span class="definable" data-define="Turing machine">Turing machines</span> \(\{P_1,\dots,P_n\}\) called the participants. The protocol is described as a specification of the program each participant should follow.
						</p>
						<p class="rp_original">
							Each machine has private input, output, and random tapes, and one communication tape. The contents of the input tape of \(P_i\) is called <span class="equation" data-equation="ip">\(ip_i\)</span>, the contents of the output tape after execution of the protocol is called <span class="equation" data-equation="op">\(op_i\)</span>. All machines are <span class="definable" data-define="synchronous network">clocked by a common clock</span>, and the protocol proceeds in rounds. In each round, exactly one machine can do some computation and perhaps write a message on the other machines' communication tapes. By definition, all messages sent in the protocol are written simultaneously on all communication tapes. If a machine receives a message which does not obey the constraints specified in the protocol, it stops immediately, and we say that <i>cheating has been detected</i>.
						</p>
						<p class="rp_annotation">
							The above implicitly defines a <span class="definable">broadcast channel</span>: that is, all communication tapes are written to with identical messages simultaneously, which is equivalent to every machine being able to write to a single channel that all parties can read. This is not terribly important in terms of the results of the paper, it simply makes exposition simpler.
						</p>
						<p class="rp_original">
							We assume the existence of a mutually trusted source of random bits. Such a source could easily be implemented using e.g. Blum's coin flipping problem<sup class="reference" data-citation="Bl">[?]</sup>. But since the construction of such a subprotocol is independent of our main protocol, we have chosen to abstract away the fact that a subprotocol is used.
						</p>
						<p class="rp_original">
							The protocol takes some global input, known to all machines:
						</p>
						<ul class="rp_original">
							<li>A specification of the computation to be performed, in the form of a boolean circuit \(C\).</li>
							<li>The cryptographic security parameter \(m\).</li>
						</ul>
						<p class="rp_original">
							Note that the security and the certainty of correctness may be varied <i>independently</i> of the complexity of the computation modelled by \(C\). Moreover, the protocol never uses any special properties of \(C\), such as membership of a polynomial size family. For these reasons, we look at \(C\) just as a single fixed circuit.
						</p>
						<p class="rp_original">
							Of course, this does not mean that the behavior of e.g. the running time of the protocol as a function of \(C\) is not interesting, only that such dependencies should be considered independently of the security level.
						</p>
						<section id="sec4.1">
							<h3>4.1. Correctness and Security</h3>
							<p class="rp_original">
								The definitions in this section are straightforward generalizations of the definition of "<span class="definable">zero knowledge proof</span> systems" found in <span class="reference" data-citation="GMR">[?]</span>. This becomes clear if one takes a slightly different point of view of the situation where a prover convinces a verifier about the membership of a string \(x\) in an <span class="definable">NP</span>-language \(L\).
							</p>
							<p class="rp_original">
								In fact the prover and the verifier are doing an interactive computation, where only the prover supplies input, namely a certificate of membership for \(x\). The notion of correctness of the protocol they execute corresponds to the fact that we have a proof system: we want the protocol to produce the correct output of the computation, namely "accept" if indeed the prover put in a valid certificate of membership for \(x\). The notion of security corresponds to the fact that the proof system is zero knowledge: we want the verifier to gain nothing useful about the secrets of the prover, other than the fact that \(x\) is in \(L\).
							</p>
							<p class="rp_original">
								If we model the computation needed to verify membership for \(x\) by a boolean circuit \(C\), it is clear that this is just a special case of the general problem addressed in this paper.
							</p>
							<p class="rp_original">
								We allow \(C\) to be a probabilistic circuit, i.e. take as input a number of bits chosen uniformly from \(\{0,1\}\). Thus, given as inputs \(I=\)<span class="equation" data-equation="ip">\((ip_1,\dots,ip_n)\)</span>\(,\,C\) determines a probability distribution \(OP_I^C\) on the output. We assume for simplicity that the output is public, i.e. the same output string will appear on the output tape of any participant following the protocol (the generalization to different (private) outputs is easy and will be discussed <a href="#sec7.1">later</a>). Given a choice of inputs as above, we let \(OP_{I,m}^{prot}\) denote the probability distribution according to which the output string of a participant following the protocol is distributed, when the protocol is executed with security parameter value \(m\) and no cheating is detected. We would like this distribution to be essentially equal to \(OP_I^C\). In other words, the only way for (a set of) dishonest participant(s) to prevent the correct result from being computed is to stop the protocol, e.g. by deliberately sending an incorrect message.
							</p>
							<p class="rp_original">
								We let \(OP_I^C(op)\) (resp. \(OP_{I,m}^{prot}(op)\)) denote the probability that the binary string \(op\) is produced as output.
							</p>
							<span class="rp_definition_header" id="def4.1">Definition 4.1</span>
							<p class="rp_original rp_definition">
								A protocol is said to be <i>correct</i> if for any choice of inputs \(I=\)<span class="equation" data-equation="ip">\((ip_1,\dots,ip_n)\)</span>, and any binary string \(op\) and constant \(c,\) $$|OP_I^C(op)-OP_{I,m}^{prot}(op)|\lt m^{-c}$$ for all sufficiently large \(m\).
							</p>
							<p class="rp_original">
								A <span class="definable">conspiracy</span> is a subset \(X\) of \(\{P_1,\dots,P_n\}\) with \(|X|\lt n\). The machines in a conspiracy may follow any (polynomial time) program, and they may establish private communication channels to share all the information available to them.
							</p>
							<p class="rp_original">
								Intuitively, we will consider the protocol secure if no conspiracy will learn more from the protocol than what could already have been inferred from the output of the computation and the part of the input known to the conspiracy.
							</p>
							<p class="rp_original">
								To state this more formally, we need some definitions:
							</p>
							<p class="rp_original">
								The binary string which is that concatenation of all messages sent during an execution of the protocol is called a <span class="definable">protocol conversation</span>.
							</p>
							<p class="rp_original">
								Let <span class="equation" data-equation="ra">\(ra\)</span> be a binary string containing as many bits as there are random input bits to \(C\). Then by <span class="equation" data-equation="fC">\(f_C(ip_1,\dots,ip_n,ra)\)</span> we denote the output of \(C\) resulting from inputs <span class="equation" data-equation="ip">\((ip_1,\dots,ip_n)\)</span> and random choice <span class="equation" data-equation="ra">\(ra\)</span>.
							</p>
							<p class="rp_original">
								We let <span class="equation" data-equation="Pprot">\(P_{prot}^{(m)} (ip_1,\dots,ip_n,ra)\)</span> denote the probability distribution according to which a protocol conversation with security parameter \(m\) and inputs \((\)<span class="equation" data-equation="ip">\(ip_1,\dots,ip_n\)</span>\(,\)<span class="equation" data-equation="ra">\(ra\)</span>\()\) is distributed.
							</p>
							<p class="rp_original">
								Note that this distribution is conditional on the program followed by the machines in <span class="equation" data-equation="X">\(X\)</span>, i.e. the conspiracy's strategy. Note also that the definition talks about the inputs of machines in <span class="equation" data-equation="X">\(X\)</span>. This is not necessarily a meaningful concept: nothing prevents a dishonest participant from pretending that the contents of its input tape are different from what they are in fact. This "problem" is easily solved, however, if we jump ahead in the protocol description a little: each participant must publish bit commitments which determine a particular choice of input. We therefore <i>define</i> the input of a participant to be the bit string committed to during the execution of the protocol.
							</p>
							<p class="rp_original">
								A <span class="definable" data-define="simulator for X">simulator for \(X\)</span> is a polynomial time Turing machine \(M_X\) which, on input \(\left(m, f_C(ip_1,\dots,ip_n,ra), \left\{ip_i,\,\middle|\,P_i\in X\right\}\right)\) will generate a protocol conversation distributed according to the distribution \(P_{M_X}^{(m)}\left(f_C(ip_1,\dots,ip_n,ra), \left\{ip_i,\,\middle|\,P_i\in X\right\}\right)\).
							</p>
							<span class="rp_definition_header" id="def4.2">Definition 4.2</span>
							<p class="rp_original rp_definition">
								The protocol is said to be <i>secure against the conspiracy <span class="equation" data-equation="X">\(X\)</span></i> if there exists a <span class="definable" data-define="simulator for X">simulator for \(X\)</span>, \(M_X\), such that for any <span class="equation" data-equation="ip">\((ip_1,\dots,ip_n)\)</span> and <span class="equation" data-equation="ra">\(ra\)</span>, the two ensembles of probability distributions $$\left\{P_{M_X}^{(m)}\left(f_C(ip_1,\dots,ip_n,ra), \left\{ip_i,\,\middle|\,P_i\in X\right\}\right)\right\}_{m=1}^\infty$$ and $$\left\{P_{prot}^{(m)}(ip_1,\dots,ip_n,ra)\right\}_{m=1}^\infty $$ are polynomially (in \(m\)) <span class="definable">indistinguishable</span>.
							</p>
							<p class="rp_original">
								We assume that the reader is familiar with this notion. For details, refer to <span class="reference" data-citation="GMR">[?]</span>.
							</p>
							<p class="rp_annotation" data-broken-link=true>
								There is also soon to be a tutorial on proof of zero-knowledge through simulation.
							</p>
							<p class="rp_original">
								The protocol is said to be <i>secure</i> if it is secure against any conspiracy.
							</p>
							<p class="rp_original">
								This definition means that no matter which type of hostile behavior is exhibited by \(X\), the private inputs of all honest participants <i>and</i> the random inputs are optimally protected. But note that providing the protocol secure under this definition does not exclude the possibility that a conspiracy, by stopping the protocol in some clever way, could find out about the output, while preventing honest participants from getting at it. The basic protocol as described in <a href="#sec5">Section 5</a> already offers protection against this, but a lot of variations on the theme are possible. More details will be given in <a href="#sec6">Section 6</a>.
							</p>
							<p class="rp_annotation">
								This concept of a conspiracy learning the output while stopping the other parties from learning the output is known in the literature as <i>fairness</i>.
							</p>
						</section>
					</section>
					<section id="sec5">
						<h2>5. Circuits, terminology, and notation</h2>
						<p class="rp_original">
							We think of a boolean circuit \(C\) in the usual way, as an acyclic directed graph where the nodes are called <i>gates</i> and the edges are called <i>wires</i>.
						</p>
						<p class="rp_original">
							A wire may be connected only into a gate, in which case it is called an <i>input wire</i>. If it leaves a gate without connecting it into another, we call it an <i>output wire</i>.
						</p>
						<p class="rp_original">
							The input wires are partitioned into \(n+1\) disjoint subsets, \(I_1,\dots,I_n,R\). <span class="equation" data-equation="ip">\(I_j\)</span> corresponds to the secret input chosen by \(P_j\), such that <span class="equation" data-equation="ip">\(ip_j\)</span> contains one bit for each wire in <span class="equation" data-equation="ip">\(I_j\)</span>. In a similar way, <span class="equation" data-equation="ra">\(R\)</span> corresponds to the random inputs to \(C\).
						</p>
						<p class="rp_original">
							For each gate, a function is specified that maps the input bits to a one bit output. For the gate \(G\), this function is given by the <i>truth table</i> \(T(G).\,T(G)\) is a 0-1 matrix with \(t+1\) columns and \(2^t\) rows, where \(t\) is the number of wires connecting into \(G\). The rows, apart from the last entry, contain each possible assignment of bits to the input of \(G\) exactly once, and the last column contains the corresponding output bits. Note that each input column in each truth table corresponds to exactly one wire in \(C\), and that an output column may correspond to any number of wires ("fan-out" from a gate is allowed). Thus, two columns may correspond to the same wire. Two such columns are said to be <i>connected</i>.
						</p>
						<span class="rp_definition_header" id="def5.1">Definition 5.1</span>
						<p class="rp_original rp_definition">
							A <i>computation</i> \(\Gamma\) in \(C\) consists of a <i>selection</i> of exactly one row in each truth table. The <i>input</i> of \(\Gamma\) is the corresponding assignment of bits to the input wires of \(C\), the <i>output</i> of \(\Gamma\) is the corresponding assignment of bits to the output wires.
						</p>
						<p class="rp_original rp_definition">
							A computation is said to be <i>consistent</i> if the following is satisfied: whenever two truth table columns \(c_1\) and \(c_2\) are connected, the entry selected by \(\Gamma\) in \(c_1\) equals the entry selected in \(c_2\).
						</p>
						<section id="#sec5.2">
							<h3>Transformations of Truth Tables</h3>
							<p class="rp_original">
								Our protocol works with "transforms" of truth tables. Basically, a transform of a truth table \(T(G)\) is just a row-permuted version of \(T(G)\) with the last column changed and some extra (encrypted) information about the transformation included.
							</p>
							<span class="rp_definition_header" id="def5.2">Definition 5.2</span>
							<p class="rp_original rp_definition">
								Let \(g\) be a gate in \(C\) with \(t\) input wires. For \(i=1\cdots n\), we define an <i>\(i\)-transform \(T\) of \(T(G)\)</i> to be a \((t+1)\) by \(2^t\), 0-1 matrix with a list of bit commitments attached to each row and each column. The list attached to row \(l\) is called \(rlist(l,T)\). The list attached to column \(k\) is called \(clist(k,T)\).
							</p>
							<p class="rp_original rp_definition">
								Each list contains one commitment from each participant \(P_j\), for which \(j\leq i\), except \(clist(k,T)\), when the \(k\)-th column corresponds to an input wire in some \(I_j\). These lists are empty if \(j\gt i\), and contain one bit commitment from \(P_j\) if \(j\leq i\).
							</p>
							<p class="rp_original rp_definition">
								By \(rsum(l,T)\) (resp. \(csum(k,T)\)), we denote the XOR sum of all bits commited to in \(rlist(l,T)\) (resp. \(clist(k,T)\)). The sum of an empty list is defined to be 0.
							</p>
							<p class="rp_original rp_definition">
								A 0-transform of \(T(G)\) is defined to be simply \(T(G)\) itself.
							</p>
							<p class="rp_original">
								Most of the work done in the protocol by \(P_i\) will consist of receiving \((i-1)\)-transforms and from these creating \(i\)-transforms. We require that there is some specific relation between a truth table \(T(G)\) and its transforms used in the protocol. When this relation holds, the transform is said to be <i>valid</i>. A valid transform can be seen as an encrypted version of \(T(G)\): the rows are permuted, and each column is XORed with an independently chosen bit. In addition to this, the last entry in each row is XORed with an independently chosen bit. The attached lists of bit commitments (when opened) contain complete information about how the transform was constructed. More specifically, we have the following:
							</p>
							<span class="rp_definition_header" id="def5.3">Definition 5.3</span>
							<p class="rp_original rp_definition">
								A <i>valid \(i\)-transform \(T\) of \(T(G)\)</i> is an \(i\)-transform of \(T(G)\) which satisfies that:
							</p>
							<p class="rp_original rp_definition">
								There exists a permutation \(\sigma\) of \((1,\dots,2^t)\) such that: $$\begin{split}
								T_{lk}&=T(G)_{\sigma(l)k}\oplus csum(k,T),\quad\,&\mbox{if}\;k\lt t+1,\\
								T_{lk}&=T(G)_{\sigma(l)k}\oplus csum(k,T)\oplus rsum(l,T),\quad &\mbox{if}\;k= t+1,
								\end{split} $$ where \(T_{lk}\) (resp. \(T(G)_{lk}\)) is the entry in the \(l\)-th row and \(k\)-th column of \(T\) (resp. \(T(G)\)).
							</p>
						</section>
					</section>
					<section id="sec6">
						<h2>6. The Protocol</h2>
						<p class="rp_original">
							The first step in the protocol is that each participant chooses an instance of a bit commitment scheme and uses the protocols mentioned in <a href="#sec2">Section 2</a> to convince all other participants that the choice was made correctly. We assume for simplicity that all participants use the same value of \(m\) as security parameter but, in principle, different participants could choose different levels of security.
						</p>
						<p class="rp_original">
							The commitment scheme chosen by participant \(P_i\) is called \(\operatorname{BCS}_i\).
						</p>
						<p class="rp_original">
							All commitment schemes \(\operatorname{BCS}_i\) with \(i\lt n\) must satisfy all properties defined in <a href="#sec2">Section 2</a>, so they can be instances of QRS, but not of JSS or DLS. \(\cancel{c_n}\;\operatorname{BCS}_n\) must satisfy all the properties from <a href="#sec2">Section 2</a>, except the blinding property, so it could be an instance of JSS or DLS.
						</p>
						<p class="rp_annotation">
							Notice that above we corrected the (undefined) value \(c_n\) with \(\operatorname{BCS}_n\), based on context.
						</p>
						<p class="rp_original">
							The main part of the protocol proceeds in two phases: 1) The Encryption Phase and 2) The Computation Phase. Each is described formally in separate subsections below.
						</p>
						<section id="sec6.1">
							<h3>6.1. The Encryption Phase</h3>
							<p class="rp_original">
								The procedure <span class="main_language">Transform Circuit</span> below is iterated once by each participant, such that the \(i\)-th iteration is executed by \(P_i\). After each iteration, the protocol <span class="main_language">Check Transformation</span> is executed to verify that the preceding iteration of <span class="main_language">Transform Circuit</span> has been performed correctly. The input to the first iteration will be the truth tables in the original circuit.
							</p>
							<section id="protocol1">
								<h4>Procedure <span class="main_language">Transform Circuit</span>.</h4>
								<p class="rp_original rp_sub"><i>Input: in the \(i\)-th iteration, one \((i-1)\)-transform of each truth table in \(C\). Output: one \(i\)-transform of each truth table in \(C\)</i>.</p>
								<p class="rp_original">
									For each \((i-1)\)-transform \(S\) supplied in the input, do the following:
								</p>
								<ol class="rp_original">
									<li>Suppose the corresponding gate in \(C\) has \(t\) input wires, so that \(S\) has \(2^t\) rows and \(t+1\) columns. Choose a permutation \(\sigma\) of \(\{1,\dots,2^t\}\) at random and apply \(\sigma\) to the rows of \(S\) with attached lists. Call the result \(T\).</li>
									<li>For \(l=1\cdots 2^t\), and each \(j\lt i\), do:
									<p class="rp_original">
										choose a bit \(s_{ij}(l,T)\in\{0,1\}\) at random and XOR the last entry in the \(l\)-th row of \(T\) with \(s_{ij}(l,T)\). Find the commitment $$\operatorname{BCS}_j(b_j(l,T),r_j(l,T))\in rlist(l,T),$$ and use the blinding property of \(\operatorname{BCS}_j\) to replace this commitment with $$ \operatorname{BCS}_j(b_j(l,T)\oplus s_{ij}(l,T), r'_j(l,T))\in rlist(l,T).$$
									</p></li>
									<li>For \(k=1\cdots t+1\) do:
									<p class="rp_original">
										if the \(k\)-th column in \(T\) does not correspond to any input wire in \(I_i\), then do nothing.
									</p><p class="rp_original">
										Otherwise, choose a bit \(b_i(k,T)\in\{0,1\}\) in the following way: If column \(k\) in \(T\) is connected to another column in another transform for which a bit \(b\) has already been chosen, then put \(b_i(k,T)=b\). Otherwise, choose \(b_i(k,T)\) at random. Now XOR all entries in the \(k\)-th column of \(T\) with \(b_i(k,T)\), and append to \(clist(k,T)\) a commitment $$\operatorname{BCS}_i(b_i(k,T),r_i(k,T)).$$
									</p></li>
									<li>For \(l=1\cdots 2^t\) do:<p class="rp_original">
										Choose a bit \(b_i(l,T)\in\{0,1\}\) at random, XOR the last entry in the \(l\)-th row of \(T\) with \(b_i(l,T)\), and append to \(rlist(l,T)\) a commitment $$\operatorname{BCS}_i(b_i(l,T),r_i(l,T)).$$
									</p></li>
								</ol>
								<p class="rp_original">
									Notice that the special way of choosing \(b_i(k,T)\) in step 3 ensures that whenever two columns are connected, the contents of the corresponding column lists will be identical.
								</p>
								<p class="rp_original">
									The purpose of step 2 is to hide the row permutation \(\sigma\). The blinding in this step ensures that the contents of the row lists in \(S\) and \(T\) are statistically independent, so that no information about \(\sigma\) is revealed by the row lists. The reader may have noticed that information about \(\sigma\) is revealed by the contents of the input columns in \(T\). But since each such column contains as many 0's as 1's, a particular entry in a column still has the same probability of being the encryption of a 1 as of a 0, if the bit XORed into the column by \(P_i\) is unknown. This will be sufficient to make the protocol secure, as we shall see.
								</p>
							</section>
							<p class="rp_original">
								The interactive proof <ins>demonstrating</ins> that every \(T\) was created according to the protocol proceeds as follows:
							</p>
							<section id="protocol2">
								<h4>Protocol <span class="main_language">Check Transformation</span></h4>
								<p class="rp_original rp_sub">
									<i>Input: for every truth table in \(C\), an \((i-1)\)-transform \(S\) and an \(i\)-transform \(T\), which \(P_i\) claims was created correctly from \(S\).</i>
								</p>
								<ol class="rp_original">
									<li>For every corresponding pair \(S,T\) in the input, \(P_i\) creates from \(S\) another \(i\)-transform \(T'\) in exactly the same way as \(T\), but with new independent choices of permutation and bits. \(T'\) is made public.</li>
									<li>The mutually trusted source of random bits chooses \(b\in\{0,1\}\) at random.</li>
									<li>If \(b=1,\,P_i\) must for every \(T'\): make public the row permutation used for creating \(T'\), open all bit commitments attached to \(T'\), and reveal all blinding factors (see <a href="#sec2">Section 2</a>) used in blinding other commitments. This allows everybody to check that \(T'\) was correctly constructed.</li>
									<li><p class="rp_original">
										If \(b=0,\,P_i\) must show for all corresponding \((T,T')\) a relation between \(T\) and \(T'\):
									</p><p class="rp_original">
										\(P_i\) makes public the permutation \(\pi=\sigma(\sigma')^{-1}\), where \(\sigma\) (resp. \(\sigma'\)) is the permutation used in creating \(T\) (resp. \(T'\)).
									</p><p class="rp_original">
										For \(k=1\cdots t+1:\) if \(P_i\) appended commitments to \(clist(k,T)\) and \(clist(k,T'),\,P_i\) uses comparability of \(\operatorname{BCS}_i\) to show from those commitments the value of $$b_i(k,T)\oplus b_i(k,T').$$
									</p><p class="rp_original">
										For \(l=1\cdots 2^t,\,P_i\) uses comparability of commitments in \(rlist(l,T)\) and \(rlist(\pi(l),T')\) to show the value of $$s_{ij}(l,T)\oplus s_{ij}(\pi(l),T').$$
									</p><p class="rp_original">
										This allows everybody to check that the following holds: $$\begin{split}T_{lk}\;&=\;T'_{\pi(l)k}\oplus csum(k,T)\oplus csum(k,T'), &\mbox{if}\;k\lt t+1,\\T_{lk}\;&=\;T'_{\pi(l)k}\oplus csum(k,T)\oplus csum(k,T')\oplus rsum(l,T)\oplus rsum(\pi(l),T'),\;&\mbox{if}\;k=t+1.\end{split}$$
									</p></li>
								</ol>
								<p class="rp_original">
									Steps 1-4 are repeated \(m\) times.
								</p>
							</section>
							<span class="rp_theorem_header" id="theorem6.1">Theorem 6.1</span>
							<p class="rp_original rp_theorem">
								For every \(i=1\cdots n\), the probability that \(P_i\) has cheated (i.e. sent incorrect messages) anywhere in the protocol is smaller than \(m^{-c}\) for any constant \(c\) and all sufficiently large \(m\). If no cheating occurs, then the encryption phase ends with \(P_n\) outputting a valid \(n\)-transform of every truth table in \(C\).
							</p>
							<span class="rp_sub_header">Proof</span>
							<p class="rp_original rp_sub">
								It is not hard to see that if at least one iteration in the <span class="main_language">Check Transformation</span> protocol, \(P_i\) was able to give satisfying answers in <i>both</i> steps 3 and 4, and if \(P_i\) was not able to change the contents of his bit commitments, then \(T\) must have been correctly constructed. This and the unforgeability property of all bit commitment schemes used suffice to prove the first statement. The second follows from the obvious fact that if \(T\) was created correctly from \(S\) in the <span class="main_language">Transform Circuit</span> protocol, then \(T\) is valid if \(S\) was valid.
							</p>
							<p class="rp_original">
								If all participants use QRS for bit commitments, then the unforgeability property holds unconditionally for all participants, which means that the probability of undetected cheating will be at most \(2^{-m}\).
							</p>
							<p class="rp_original">
								Intuitively, the <span class="main_language">Check Transformation</span> protocol is secure from \(P_i\)'s point of view because all the other participants never see anything but random "copies" of \(S\) or \(T\), which they could also have produced themselves. All other participants will therefore be convinced that \(T\) was correctly constructed, but will learn nothing more about \(T\). A formal proof can be found in <a href="#sec6.3">Section 6.3</a>.
							</p>
						</section>
						<section id="sec6.2">
							<h3>6.2. The Computation Phase</h3>
							<p class="rp_original">
								At the end of the encryption phase, \(P_n\) has output a set of \(n\)-transforms of the truth tables in \(C\). This set will be called \(C^*\).
							</p>
							<p class="rp_original">
								Let \(w\) be an input wire in \(C\) connecting into the gate \(G\), and suppose \(w\) corresponds to column \(k\) in \(T(G)\). Let \(T^*\) be the \(n\)-transform of \(T(G)\) contained in \(C^*\).
							</p>
							<p class="rp_original">
								As the first step in the computation phase, <i>encrypted</i> input bits are specified for each such \(w\). This is done as follows: if \(w\in\) <span class="equation" data-equation="ra">\(R\)</span>, then the mutually trusted source of random bits selects a bit \(b_w\), which is made public; if \(w\in\)<span class="equation" data-equation="ip">\(I_i\)</span> for some \(i,\,P_i\) reads a bit \(b\) in <span class="equation" data-equation="ip">\(ip_i\)</span> corresponding to \(w\) from its private input tape, and then makes \(b_w=b\oplus b_i(k,T^*)\) public.
							</p>
							<p class="rp_original">
								To describe the next steps in the computation phase, we need to define the notion of computations in \(C^*\).
							</p>
							<span class="rp_definition_header" id="def6.1">Definition 6.1</span>
							<p class="rp_original rp_definition">
								By a <i>computation \(\Gamma^*\) in \(C^*\)</i>, we mean a selection of exactly one row in each \(n\)-transform in \(C^*\).
							</p>
							<p class="rp_original rp_definition">
								A computation \(\Gamma^*\) is said to be <i>consistent</i>, if the following is satisfied: Suppose output column \(k_1\) in the transform \(T^*_1\) is connected with column \(k_2\) in the transform \(T_2^*\), and let \(\Gamma^*(k_1)\) and \(\Gamma^*(k_2)\) be the entries selected by \(\Gamma^*\) in the two columns then $$\Gamma^*(k_1)\oplus rsum(l_1,T_1)\;=\;\Gamma^*(k_2),$$ where \(l_1\) is the index of the row selected by \(\Gamma^*\) in \(T_1^*\).
							</p>
							<p class="rp_original">
								The intuition behind these rather technical looking definitions is very simple: if we assume that all transforms in \(C^*\) are valid, then the selection of a row in a table \(T^*\) corresponds to selecting a row in the original truth table, under the product of all row permutations chosen for \(T^*\) by the participants. Therefore, a computation in \(C^*\) corresponds to a computation in \(C\). Moreover the consistency condition on a computation in \(C^*\) just says that if we look at the string of bits selected in the computation and "remove" all layers of encryption, then the consistency condition as defined in <a href="#sec5">Section 5</a> holds for the computations in \(C\) (note that by construction of the \(n\)-transforms in \(C^*,\,csum(k_1,T_1^*)=csum(k_2,T_2^*)\)). Formally, we have the following:
							</p>
							<p class="rp_original">
								Given an \(n\)-transform \(T^*\) in \(C^*\), let \(\sigma_i\) be the row permutation chosen by participant \(P_i\) for \(T^*\). If \(\Gamma^*\) is a computation in \(C^*\) selecting row \(l\) in \(T^*\), then we define <i>the corresponding computation</i> \(\Gamma\) in \(C\) by selecting row \((\sigma_n\cdots\sigma_1)^{-1}(l)\) in the original truth table.
							</p>
							<span class="rp_theorem_header" id="lemma6.2">Lemma 6.2</span>
							<p class="rp_original rp_theorem">
								Let \(\Gamma^*\) be a computation in \(C^*\) and suppose all transforms in \(C^*\) are valid. Then the corresponding computation \(\Gamma\) in \(C\) is consistent if and only if \(\Gamma^*\) is consistent.
							</p>
							<p class="rp_original">
								The rest of the protocol is now just an algorithm which constructs a consistent computation in \(C^*\) from the input as specified above.
							</p>
							<section id="protocol3">
								<h4>Procedure <span class="main_language">Construct Computation</span></h4>
								<p class="rp_original rp_sub">
									<i>Input: The fully encrypted circuit \(C^*\) and, for each input wire \(w\), an attached input bit \(b_w\) specified as above. Output: a consistent computation \(\Gamma^*\) in \(C^*\) and its output.</i>
								</p>
								<ol class="rp_original">
									<li>Mark every input wire.</li>
									<li>
										<p>For every gate \(G\) for which all input wires are marked, do the following:</p>
										<p>Let \(T^*\) be the \(n\)-transform in \(C^*\) of \(T(G)\). Let \(l\) be the index of the row in \(T^*\), whose first entries match the bits attached to the input wires of \(G\), and let \(b_l\) be the last entry in this row.
										</p><p>
											Record row number \(l\) as selected by \(\Gamma^*\). Open all bit commitments in \(rlist(l,T^*)\), and put $$b_l^*=b_l\oplus rsum(l,T^*).$$
										</p>
									</li>
									<li>For every wire \(w\) connecting out of \(G\), mark \(w\) and attach to it $$b_w=b_l^*.$$</li>
									<li>If any wires in \(C\) are still unmarked, go to Step 2.</li>
									<li><p>
										For every output wire \(w\), do the following:
									</p><p>
										suppose \(w\) corresponds to output column \(k\) in \(T^*\). Then open all commitments in \(clist(k,T^*)\), and compute the final result for this wire as: $$\operatorname{Result}(w)=b_w\oplus csum(k,T^*).$$
									</p></li>
								</ol>
								<p class="rp_original">
									The reader can easily verify that if all participants supply the information needed in step 2, then the procedure runs in time linear in the number of gates in \(C\), and constructs a consistent computation \(\Gamma^*\). Furthermore, it is easy to see that step 5 above in fact produces the output of the computation in \(C\) corresponding to \(\Gamma^*\).
								</p>
								<p class="rp_annotation">
									<i>This</i> procedure is linear; the encryption stage is not, and is the bulk of a calculation's runtime.
								</p>
							</section>
						</section>
						<section id="sec6.3">
							<h3>6.3. Proofs of Correctness and Security</h3>
							<p class="rp_original">
								Before starting on this section, the reader is well advised to review the definitions of correctness and security given in <a href="#sec4.1">Section 4.1</a>.
							</p>
							<p class="rp_original">
								Using the results proved in preceding sections, it is now not hard to prove:
							</p>
							<span class="rp_theorem_header" id="theorem6.3">Theorem 6.3</span>
							<p class="rp_original rp_theorem">
								The protocol is correct, as defined in <a href="#def4.1">definition 4.1</a>.
							</p>
							<span class="rp_sub_header">Proof</span>
							<p class="rp_original rp_sub">
								First note that for each input wire \(w\) in <span class="equation" data-equation="ra">\(R\)</span>, the input bit given to \(C\) is the XOR sum of one bit chosen by the mutually trusted random source, and one bit chosen by each participant (namely the bit committed to in the \(clist\) corresponding to \(w\)). By <a href="#lemma6.2">Lemma 6.2</a>, this means that the conditional probability distribution of the output of the protocol assuming that no cheating has occurred, is exactly equal to the "right" probability distribution \(OP_C^I\), for any choice \(I\) of inputs. The theorem now follows from <a href="#theorem6.1">Theorem 6.1</a> and elementary probability theory.
							</p>
							<p class="rp_original">
								To show that the protocol is secure, we assume the existence of some conspiracy <span class="equation" data-equation="X">\(X\)</span>. We must then exhibit a simulator \(M_X\) for <span class="equation" data-equation="X">\(X\)</span> and prove that its output is polynomially indistinguishable from an actual proof conversation. Only informal descriptions will be given, we trust that this will make the proofs easier to understand, and that the reader will have no trouble in filling in the necessary details.
							</p>
							<p class="rp_original">
								We begin with the description of the simulator \(M_X\):
							</p>
							<p class="rp_original">
								Recall that \(M_X\) is given as input the security parameter value \(m\), the output of a "real" computation <span class="equation" data-equation="fC">\(f_C(ip_1,\dots,ip_n,ra)\)</span>, and the part of the input "known" to <span class="equation" data-equation="X">\(X\)</span> \(\{\)<span class="equation" data-equation="ip">\(ip_i\)</span>\(|\,P_i\in\)<span class="equation" data-equation="X">\(X\)</span>\(\}\). In addition to this, \(M_X\) is of course allowed to use the machines in <span class="equation" data-equation="X">\(X\)</span> in any (feasible) way it likes. We will describe the algorithm of \(M_X\) as a simulated protocol execution, where the participants in <span class="equation" data-equation="X">\(X\)</span> act "as themselves" and \(M_X\) plays the parts of all other participants.
							</p>
							<p class="rp_original">
								\(M_X\) starts by putting <span class="equation" data-equation="ip">\(ip_i\)</span> on the input tape of \(P_i\) for every \(P_i\in\)<span class="equation" data-equation="X">\(X\)</span>. Also, the random tapes of all machines in <span class="equation" data-equation="X">\(X\)</span> are filled in using \(M_X\)'s own random tape. This means that all the machines in <span class="equation" data-equation="X">\(X\)</span> are deterministic from now on.
							</p>
							<p class="rp_original">
								For simplicity, we assume that all participants use QRS for bit commitments. \(M_X\) therefore chooses a modulus \(N_i\) for all participants \(P_i\) not in the conspiracy, while the participants in <span class="equation" data-equation="X">\(X\)</span> choose their own moduli. Although this means that \(M_X\) in fact knows some of the factorizations involved, it is of course essential that this is not used in the simulation!
							</p>
							<p class="rp_original">
								Next, \(M_X\) executes a simulation of the proof that \(N_i\) is a Blum integer, for every \(i=1\cdots n\). When \(i\) is such that \(P_i\in\)<span class="equation" data-equation="X">\(X\)</span>, \(P_i\) can be used directly as the prover, otherwise the simulation from <span class="reference" data-citation="PG">[?]</span> can be used.
							</p>
							<p class="rp_original">
								We now come to the executions of the <span class="main_language">Transform Circuit</span> procedure. If \(P_i\in\)<span class="equation" data-equation="X">\(X\)</span>, then the \(i\)-th iteration of this procedure is replaced by an execution of the procedure <span class="main_language">Simulate Conspiracy</span> below, otherwise the procedure <span class="main_language">Simulate Honest Participant</span> is used.
							</p>
							<section id="protocol4">
								<h4>Procedure <span class="main_language">Simulate Honest Participant</span>.</h4>
								<p class="rp_original rp_sub">
									<i>Input: one \((i-1)\)-transform of every truth table in \(C\). Output: one \((i-1)\)-transform of every truth table in \(C\).</i>
								</p>
								<ol class="rp_original" type="i">
									<li>For every \((i-1)\)-transform \(S\) supplied in the input, which does not correspond to an output gate, \(M_X\) creates an \(i\)-transform \(T\) exactly according to the protocol.</li>
									<li>
										For every \((i-1)\)-transform \(S\) corresponding to an output gate, an \(i\)-transform \(T\) is created in exactly the same way as in step i. In addition to this, the following is done:
										<p>
											Recall that for each output gate \(G\) of \(C\), a bit \(b_G\) is specified in the input to \(M_X\), as part of the given value of <span class="equation" data-equation="fC">\(f_C(ip_1,\dots,ip_n,ra)\)</span>. The simulated computation must produce this bit as output from \(G\). This is ensured by simply multiplying the commitment from \(P_i\) in some of the row lists by -1, so that the last column of \(T\) becomes an encryption of a column with all entries equal to \(b_G\).
										</p><p>
											Note that the above modification only has to be done once, even if the simulation is done with more than one honest participant.
										</p>
									</li>
									<li>To simulate the <span class="main_language">Check Transformation</span> protocol, \(M_X\) chooses \(b_M\in\{0,1\}\) at random. If \(b_M=1\), a set of \(T'\)'s is created as valid transforms from the \(S\)'s, otherwise, the \(T'\)'s are created from the \(T\)'s as randomly chosen \(i\)-transforms such that step 4 in the <span class="main_language">Check Transformation</span> protocol can be executed.</li>
									<li>The trusted source outputs a bit \(b\). If \(b=b_M,\,M_X\) just executes step 3 in the <span class="main_language">Check Transformation</span> protocol if \(b=1\), and step 4 if \(b=0\). This is possible by construction of \(T'\). Otherwise, \(M_X\) rewinds all machines in \(X\) to their configuration just after the last execution of step ii. We then go back to step iii and try again with a new independent choice of \(b_M\) and \(T'\).</li>
								</ol>
								<p class="rp_original">
									Steps iii and iv are repeated until step iv has been successful \(m\) times.
								</p>
								<p class="rp_original">
									Note that the expected number of "trial \(T'\)'s", we must create in the above procedure before \(b\) happens to be equal to \(b_M\) is constant, and that the above procedure therefore takes expected linear time in \(m\).
								</p>
							</section>
							<section id="protocol5">
								<h4>Procedure <span class="main_language">Simulate Conspiracy</span>.</h4>
								<p class="rp_original rp_sub">
									<i>Input: one \((i-1)\)-transform of every truth table in \(C\). Output: one \(i\)-transform of every truth table in \(C\).</i>
								</p>
								<ol class="rp_original" type="i">
									<li>\(M_X\) uses \(P_i\) to compute an \(i\)-transform \(T\) of every \((i-1)\)-transform \(S\) in the input.</li>
									<li>The first round of the <span class="main_language">Check Transformation</span> protocol is executed as follows: step 1 is executed only once, but steps 2-4 are executed several times, rewinding \(P_i\) after each iteration. This goes on until \(P_i\) has shown <i>both</i> that \(T\) is equivalent to \(T'\), and that \(T'\) was correctly constructed. If either proof is not valid, the simulator stops.
									<p>The reader can easily verify that having seen both proofs, \(M_X\) can find out exactly how \(T\) was constructed from \(S\). In particular, all the blinding factors used by \(P_i\) can be found. This means that \(M_X\) can now open all bit commitments used so far in the simulation, without making further use of the machines in the conspiracy.</p>
									</li>
									<li>The rest of the rounds in the <span class="main_language">Check Transformation</span> protocol are executed exactly as in an actual protocol execution.</li>
								</ol>
								<p class="rp_original">
									Once again, it is easy to see that the above procedure takes expected polynomial time.
								</p>
							</section>
							<p class="rp_original">
								In the computation phase, \(M_X\) lets all machines in <span class="equation" data-equation="X">\(X\)</span> specify their encrypted choice of input bits, and specifies randomly chosen bits for all other participants. It is now easy to see that the <span class="main_language">Construct Computation</span> procedure can be executed exactly as in the protocol: by the remarks in the <span class="main_language">Simulate Conspiracy</span> procedure, \(M_X\) has all the information it needs to open all bit commitments from participants not in <span class="equation" data-equation="X">\(X\)</span>.
							</p>
							<p class="rp_original">
								Why does this simulation look just like a "real" protocol conversation? Consider the set of messages sent by participant \(P_i\) in the protocol, and suppose \(P_i\) is honest. It is easy to see that the bits shown "in clear" in the messages will be distributed in exactly the same way in the simulation as in an actual protocol conversation. The difference between simulation and protocol therefore lies only in the distribution of the bits hidden in \(P_i\)'s bit commitments. It is intuitively clear that to notice this difference, a distinguisher would need the ability to tell the difference between commitments containing 0's and those containing 1's. But by assumption, this cannot be done efficiently. This argument is formalized below.
							</p>
							<span class="rp_theorem_header" id="theorem6.4">Theorem 6.4.</span>
							<p class="rp_original rp_theorem">
								The protocol is secure.
							</p>
							<span class="rp_sub_header">Proof</span>
							<p class="rp_original rp_sub">
								It remains to be shown that the output of the simulator described above is polynomially indistinguishable from an actual protocol conversation. For simplicity, we will only do this in the case where \(n-1\) participants conspire against one honest participant \(P_i\). Cases with smaller conspiracies are in principle similar and introduce only technical differences.
							</p>
							<p class="rp_original rp_sub">
								Recall that a polynomial time distinguisher \(\Delta\) is a probabilistic polynomial time algorithm which takes as input a binary string and gives a one bit output. Let \(p_{prot}(m)\) be the probability that \(\Delta\) outputs a 1 when given an actual protocol conversation with security parameter \(m\) as input. Similarly, \(p_{sim}(m)\) is the probability that \(\Delta\) outputs a 1 when given a simulated conversation created as above. By way of contradiction, we assume that there exists a choice of inputs (<span class="equation" data-equation="ip">\(ip_1,\dots,ip_n\)</span>,<span class="equation" data-equation="ra">ra</span>) which will result in distinguishable protocol and simulated conversations, i.e. there exists a constant \(c\), such that $$\left|p_{prot}(m)-p_{sim}(m)\right|\;\gt\;m^{-c}$$ for infinitely many \(m\).
							</p>
							<p class="rp_original rp_sub">
								Below, we will derive a contradiction with the <a href="#assumptions">quadratic residuosity assumption</a> by showing how to use \(\Delta\) to construct an algorithm that will distinguish <span class="definable" data-define="quadratic residue">quadratic residues</span> from nonresidues modulo a <span class="definable">Blum integer</span> \(N\), whenever \(N\) has \(m\)-bit prime factors, and \(m\) satisfies the above equation. Let us therefore assume that we are given an element \(x\) in \(Z_N^*\) of <span class="definable">Jacobi symbol</span> 1.
							</p>
							<p class="rp_original rp_sub">
								Below, we will describe a polynomial time <span class="definable">Turing machine</span> \(M_X'\), which on input (<span class="equation" data-equation="ip">\(ip_1,\dots,ip_n\)</span>,<span class="equation" data-equation="ra">ra</span>) and \(x\) chosen as above will generate a conversation. This conversation will be a "real" protocol conversation if \(x\) is a quadratic residue, and it will be distributed exactly as a simulated one if \(x\) is a quadratic nonresidue.
							</p>
							<p class="rp_original rp_sub">
								The description of \(M_X'\) is easy, based on the algorithm of \(M_X:\,M_X'\) assigns \(N\) as modulus to \(P_i\), and then works exactly as \(M_X\), except for steps i and ii in the <a href="#protocol4"><span class="main_language">Simulate Honest Participant</span></a> procedure. In step i, \(M_X'\) will: for each commitment placed by \(P_i\) in an input column list choose a bit \(b\) at random and multiply the commitment by \(x^b\). To see why this is done, observe that in a real protocol conversation the bits used in the (encrypted) computation and the bits contained in column lists are correlated: they always XOR together to the bits used in the unencrypted computation. If \(x\) is a quadratic nonresidue, this correlation is destroyed by the multiplications by \(x\), corresponding to the fact that we should be producing a simulated conversation in this case. The resulting transformation, however, is no longer valid. Since both simulation and protocol conversations produce valid transforms for non-output gates, we have to do something about this. But it is not hard to see that the correctness of the transform can be ensured by also multiplying appropriately chosen commitments in row lists and output column list by \(x\). Note that \(M_X'\) will know how to do this, since it knows exactly how every transform was computed. Finally in step ii, the multiplications by -1 are replaced by multiplications by \(x\).
							</p>
							<p class="rp_original rp_sub">
								In the computation phase, \(M_X'\) specifies inputs for \(P_i\) according to the protocol, i.e. as if the \(x\)'s had not been multiplied in. The reader may have observed that a problem could arise here: to complete this phase, \(M_X'\) must be able to open some of the commitments from \(P_i\) placed in row lists. But this is of course impossible if the commitment has been multiplied by \(x\). Note, however, that since all inputs are known to \(M_X'\), it is known which rows will be used in the computation in \(C\), and therefore it can be predicted which rows will be used in the encrypted computation. This, together with the observation that the necessary adjustments can always be done while leaving at least one row untouched, solves the problem.
							</p>
							<p class="rp_original rp_sub">
								Now observe that, if \(x\) is a quadratic residue, multiplying a commitment by \(x\) does not change the bit contained in the commitment, while if \(x\) is a quadratic nonresidue, the bit is complemented. Using this fact, it is straightforward to check that the claim above about the output of \(M_X'\) holds.
							</p>
							<p class="rp_original rp_sub">
								Let \(p_{prot}(m\,|\,N)\) be the probability that \(\Delta\) outputs a 1 when given as input a protocol conversation in which \(P_i\) chooses \(N\) as modulus. \(p_{sim}(m\,|\,N)\) is defined similarly. An easy calculation will show that the equation above implies $$\left|p_{prot}(m\,|\,N)\;-\;p_{sim}(m\,|\,N)\right|\;\gt\;m^{-c+1}$$ for infinitely many \(m\) and for more than a <span class="definable">negligible</span> (i.e. polynomial) fraction of the possible choices of \(N\). Elementary probability theory now shows that if \(x\) is a randomly chosen element in \(\mathbb{Z}_N^*\) of Jacobi symbol 1, then we can guess whether \(x\) is a quadratic residue with an advantage polynomially larger than &frac12;, whenever this derived equation holds. But this contradicts the hiding property of QRS, i.e. the intractability assumption on the quadratic residuosity problem.
							</p>
							<span class="rp_theorem_header" id="theorem6.5">Theorem 6.5.</span>
							<p class="rp_original rp_theorem">
								If \(P_n\) is honest and uses DLS for bit <span class="definable" data-define="commitment">commitments</span>, then the protocol releases no information in the Shannon sense about the private input of \(P_n\) and all intermediate results in the computation.
							</p>
							<span class="rp_sub_header">Proof.</span>
							<p class="rp_original rp_sub">
								Since DLS hides the bits unconditionally, it is easy to see that the protocol provides even a conspiracy consisting of all other participants with nothing more than the string of input bits and intermediate results, encrypted under a true one-time pad.
							</p>
							<p class="rp_original">
								A similar result holds if \(P_n\) uses JSS, <i>assuming</i> that the moduli used are of the right form. Since the known interactive proofs of this would leave a small probability that this is not so, \(P_n\) would on the average be releasing an exponentially small amount of information when using JSS.
							</p>
						</section>
					</section>
					<section id="sec7">
						<h2>7. Generalizations</h2>
						<p class="rp_original">
							In this section, we will show how to adopt the protocol to various additional requirements. It will be shown that a very flexible functionality can be obtained from a general computation protocol, as long as it protects the private inputs, computes correct results, and allows execution of <i>coordinated</i> instances, i.e. participants can prove relations between inputs and outputs used in different instances of the protocol. In particular, a protocol which implements the "input-secure computation"-primitive as defined in <span class="reference" data-citation="GHY">[?]</span> and allows coordinated instances can in fact implement all four "primitives for cryptographic computation" defined in <span class="reference" data-citation="GHY">[?]</span>. From the comparability property of the bit <span class="definable">commitment</span> schemes used, it is clear that our basic protocol satisfies these requirements.
						</p>
						<section id="sec7.1">
							<h3>7.1. Private Outputs</h3>
							<p class="rp_original">
								How can we make some of the output bits private to a participant \(P_i\)? First, note that this problem could always be solved by rewriting the circuit, such that each of the output bits in question were XORed with a bit chosen at random by the participant.
							</p>
							<p class="rp_original">
								With out protocol, however, this is not needed: we can just modify the protocol such that \(P_i\) is not required to open his or her bit commitments corresponding to the output wires in question. The proof of security could easily be modified to take this into account: just note that if some output bits are private to a participant not belonging to a conspiracy, then the simulation can be done without knowing these bits.
							</p>
							<p class="rp_annotation">
								This is important because, since the conspiracy does not learn those secret outputs, they cannot use the bits of those outputs in their protocol. As mentioned, they don't need them.
							</p>
						</section>
						<section id="sec7.2">
							<h3>7.2. Simultaneous Release of the Output</h3>
							<p class="rp_original">
								An obvious strategy for a set of dishonest participants would be to try stopping the protocol early in such a way that this conspiracy could find out about the output while preventing honest participants from getting it. To solve this problem in general, one could just execute a set of coordinated instances, such that the input was constant over all rounds, while the circuit was rewritten such that exactly one bit of the result was computed in each instance.
							</p>
							<p class="rp_original">
								Note, however, that our basic protocol already implements a bit by bit release, since the "encryptions" of the output columns are opened for one column at a time. Thus, each participant will never have more than a one bit advantage over any other participant. Also this statement could be incorporated into the formal security proof: loosely speaking, if the protocol stops without computing the complete result, then the simulation can be done without knowing all output bits.
							</p>
							<p class="rp_original">
								If simultaneous release is to be combined with private outputs, however, then a bit by bit release does not make sense because the private outputs may have different lengths. We propose instead the following solution, the basic idea of which was first introduced by Yao in <span class="reference" data-citation="Y1">[?]</span>: The parties agree on a probabilistic circuit, which will produce as output an instance of a bit commitment scheme based on a trapdoor one-way function, e.g. an instance of QRS, together with the trapdoor information. Our basic protocol can now be used to do a computation in this circuit. The parties open the specification of the instance, such that commitments can be computed, but keep the trapdoor closed. In the case of QRS, this would mean that a public modulus has been computed, but its factorization is still unknown to everyone. Since all coin flips in the computation are secret, no participant can compute the trapdoor information by himself. The parties now go back to the original circuit and do the computation, using the bit commitment instance computed above for all commitments in output column lists. When this is done, the trapdoor information is opened, bit by bit, which is possible by above remarks. Using Yao's terminology, this is a <i>fair</i> protocol because all participants need exactly the same information in order to get their share of the output.
							</p>
						</section>
						<section id="sec7.3">
							<h3>7.3. Other Special Requirements</h3>
							<p class="rp_original">
								Since our basic protocol protects not only the inputs, but also all intermediate results, a variety of special properties can be obtained by rewriting the circuit. For example, the result could be distributed only to a secret subset of users, the subset being chosen at random or based on the result. Also, a secret permutation could be applied to the private output of some participant to hide the order in which that participant obtains his or her output bits. This could be important, e.g. in the implementation of a game such a poker.
							</p>
						</section>
						<section id="sec7.4">
							<h3>7.4. Verifiability</h3>
							<p class="rp_original">
								Is it possible for a non-participant to check from, say, a recording of all messages sent in the protocol that the result computed is a correct one? It is clear that such a check cannot be possible without interacting with the participants, since otherwise the protocol could not be minimum knowledge with respect to the private inputs: recall that there should be no way for anyone to tell whether he is presented with a genuine protocol conversation or a simulated one. But this is exactly what we would be asking the non-participant above to do!
							</p>
							<p class="rp_original">
								<i>With</i> interaction, however, checking is easy: all participants could be asked to prove once again using the <span class="main_language">Check Transformation</span> protocol that they had computed valid transforms. Then all the computation phase could be checked without interaction.
							</p>
						</section>
						<section id="sec7.5">
							<h3>7.5. Fault Recovery</h3>
							<p class="rp_original">
								In our basic construction, there is not much one can do short of stopping the protocol if some participant sends incorrect messages or just stops completely. In the recent literature, a number of techniques have been proposed for recovering for such situations.
							</p>
							<p class="rp_original">
								Under the assumption that the majority of users are honest, <span class="reference" data-citation="GMW">[?]</span> propose to verifiably secret share the secret inputs of all participants. In the event of a fault, a majority of users would recover all the secrets of the participant who stopped, and complete the computation. Thus, it is assumed by definition that all honest participants will always send the messages they are supposed to. This hardly seems a realistic assumption, however: in practice, almost all faults may occur by accident, or even worse, as a result of dishonest participants sabotaging honest ones to reveal their secrets!
							</p>
							<p class="rp_original">
								Galil, Haber, and Yung<sup class="reference" data-citation="GHY">[?]</sup> propose instead a secret sharing in two levels: first, for each secret bit of a user, the user distributes one "XOR share" to each of the other participants, where the exclusive-or of these XOR shares is the original secret bit. The XOR shares are then verifiably secret shared. Recovery in now possible by reconstructing the XOR shares held by the stopped participant, which has the effect of preserving that participant's privacy.
							</p>
							<p class="rp_original">
								Our protocol could easily be adapted to include the procedure of <span class="reference" data-citation="GHY">[?]</span>: In case QRS is used, participant \(P_i\) would first commit to \(ip_i\), and then distribute XOR shares of the factorization of his or her modulus to the other participants. If \(P_i\) stops working, any majority of users could reconstruct the XOR shares of the factorization of \(P_i\)'s modulus, and use instances of our basic protocol to simulate \(P_i\): open his commitments as needed, etc.
							</p>
							<p class="rp_original">
								In addition to this, the techniques presented in <span class="reference" data-citation="Ch2">[?]</span> can be used to add flexibility to the protocol. Here, it is shown how to change the <i>quorum</i>, i.e. the number of participants necessary to reconstruct the secret, during the protocol. This can be useful in applications, where it can be assumed that almost all faults occur by accident, because of breakdown of communication lines, etc. In this case, it may be desirable to keep the ratio between the quorum and the number of remaining participants constant.
							</p>
						</section>
						<section id="sec7.6">
							<h3>7.6. The Possibility of Further Generalizations</h3>
							<p class="rp_original">
								From an intuitive point of view, it may seem unnatural that only one participant can be unconditionally protected. Why not try to devise a protocol where any subset of the participants could have this option?
							</p>
							<p class="rp_original">
								To understand this question better, consider the All-or-nothing-disclosure problem (ANDOS).
							</p>
							<p class="rp_annotation">
								Also known as one-of-\(n\) oblivious transfer
							</p>
							<p class="rp_original">
								In this problem, party A(lice) possesses a number of secrets, of which she is willing to disclose exactly one to B(ob). B would like to be able to choose which secret to get, without disclosing to A which secret he is interested in.
							</p>
							<p class="rp_original">
								Clearly, ANDOS is just a special case of the general computation problem. Furthermore, the folklore of the subject has it that for fundamental information theoretical reasons, a two party ANDOS cannot be implemented such that the secrets of both parties are unconditionally protected. Informally, this is so since, if A is unconditionally protected, the messages she sends must contain enough Shannon information to determine exactly one of her secrets. But this must then be the secret B learns, which means that he is anything but unconditionally protected!
							</p>
							<p class="rp_original">
								Although we do not yet have a formal proof that this last claim is true, it certainly seems that there is little hope of achieving the generalization described above.
							</p>
							<p class="rp_original">
								Under different assumptions, however, it <i>is</i> possible to get unconditional security for all participants. In <span class="reference" data-citation="CDC">[?]</span>, it is shown how to do this using no cryptographic assumptions, in a model where there exists an unconditionally secure secrecy channel between every pair of participants, and where at least two thirds of the participants will follow the protocol.
							</p>
							<p class="rp_original">
								On the positive side, it should be noted that in joint work with Claude Cr&eacute;peau, we have recently shown that our basic protocol can be made to work, based only on the assumption that a one way function exists, and that there is a protocol solving the ANDOS problem: Clearly, bit commitments are possible if one way functions exist, and the comparability property can always be satisfied using the fact that all NP-statements can be proved in zero knowledge (although using very inefficient protocols). The idea is now to use a protocol for ANDOS to get something which will replace the blinding property: Notice that when participant \(P_i\) blinds other participants' commitments, the basic fact used in the protocol is that \(P_i\) knows the XOR sum of the bit contained in the original commitment, and the one contained in the blinded version. It will therefore be sufficient if that participant can learn a set of these XOR relations by doing an ANDOS protocol with each \(P_j\) with \(j\lt i\). 
							</p>
							<p class="rp_original">
								The fact that ANDOS can be based on the existence of a trapdoor one way function<sup class="reference" data-citation="Cr">[?]</sup> then implies that our protocol can also be based only on a trapdoor one way function. The resulting protocol would have the same property as the one of <span class="reference" data-citation="GHY">[?]</span> which is based on the same assumption, namely that only one trapdoor function would have to be generated for each participant, while the solution in <span class="reference" data-citation="GMW">[?]</span> requires generation of \(O(n^2)\) functions.
							</p>
						</section>
					</section>
					<section id="sec8">
						<h2>8. Proving all IP-statements in Zero Knowledge</h2>
						<p class="rp_original">
							Below, we will informally describe how to use our protocol to construct a zero knowledge proof system for any language \(L\) in IP. By definition of IP, we may assume that we have a proof system for \(L\), i.e. a polynomial time Turing machine \(V\) (the verifier), a Turing machine \(P\) with unlimited power (the prover), and an interactive protocol that can be executed by \(P\) and \(V\). The protocol has the property that given a binary string \(x\in L\), the verifier will accept \(x\) at the end of the protocol with overwhelming probability, while if \(x\) is not in \(L,\,x\) will be rejected with overwhelming probability, even if the prover does not follow the protocol.
						</p>
						<p class="rp_original">
							In each round of the protocol, one of the machines receives a message, does some (probabilistic computation), and outputs another message. One can think of these computations as being described by boolean circuits&mdash;in particular the circuits describing the verifiers computations can be at most of polynomial size.
						</p>
						<p class="rp_original">
							The idea is now to use our computation protocol on each of the circuits specifying the verifier's computations. More specifically, the following is done:
						</p>
						<p class="rp_original">
							At each point where the prover is about to send a message in the original protocol, it will instead send a collection of bit commitments containing the bits of this message. The parties will now use our computation protocol on the circuit specified by the original proof system to be used by the verifier at this point. This circuit may take as input any message sent so far, but also some secret input coin flips, for example, from the verifier. The comparability property of the bit commitment schemes will ensure that the same set of messages and input is used consistently throughout. The computation protocol will be executed so that the output of the circuit, i.e. the verifiers next message in the original proof system, is private to the prover, by techniques introduces in the previous section. The prover is now free to read this message and compute a response, perhaps even using its infinite computing power.
						</p>
						<p class="rp_original">
							The last circuit processed is the one doing the computation that the verifier should use in deciding whether or not to accept the proof in the original proof system. The output of this circuit is opened to the verifier, who can check that indeed it is "accept".
						</p>
						<p class="rp_original">
							It is now easy to see that, because the computation protocol is correct, the verifier can be convinced that it would have accepted, had it done the original protocol with the prover. Note, however, that this makes essential use of the fact that one party&mdash;in this case the verifier&mdash;can be unconditionally protected. This means that, even using its infinite computing power, the prover will not learn anything about the secrets of the verifier and is therefore in essentially the same position as in the original proof system.
						</p>
						<p class="rp_original">
							On the other hand, since the computation protocol is also secure with respect to the secrets of the prover, this new proof system is zero knowledge: the verifier learns nothing except the fact that \(x\in L\); everything else is hidden in bit commitments, which are computationally as good as nothing.
						</p>
						<p class="rp_original">
							All of this can be summarized in the following:
						</p>
						<span class="rp_theorem_header" id="theorem8.1">Theorem 8.1</span>
						<p class="rp_original rp_theorem">
							Assume that pairs of <span class="definable">clawfree</span> trapdoor functions exist. Then any language in IP has a zero knowledge proof system.
						</p>
						<span class="rp_sub_header">Proof</span>
						<p class="rp_original rp_sub">
							The existence of <span class="definable" data-define="trapdoor function">trapdoor one way functions</span> will make our basic computation protocol work with conditional security, which is what we need for the prover. The clawfreeness implies that the existence of a bit <span class="definable">commitment</span> scheme hiding the bits unconditionally<sup class="reference" data-citation="C">[?]</sup>, which means that the verifier can be protected as required above.
						</p>
					</section>
					<section id="sec9">
						<h2>9. Acknowledgements</h2>
						<p class="rp_original">
							We would like to thank Gilles Brassard and Claude Cr&eacute;peau for may stimulating discussions.
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color8" id="references">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="Y1">Andrew Chi-Chih Yao. <a href="24.html">How to generate and exchange secrets (extended abstract)</a>. In <i>27th Annual Symposium on Foundations of Computer Science</i>, pages 162–167, Toronto, Ontario, Canada, 27–29 October 1986. IEEE.</li>
					<li id="GMW">Oded Goldreich, Silvio Micali, and Avi Wigderson. <a href="81.html">How to play any mental game or a completeness theorem for protocols with honest majority.</a> In <i>Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing</i>, pages 218–229, New York City, 25–27 May 1987.</li>
					<li id="GHY">Galil, Haber, and Yung: Primitives for Designing Multi-Party Cryptographic Protocols from Specifications. To appear.</li>
					<li id="Y2">A.C. Yao. <a href="49.html">Protocols for secure computations (extended abstract).</a> In <i>Proc. of the 23rd Annu. IEEE Symp. on Foundations of Computer Science.</i> pages 160-164. 1982.</li>
					<li id="GV">Goldreich and Vainish: How to solve any protocol problem: an efficiency improvement. <i>Proc of Crypto</i> 87.</li>
					<li id="GMW2">Goldreich, Micali, and Wigderson: How to prove all NP-statements in zero-knowledge, and a methodology of cryptographic protocol design. <i>Proc. of Crypto</i> 86.</li>
					<li id="BC">Brassard and Cr&eacute;peau: Zero knowledge simulation of boolean circuits. <i>Proc. of Crypto</i> 86.</li>
					<li id="C">Chaum: Demonstrating that a public predicate can be satisfied while revealing no information about how. <i>Proc. of Crypto</i> 86.</li>
					<li id="GB">S. Goldwasser and M. Bellare. Lecture Notes on Cryptography. Web resource, MIT. 2008.</li>
					<li id="GM">Goldwasser and Micali: Probabilistic Encryption. <i>JCSS, vol. 28, no.2</i>, April 1984, pp.270-299.</li>
					<li id="PG">Peralta and van de Graaf: A simple an efficient protocol to prove the validity of your public key. To appear in <i>Proceedings of Crypto</i> 87.</li>
					<li id="Bl">Blum: Coinflipping by telephone: Protocols for solving impossible problems. <i>Proc. of 24. IEEE</i> CompCon, 1982.</li>
					<li id="GMR">Goldwasser, Micali, and Rackoff: The knowledge complexity of interactive proof systems. <i>Proc. 17th STOC</i>, 1985.</li>
					<li id="Ch2">Chaum: How to keep a secret alive. <i>Proc. of Crypto</i> 84.</li>
					<li id="Cr">Cr&eacute;peau: Equivalence between two flavours of oblivious transfers. To appear in proceedings of <i>Crypto</i> 87.</li>
					<li id="CDC">Chaum, Damg&aring;rd, and Cr&eacute;peau: Fundamental primitives for multiparty unconditionally secure protocols. To appear.</li>
					<li id="QRtoF">H. Delfs and H. Knebl. Quadratic Residuosity Property. <i>Introduction to Cryptography: Principles and Applications</i>, pages 162-163. Springer. 2007.</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+82@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Created by Nicolas Schank 2014, Brown University</p>
				<p>All original work is free for any use by anyone whatsoever.</p>
				<p>For more information about liability and licensing the original paper, see <a href="../liability.html">Liability</a>.</p>
            </div>
        </div>
    </body>
</html>