<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>How to Generate and Exchange Secrets - Andrew Yao, 1986</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					case "delta":
						return "The function \\(\\Delta_X(\\sigma)\\) takes in a run of a particular protocol \\(\\sigma\\) and outputs the history of that run from \\(X\\)'s point of view.";
					case "rfunction":
						return "We denote by \(r(d_n,X_n,Y_n,Q)\) the probability that a correct guess for \(d_n(x_n)\) will be produced by \(Q\) when given \(y_n\), where \((x_n,y_n)\) is distributed according to \((X_n,Y_n)\).";
					
					default:
						return "No info on this equation yet.";
				}
			}

			function authorLink(ref)
			{
				switch (ref)
				{
					default:
						return "#";
				}
			}

			self_def["polynomial ensemble"] = "A sequence of distributions \\((h_1,h_2,\\dots,h_n,\\dots)\\) is assumed to be a polynomial ensemble if there is a probabilistic <span class=\"definable\">Turing machine</span> which, on input \\(n\\), will generate in time polynomial in \\(n\\) a random string \\(x\\) with a distribution <span class=\"definable\">indistinguishable</span> computationally from \\(h_n\\).";
			//-->
        </script>
    </head>
    <body>
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth"><a id="_A"></a>
                    <div class="rp_linkbox"><a href="pdf/24.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">Paper Title</span>
                    <span class="rp_info">Year
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <a class="rp_author" href="../authors/authorpage.html">Author</a></span>
						
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a>
								<ol>
									<li><a href="#a_intro">Introduction</a></li>
									<li><a href="#a_goals">Goals and Results</a></li>
									<li><a href="#a_defs">Definitions</a></li>
									<li><a href="#a_theorems">Theorems</a></li>
									<li><a href="#a_protocols">Protocols</a></li>
									<li><a href="#a_ref">Referencing This Paper</a></li>
								</ol>
							</li>
                            <li><a href="#_B">Annotated Paper</a></li>
                        </ol>
                    </div>
					
                    <div class="rp_snippet">
						An important snippet of the paper
					</div>
						
                    <section id="a_intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Paper Title</b> is...
						</p>
					</section>
					<section id="a_goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							Some goals that they had.
						</p>
						<p class="rp_analysis">
							Don't forget some results, too!
						</p>
					</section>
					<section id="a_defs">
						<h2>Definitions</h2>
						<a href="#def1"><span class="rp_definition_header">Definition 1 - </span></a>
						<p class="rp_original rp_definition">
							A definition 
						</p>
					</section>
					<section id="a_theorems">
						<h2>Theorems</h2>
						<p class="rp_original">Some general definitions used by several theorems</p>
						<a href="#theorem1"><span class="rp_theorem_header">Theorem 1</span></a>
						<p class="rp_original rp_theorem">
							A theorem
						</p>
					</section>
					<section id="a_protocol">
						<h2>Protocols</h2>
						<h3><a href="#secxx">Some Protocol Defined</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b></li>
							<li><b>Function(s): </b></li>
							<li><b>Privacy constraints: </b></li>
							<li><b>Security constraints: </b></li>
							<li><b>Cheating: </b></li>
							<li><b>Bits exchanged: </b></li>
							<li><b>Runtime:</b></li>
						</ul>
					</section>
					<section id="a_ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							A reference for this paper
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5"><a id="_B"></a>
                <div class="main_window main_fullwidth">
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a></li>
                            <li>
                                <a href="#_B">Annotated Paper</a>
                                <ol>
                                    <li><a href="#sec1">Introduction</a></li>
                                </ol>
                            </li>
                        </ol>
                    </div>
					<section id="abstract">
						<h2>Abstract</h2>
						<p class="rp_original">
							In this paper we introduce a new tool for controlling the knowledge transfer process in cryptographic protocol design. It is applied to solve a general class of problems which include most of the two-party cryptographic problems in the literature. Specifically, we show how two parties A and B can interactively generate a random integer \(N = pq\) such that its secret, i.e., the prime factors \((p, q)\), is hidden from either party individually but is recoverable jointly if desired. This can be utilized to give a protocol for two parties with private values \(i\) and \(j\) to compute any polynomially computable functions \(f(i,j)\) and \(g(i,j)\) with minimal knowledge transfer and a strong fairness property. As a special case, A and B can exchange a pair of secrets \(s_A\), \(s_B\), e.g. the factorization of an integer and a Hamiltonian circuit in a graph, in such a way that \(s_A\) becomes computable by B when and only when \(s_B\) becomes computable by A. All these results are proved assuming only that the problem of factoring large integers is computationally intractable.
						</p>
					</section>
                    <section id="sec1">
						<h2>Introduction</h2>
                        <p class="rp_original">
							A <i>protocol</i> \(M=(M_A,M_B)\) is a pair of communicating probabilistic <span class="definable" data-define="Turing machine">Turing machines</span> each with a special "send-receive" tape. Given inputs of the form \((n,i_A)\) and \((n,i_B)\), the two machines will alternately send and receive message strings using the send-receive tapes; each machine will perform computation as a standard Turing machine after receiving a message string, including the computation of the next message to be sent. Eventually both machines half within a number of steps bounded by some polynomial in \(n\), leaving strings \(u_A\) and \(u_B\) on the output tapes. For a detailed description, see for example <a href="#citation1"><span class="reference" data-citation="1">[1]</span></a><a href="#citation2"><span class="reference" data-citation="2">[2]</span></a>; in our case we allow each machine to have their own private input tape. For any run \(\sigma\) of the protocol, let <span class="equation" data-equation="delta">\(\Delta_A(\sigma)\)</span> denote the <i>history</i> of the run from A's view, i.e. a sequence of the instantaneous descriptions of \(M_A\); similarly <span class="equation" data-equation="delta">\(\Delta_B(\sigma)\)</span> denote the history of this run from B's view.
						</p>
						<p class="rp_original">
							The class of problems we are interested in are as follows. Given inputs \((n,i_A)\) and \((n,i_B)\), where \((i_A,i_B)\) is a random pair of strings distributed according to a probability distribution \(h_n\) over \(\{0,1\}^*\times\{0,1\}^*\), we wish to design a protocol \(\mathbb(M)=(M_A,M_B)\) such that the outputs \((u_A,u_B)\) are distributed according to a certain probability distribution \(w_{n,i_A,i_B}\) over \(\{0,1\}^*\times\{0,1\}^*\). The sequence of distributions \((h_1,h_2,\dots,h_n,\dots)\) is assumed to be a <i>polynomial ensemble</i> in the sense that there is a probabilistic Turing machine which, given input \(n\), will generate in time polynomial in \(n\) a random string \(x\) with a distribution indistinguishable computationally from \(h_n\); similarly we assume that \(w_{n,i_A,i_B}\) is a polynomial ensemble in that a random sample point can be generated in time polynomial in \(n\), when the parameters \(n,i_A,i_B\) have been given. Let us call this a <i>(two-party) interactive computational problem</i> \(\langle h_n,w_n\rangle\). OF special interest is the case when the probability distribution \(w_{n,i_A,i_B}\) is nonzero only at one point, call it \((f_n(i_A,i_B),g_n(i_A,i_B))\), in which case we can regard the problem as the evaluation of a pair of functions \(f_n(i_A,i_B),g_n(i_A,i_B)\); write it as \(\langle h_n,(f_n,g_n)\rangle\).
						</p>
						<p class="rp_original">
							In addition to the <i>validity</i> requirement above, we would like the protocol to have certain <i>privacy</i> and <i>fairness</i> properties. Roughly, "privacy" means that if A behaves according to the protocol, then B will have no more information about the values of \(i_A,u_A\) than in the situation where an oracle does the computation for B and just hands B a value \(u_B\). Classical examples where privacy is the main concern include <span class="definable">oblivious transfer</span><a href="#citation3"><sup class="reference" data-citation="3">[3]</sup></a><a href="#citation4"><sup class="reference" data-citation="4">[4]</sup></a>, <span class="definable" data-define="coin flip">coin tossing</span><a href="#citation5"><sup class="reference" data-citation="5">[5]</sup></a><a href="#citation6"><sup class="reference" data-citation="6">[6]</sup></a>, mental poker<a href="#citation7"><sup class="reference" data-citation="7">[7]</sup></a><a href="#citation8"><sup class="reference" data-citation="8">[8]</sup></a>. A general study of this problem is given by Yao<a href="#citation9"><sup class="reference" data-citation="9">[9]</sup></a><a href="#citation10"><sup class="reference" data-citation="10">[10]</sup></a>. A related problem is the <i>interactive proof system</i><a href="#citation1"><sup class="reference" data-citation="1">[1]</sup></a> in which player A wishes to convince player B that a string \(\tau\) is in a certain language L. Recently, Goldreich, Micali, and Wigderson<a href="#citation11"><sup class="reference" data-citation="11">[11]</sup></a> proved that, for players, with polynomial-time computing power, an language in <span class="definable">NP</span> has a <i>minimum knowledge interactive proof</i>, assuming the existence of suitable <span class="definable" data-define="one-way function">one-way functions</span>. This latter problem is closely related to, in our formulation, the case of computing a pair of functions \(f_n(i_A,i_B),g_n(i_A,i_B)\), where \(i_A=(s,\tau), i_B=\tau, g_n(i_A,i_B)=1\) if and only if \(s\) is a short <i>proof</i> for \(t\in L\), and \(f_n(i_A,i_B)\equiv 1\).
						</p>
						<p class="rp_original">
							The "fairness" requirement means that a cheater should not be able to obtain the desired output while denying the other party to find the proper output. The problem of exchanging secrets<a href="#citation12"><sup class="reference" data-citation="12">[12]</sup></a><a href="#citation13"><sup class="reference" data-citation="13">[13]</sup></a><a href="#citation14"><sup class="reference" data-citation="14">[14]</sup></a> has this requirement as its main concern.
						</p>
						<p class="rp_original">
							In this paper, we will give a protocol for performing the computation \(\langle g_n,w_n\rangle\) which avieves validity, privacy, and fairness as stated in <a href="#theorem3">Theorem 3</a>, under the assumption that factoring large integers is computationally intractable. Many of the existing results mentioned are special cases of this theorem. A particular interesting special case (stated as <a href="#theorem2">Theorem 2</a>) is that it allows  two parties to exchange <i>secrets</i>, such as the factorization of a publicized integer or the Hamiltonian circuit of a publicized large graph, in a way that the probability of successful cheating can be made arbitrarily small. It is somewhat surprising that the two secrets being exchanged could be of very different apparent complexity, and one would have thought that it is difficult to find an equitable ratio of bits to be maintained during the process of swapping the secrets. Previously Blum<a href="#citation12"><sup class="reference" data-citation="12">[12]</sup></a> gave a protocol for exchanging prime factors based on several assumptions (see Hastad and Shamir<a href="#citation15"><sup class="reference" data-citation="15">[15]</sup></a> for discussions); Luby, Micali, and Rackoff<a href="#citation13"><sup class="reference" data-citation="13">[13]</sup></a>, and Vazirani and Vazirani<a href="#citation14"><sup class="reference" data-citation="14">[14]</sup></a> gave protocols for exchanging secrets which are one bit long.
						</p>
						<p class="rp_original">
							The proof of <a href="#theorem3">Theorem 3</a> depends on the ability of two parties to generate a random integer \(N=p\cdot q\), with its <i>secret</i> \((p,q)\) hidden from each party, but recoverable at a later time by a joint effort. This result is of independent interest, and should serve as another useful tool for cryptographic protocol design. A general form of this result is given as <a href="#theorem1">Theorem 1</a>.
						</p>
						<p class="rp_original">
							Compared with <a href="#citation9"><span class="reference" data-citation="9">[9]</span></a><a href="#citation10"><span class="reference" data-citation="10">[10]</span></a>, which deals with the same general problem, the addition of the fairness property is the new motive which leads to the present work. We should mention that all the protocols considered in this paper for solving the interactive computational problems \(\langle h_n,w_n\rangle\) will be independent of \(h_n\), as is traditional in considering cryptographic protocols. The main results (Theorems <a href="#theorem1">1</a>,<a href="#theorem2">2</a>, and <a href="#theorem3">3</a>) are all proved under the following assumption. Let \(W_n\) be the set of all integers \(N\) of the form \(p\cdot q\) where \(p\equiv q\equiv 3\bmod{4}\) are prime numbers. 
						</p>
						<span class="rp_theorem_header" id="IAF">
							The Intractability Assumption of Factoring (IAF)
						</span>
						<p class="rp_original rp_theorem">
							Let \(k&gt;0\) be any fixed number. For any polynomial time probabilistic algorithm for factoring integers, the probability of success for a random input integer from \(W_n\) is less than \(\frac{1}{n^k}\) for all large \(n\).
						</p>
                    </section>
					<section id="sec2">
						<h2>Terminology</h2>
						<p class="rp_original">
							Let \(S=(S_1,S_2,\dots)\) and \(S'=(S_1',s_2',\dots)\) be <span class="definable" data-define="polynomial ensemble">polynomial ensembles</span>, where \(S_n=(X_n,Y_n)\) and \(S_n'=(X_n',Y_n')\) each is a probability distribution over \(\{0,1\}^*\times\{0,1\}^*\). Furthermore, assume that the two ensembles \((X_1,X_2,\dots)\) and \((X_1',X_2',\dots)\) are <span class="definable">indistinguishable</span> for polynomial-time computations.
						</p>
						<p class="rp_original">
							Let \(D=(d_1,d_2,\dots)\) be a sequence of predicates \(d_n:\{0,1\}^*\rightarrow\{0,1\}\), where given \(d\) and \(n\), \(d_n(x)\) can be computed probabilistically in time polynomial in \(n\). Define a <i>guessing algorithm</i> \(Q_B\) to be a probabilistic algorithm which takes \((n,y)\) as input, where \(y\in\{0,1\}^*\), and outputs a 0 or 1 in time polynomial in \(n\).
						</p>
						<p class="rp_original">
							Consider the experiment of taking a random \((x_n,y_n)\) distributed according to \((X_n,Y_n)\). Suppose that one observes the value \(y_N\) and tries to guess what the value of \(d_n(x_n)\) is by using a guessing algorithm \(Q\); let us denote by \(r(d_n,X_n,Y_n,Q)\) the probability that a correct guess will be made. We use the notation \(o\)(poly-small) to denote any sequence \((b_1,b_2,\dots)\) that has the property \(b_n\in o(\frac{1}{n^k})\) for all fixed \(k\).
						</p>
						<p class="rp_original">
							We write \(I_n(X_n | Y_n)\leq I_n(X_n' | Y_n')\) if \(\forall D,Q \exists Q'\) such that \(r(d_n,X_n',Y_n',Q')-r(d_n,X_n,Y_n,Q)\geq o\)(poly-small).
						</p>
						<p class="rp_original">
							We write \(I_n(X_n | Y_n)\approx I_n(X_n'|Y_n')\) if \(I_n(X_n | Y_n)\leq I_n(X_n'|Y_n')\) and \(I_n(X_n'|Y_n')\leq I_n(X_n|Y_n)\).
						</p>
						<p class="rp_original">
							A <i>puzzle ensemble</i> \(P=(L,F)\) consists of a language \(L\in BPP\) and a <span class="definable" data-define="polynomial ensemble">polynomial-time ensemble</span> \(F=(F_1,F_2,\dots)\) where each \(F_n\) is a distribution over \(\{0,1\}^*\times\{0,1\}^*\); we require further than a random \((s,\tau)\) distributed according to \(F_n\) will satisfy \((n,s,\tau)\in L\) with probability 1-\(o\)(poly-small); we will call \(s\) a <i>secret</i> of the <i>text</i> \(\tau\). Let \(T_{P,n}\) denote the distribution of a random \(\tau\) taken from the second component of a random \((s,\tau)\) distributed as \(F_n\). We will call \(P\) <i>intractable</i> if, for every probabilistic polynomial-time algorithm \(S\), when given as input a pair \((s,\tau)\), where \(\tau\) is distributed according to \(T_{P,n}\), will fail with probability 1-\(o\)(poly-small) to produce an \(s\) satisfying \((n,s,\tau)\in L\).
						</p>
						<p class="rp_original">
							For example, let \(L=\{(n;p,q,N) | N=p\cdot q, p,q\) are \(n\)-bit primes\(\}\), and \(F_n\) be the uniform distribution over the set \(W_n\). Under the <a href="#IAF">Intractability of Factorization Assumption</a>, the <i>factorization puzzle ensemble</i> \(P=(L,F)\) is an intractable puzzle ensemble.
						</p>
					</section>
					<section id="sec3">
						<h2>Generating a Secret</h2>
						<p class="rp_original">
							Let \(P=(L,F)\), where \(F=(F_1,F_2,\dots,F_n,\dots)\), be an intractable puzzle ensemble. We wish to design a protocol \(M=(M_A,M_B)\) which has the following properties for any given \(n\):
						</p>
						<ol class="rp_original">
							<li>\(M\) generates implicitly a pair \((s,\tau)\) distributed according to \(F_n\)</li>
							<li>The text \(\tau\) will be found out by \(M_A\) and \(M_B\) as their outputs.</li>
							<li>The secret \(s\), while computable by A and B jointly based on the information they have at the end of the execution of the protocol, is completely hidden from each party by itself, even if one of them cheats during the execution of the protocol</li>
						</ol>
						<p class="rp_original">
							To simplify the presentation of the result, we restrict ourselves to puzzles that have unique secrets. Let us call a puzzle ensemble \(P=(L,F)\) <i>uniquely decipherable</i> if, for every \(n,\tau\), there is at most one \(s\) satisfying \((n,s,\tau)\in L\). For example, the factorization puzzle ensemble is uniquely decipherable. For a uniquely decipherable puzzle ensemble, we can write it as \(P=(\alpha,D)\), where \(\alpha=(\alpha_1,\alpha_2,\dots)\) and \(D=(D_1,D_2,\dots)\) are given by \(\alpha_n(\tau)=s\) and \(D_n=T_{P,n}\).
						</p>
						<p class="rp_original">
							Let \(P=(\alpha,D)\) be a uniquely decipherable, intractable puzzle ensemble, where \(\alpha=(\alpha_1,\alpha_2,\dots)\) and \(D=(D_1,D_2,\dots)\). Formally, we define our requirements on a protocol \(M=(M_A,M_B)\) for generating a secret for \(P\) as follows. (A or B will sometimes output \(u_A\) or \(u_B=\)CHEATING; informally we say that A or B has detected that the other party is cheating.)
						</p>
						<section id="sec3.1">
							<h3>Validity</h3>
							<p class="rp_original">
								If both A and B follow the protocol, then
							</p>
							<ol class="rp_original" type="i">
								<li>
									With probability 1-\(o\)(poly-small), \(u_A=u_B\), and their common value \(\tau\) is distributed according to a distribution indistinguishable (by polynomial-time computations) from \(D_n\);
								</li>
								<li>
									\(I_n^{(J)}(a_n(\tau)|\tau,\Delta_j)\equiv I_N^{(L)}(a_n(\tau)|\tau)\) for \(j\in \{A,B\}\), where \(J\) is the stochastic process induced by the execution of the protocol \(M=(M_A,M_B)\), and \(L\) is the stochastic process of fetching \(\tau\) according to \(D_n\).
								</li>
								<li>
									\(\exists\) a protocol \(N=(N_A,N_B)\) which, given input \((\Delta_A,\Delta_B)\), computes outputs \(v_A,v_B\), with the property that \(v_A=v_B=a_n(\tau)\) with probability 1-\(o\)(poly-small).
								</li>
							</ol>
							<p class="rp_original">
								To discuss the validity concept when one party, say B, may misbehave. Let \(d_n\) be the probability for runs in which \(v_A\neq\)CHEATING, and let \(D_n'\) be the probability distribution for \(\tau\) when restricted to such runs. If \(d_N\) is <span class="definable">negligible</span>, then A will almost always catch B cheating, and no further requirement is needed. On the other hand, if \(d_n=\Omega(\frac{1}{n^t})\) for some fixed \(t&gt;0\), then we require the following two constraints to be true:
							</p>
							<ol class="rp_original" type="i">
								<li value="4">
									\(P'=(\alpha,D')\) is a uniquely decipherable intractable puzzle ensemble, where \(D'=(D_1',D_2',\dots)\).
								</li>
								<li>
									\(I_n^{(J)}(a_n(\tau)|\tau,\Delta_B)\approx I_n^{(L)}(a_n(\tau)|\tau)\), where \(J\) is the stochastic process induced by the execution of the protocol \(M=(M_A,M_B')\), and \(L\) is the stochastic process of fetching \(\tau\) according to \(D_n'\).
								</li>
							</ol>
							<p class="rp_original">
								To develop the concept of fairness, consider the execution of protocol \(M\) and then \(N\). If A follows the protocols, we require that the probability for B to obtain \(s\) while A cannot recover \(s\) to be small.
							</p>
						</section>
						<section id="sec3.2">
							<h3>Fairness</h3>
							<ol class="rp_original" type="i">
								<li>
									[B may cheat.] Suppose protocols \(M=(M_A,M_B)\) and \(N=(N_A,N_B)\) are run with machine pairs \((M_A,M_B'),(N_A,N_B')\). There exists a polynomial-time probabilistic algorithm \(Y\) (dependent on \(M_B'\) and \(N_B'\), which takes a history pair for \(M\) and \(N\) as input, and outputs a string \(w\). We require that if A follows the protocols \(M\) and \(N\) and then runs \(Y\), the probability that \(u_A=\tau\), \(v_B=a_n(\tau)\) while \(w\neq a_n(\tau)\) is \(o\)(poly-small).
								</li>
								<li>
									[A may cheat.] (Interchange the roles of A and B in (i).)
								</li>
							</ol>
							<span class="rp_theorem_header" id="theorem1">
								Theorem 1
							</span>
							<p class="rp_original rp_theorem">
								Let \(P\) be an intractable puzzle ensemble that is uniquely decipherable. There exists a protocol \(M=(M_A,M_B)\) for generating a secret from \(P\) that achieves validity and fairness.
							</p>
						</section>
					</section>
					<section id="sec4">
						<h2>4. Exchange of Secrets</h2>
						<p class="rp_original">
							Let \(P_A=(L_A,F_A)\) and \(P_B=(L_B,F_B)\) be two intractable puzzle ensembles. Let \((s_A,\tau_A),(s_B,\tau_B)\) be random puzzles distributed according to \(F_{A,n}\) and \(F_{B,n}\); give \((n,s_A,\tau_A,\tau_B)\) as input to A and \((n,s_B,\tau_A,\tau_B)\) to B. We wish to design a protocol \(M=(M_A,M_B)\) that will enable A and B to exchange their secrets \(s_A\) and \(s_B\) so that neither will be swindled. We state the criteria for the protocol below.
						</p>
						<section id="sec4.1">
							<h3>4.1. Validity</h3>
							<p class="rp_original">
								If both parties follow the protocol, then with probability \(1-o\)(poly-small), \(u_B=s_A\) and \(u_A=s_B\).
							</p>
						</section>
						<section id="sec4.2">
							<h3>4.2. Fairness</h3>
							<ol class="rp_original" type="i">
								<li>
									[If B gets \(s_A\), then A can compute \(s_B\).]
									<p>
										If A follows the protocols and B does not (i.e., \(M_B'\neq M_B\), then for any fixed \(k\), there exists a probabilistic polynomial-time algorithm S which takes \((n,\Delta_A)\) as input and outputs a number \(v\) such that the following is true:
									</p>
									$$Pr\{(u_B=s_A)\wedge(v\neq s_B)\}=O(\frac{1}{n^k}).$$
								</li>
								<li>
									[If A gets \(s_B\), then B can compute \(s_A\).] (Interchange A and B in (i).)
								</li>
							</ol>
							<span class="rp_theorem_header" id="theorem2">
								Theorem 2
							</span>
							<p class="rp_original">
								Let \(P_A\) and \(P_B\) be any two intractable ensembles. There exists a protocol \(M=(M_A,M_B)\) for exchanging secrets between \(P_A\) and \(P_B\) that achieves validity and fairness.
							</p>
						</section>
					</section>
					<section id="sec5">
						<h2>5. General Computation</h2>
						<p class="rp_original">
							Consider an interactive computational problem \(\langle h_n,w_n\rangle\) as defined in <a href="#sec1">Section 1</a>. We will show that there exists a protocol for it that satisfies some strong privacy and fairness constraints. In this extended abstract, we restrict ourselves to the case when \(w_n\) represents a pair of functions \((f_n,g_n)\) to be evaluated, i.e. given inputs \(i_A,i_B\), A and B wish to compute \(f_n(i_A,i_B)\) and \(g_n(i_A,i_B)\). The results can be extended to the general case.
						</p>
						<p class="rp_original">
							We will consider two variants, which differ in their input-output format. Model I is the natural one, in which the inputs and outputs are as specified in the previous paragraph. However, since in general A does not have any control over the value of \(i_B\), a dishonest B can pretend that \(i_B\) is an arbitrary value \(y\). As a result, the fairness constraint can at most force B to compute the value of \(f_n(i_A,y)\) for <i>some</i> \(y\). In Model II, A will be given as input \((i_A,p_A,q_A,N_A,N_B,E_{N_B}(i_B))\) where \(N_A=p_A\cdot q_A\) is the product of two large primes, and \(N_B\) is another integer of two large prime factors used to encode B's parameter \(i_B\) as \(E_{N_B}(i_B)\); B has as input \((i_B,p_B,q_B,N_B,N_A,E_{N_A}(i_A))\). The integers \(N_A\) and \(N_B\) are generated from some distributions such that factoring these numbers are computationally intractable; \(E_N\) can be any probabilistic encryption scheme that is provably secure under the <a href="#IAF">Intractability Assumption of Factoring</a> (e.g. the ones in Alexi, Chor, Goldreich, and Schnorr<a href="#citation16"><sup class="reference" data-citation="16">[16]</sup></a> or Blum and Goldwasser<a href="#citation17"><sup class="reference" data-citation="17">[17]</sup></a>). In the output, A, B obtain \((u_A,v_A,w_A)\) and \((u_A,v_A,w_A)\). When both parties behave honestly, \(u_A=f_n(i_A,i_B), v_A=(p_A',q_A',N_A'),\) and \(w_A=(N_B', E_{N_D'}(g_n(i_A,i_B)))\), where \(N_A'\) and \(N_B'\) are integers which are the products of two large prime factors; similarly for the output of B. such formats arise quite naturally in concatenating protocols. The privacy and fairness constraints in this model are stronger than the first model.
						</p>
						<section id="sec5.1">
							<h3>5.1. Model I</h3>
							<p class="rp_original">
								We first define the constraints when both parties follow the protocol.
							</p>
							<section id="sec5.1.1">
								<h4>5.1.1. Validity</h4>
								<p class="rp_original">
									With probability 1-\(o\)(poly-small), \(u_A=f_n(i_A,i_B)\) and \(u_B=g_n(i_A,i_B)\).
								</p>
							</section>
							<section id="sec5.1.2">
								<h4>5.1.2. Privacy</h4>
								<ol class="rp_original">
									<li>
										\(I_n^{(J)}(i_A,i_B,u_A | \Delta_B,i_B,u_B)\approx I_n^{(L)}(i_A,i_B,u_A | i_B,u_B)\) where \(J\) is the <span class="definable">stochastic</span> process of running \(M\) with input from \(h\), and \(L\) is the stochastic process of having \((i_A,i_B)\) distributed according to \(h\) and \(u_A=f_n(i_A,i_B),u_B=g_n(i_A,i_B)\).
									</li>
									<li>
										(Interchange A and B in (i).)
									</li>
								</ol>
							</section>
							<p class="rp_original">
								We now define the constraints when A follows the protocol while B may cheat, that is, B executes the protocol with any \(M_B'\). Since \(M_B'\) is arbitrary, B can always generate an \(i_B'\) and acts as if this is the input value \(i_B\). As A can never detect this method of cheating, A has to cooperate and let B know the value of \(g_n(i_A,i_B')\). This enables B to control A's output \(u_A\), and to probe somewhat into the value of \(i_A\); this cannot be prevented if we want to preserve the validity condition for honest parties described above. We shall require that B cannot do more than that. Let us denote by Z the set \(\{0,1\}^*\cup\{\)CHEATING\(\}\), and extend the function \(f_n\) by \(f_n(i_A,y)=\)CHEATING if \(y=\)CHEATING.
							</p>
							<p class="rp_original">
								Let \(M_B'\) be any communicating <span class="definable">Turing machine</span>, and let \(U_n\) be the distribution corresponding to \(u_A\) when \((M_A,M_B')\) are used to carry out the protocol.
							</p>
							<section id="sec5.1.3">
								<h4>5.1.3. Validity</h4>
								<p class="rp_original">
									There exists a probabilistic polynomial-time algorithm S that takes input \((n,i_B)\) and produces a random \(y\in Z\) such that \(U_n\) is indistinguishable from the distribution corresponding to \(f_n(i_A,y)\).
								</p>
								<p class="rp_original">
									Let \(J\) be the <span class="definable">stochastic</span> process of running \((M_A,M_B')\) with input \((i_A,i_B)\) distributed according to \(h_n\). Let \(\mathbb{S}\) be the set of all probabilistic polynomial-time algorithms \(S\) that take input \((n,i_B)\) and produce random \(y\in Z\). For any \(S\in\mathbb{S}\), let \(L(S)\) be the stochastic process of generating \((i_A,i_B)\) according to \(h_n\), run \(S\) on input \((n,i_B)\) to produce a random \(y\), and define \(u_A=f_n(i_A,y),u_B=g_n(i_A,y)\). Intuitively, B may use \(S\) to generate a random \(y\), and after that, acts as if \(y\) were the value of \(i_B\), and otherwise follows the protocol; \(L(S)\) is clearly a less informative process for B in which A simply tells B the value of \(u_B=g_n(i_A,y)\) without other communications taking place.
								</p>
							</section>
							<section id="sec5.1.4">
								<h4>5.1.4. Privacy</h4>
								<p class="rp_original">
									For any \(M_B'\), there exists an \(S\in\mathbb{S}\) such that \(I_n^{(J)}(i_A,i_B,u_A|\Delta_B,i_B,u_B)\leq I_n^{(L(S))}(i_A,i_B,u_A|i_B,u_B)\).
								</p>
								<p class="rp_original">
									The fairness concept refers to obtaining the information that one is entitled to. Suppose B wishes to know the value of \(g_n(i_A,y)\) for some \(y\) other than \(i_B\). As we mentioned earlier, B can succeed by pretending \(i_B=y\) and otherwise follow the protocol; in the process A will obtain also the value of \(f_n(i_A,y)\). The privacy constraint stipulates that no information other than the value of \(g_n(i_A,y)\) is conveyed from A to B. The fairness constraint is concerned with whether it is possible for B to stop at some point, once B has the information about \(g_n(i_A,y)\), and deny the knowledge of \(f_n(i_A,y)\) to A. The following formulation is not the strongest possible version of this constraint, but it is sufficient for some applications such as exchanging secrets of sufficient length. Let \(L_n\) denote the set of all possible values of \(f_n(i_A,i_B)\) when \((i_A,i_B)\) is distributed according to \(h_n\).
								</p>
							</section>
							<span class="rp_definition_header">
								Definition X - Recovery Algorithm
							</span>
							<p class="rp_definition">
								A <i>recovery algorithm</i> \(R\) for A is a probabilistic polynomial-time algorithm which takes \((n,\Delta_A)\) as input, and outputs a string \(v\).
							</p>
							<p class="rp_original">
								Consider a pair \((i_A,i_B)\) distributed according to \(h_n\). Let \(G\) denote a probabilistic polynomial-time <span class="definable">Turing machine</span> that takes \(i_B\) as input and outputs \(z\); let \(\beta_n(G)\) denote the probability that \(z=g_n(i_A,i_B)\).
							</p>
							<section id="sec5.1.5">
								<h4>5.1.5. Fairness</h4>
								<p class="rp_original">
									For any fixed \(k\), there exists a recovery algorithm \(R\) (dependent on \(M_B'\)) whose output \(v\) satisfies the following condition:
									$$Pr\{(u_B=g_n(i_A,i_B))\wedge (v\notin L_n)\}\leq \beta_n(G)+O(\frac{1}{n^k})$$
									for some \(G\).
								</p>
								<p class="rp_original">
									To complete the definitions, we interchange the roles of A and B in the above discussions, which gives the constraints of validity, privacy, and fairness when B follows the protocol and A is cheating.
								</p>
							</section>
							<span class="rp_definition_header">
								Definition X
							</span>
							<p class="rp_definition">
								A protocol is said to achieve validity, privacy, and fairness, if all the above constraints are satisfied.
							</p>
							<span class="rp_theorem_header" id="theorem3">
								Theorem 3
							</span>
							<p class="rp_original rp_theorem">
								For any interactive computational problem \(\langle h_n,(f_n,g_n)\rangle\), there exists a protocol \(M\) that achieves validity, privacy, and fairness.
							</p>
						</section>
						<p class="rp_original">
							In Model II, the constraints are simpler. The input-output formats are as explained at the beginning of this section.
						</p>
					</section>
					<section id="sec5.2">
						<h3>5.2. Model II</h3>
						<p class="rp_original">
							When both A and B follow the protocol, the following is required.
						</p>
						<section id="sec5.2.1">
							<h4>5.2.1. Validity</h4>
							<p class="rp_original">
								With probability 1-\(o\)(poly-small), \(u_A=f_n(i_A,i_B),v_A=(p_A',q_A',N_A')\) and \(w_A=E_{N_B'}(g_n(i_A,i_B))\), where \(N_A'\) is the product of \(n\)-bit primes \(p_A'\) and \(q_A'\); the distribution of \(N_A'\) is such that it is intractable to factor. A dual constraint on B is also required.
							</p>
						</section>
						<section id="sec5.2.2">
							<h4>5.2.2. Privacy</h4>
							<ol class="rp_original" type="i">
								<li>	
									\(I_n^{(J)}(i_A,i_B,u_A|\Delta_B,i_B,u_B,v_B,w_B)\approx I_n^{(L)}(i_A,i_B,u_A|i_B,u_B)\) where \(J\) is the <span class="definable">stochastic</span> process of running \(M\) with input from \(h\), and \(L\) is the stochastic process of having \((i_A,i_B)\) distributed according to \(h\) and \(u_A=f_n(i_A,i_B),u_B=g_n(i_A,i_B)\).
								</li>
								<li>(Interchange A and B in (i).)</li>
							</ol>
						</section>
						<p class="rp_original">
							If A follows the protocol, but B may cheat and executes some \(M_B'\). Let \(d_n\) be the probability for runs in which \(v_A\neq\)CHEATING, and let \(U_{n,i_B}\) be the probability distribution for \(u_B\) when restricted to such runs and with \(i_B\) being an input for B. If \(d_n\) is <span class="definable">negligible</span>, then A will almost always catch B cheating, and no further requirement is needed. On the other hand, if \(d_n\in\Omega(\frac{1}{n^t})\) for some fixed \(t&gt;0\), then we require the following constraints of Validity and Privacy.
						</p>
						<section id="sec5.2.3">
							<h4>5.2.3. Validity</h4>
							<p class="rp_original">
								With probability \(d_n-o\)(poly-small), \(u_A=f_n(i_A,i_B), v_A=(p_A',q_A',N_A')\) and \(w_A'=E_{N_B'}(g_n(i_A,i_B))\), where \(N_A'\) is the product of \(n\)-bit primes \(p_A'\) and \(q_A'\); the distribution of \(N_A'\) is such that it is intractable to factor.
							</p>
						</section>
						<section id="sec5.2.4">
							<h4>5.2.4. Privacy</h4>
							<p class="rp_original">
								\(I_n^{(J)}(i_A,i_B,u_A|\Delta_B,i_B,u_B,v_B,w_B) \approx I_n^{(L)}(i_A,i_B,u_A|i_B,u_B)\), where \(J\) is the <span class="definable">stochastic</span> process induced by the execution of the protocol \(M=(M_A,M_B')\), and \(L\) is the stochastic process of being given the value of \(u_B\) distributed according to \(U_{n,i_B}\).
							</p>
							<p class="rp_original">
								As in Model I, let \(G\) denote a probabilistic polynomial-time <span class="definable">Turing machine</span> that takes \(i_B\) as input and outputs \(z\); let \(\beta_n(G)\) denote the probability that \(z=g_n(i_A,i_B)\).
							</p>
						</section>
						<section id="sec5.2.5">
							<h4>5.2.5. Fairness</h4>
							<p class="rp_original">
								For any fixed \(k\), there exists a recovery algorithm \(R\) (dependent on \(M_B'\)) whose output \(s\) satisfies the following condition:
								$$Pr\{(u_B=g_n(i_A,i_B))\wedge(s\neq f_n(i_A,i_B))\} \leq\beta_n(G)+O(\frac{1}{n^k})$$
								for some G.
							</p>
						</section>
						<p class="rp_original">
							When B follows the protocol and A may cheat, we have a set of requirements obtained from the above ones by switching the roles of A and B.
						</p>
						<p class="rp_original">
							<a href="#theorem3">Theorem 3</a> is also true for Model II.
						</p>
					</section>
					<section id="sec6">
						<h2>6. Connections</h2>
						<p class="rp_original">
							We have chosen a semantic definition of privacy, namely, the communications will not enable one to compute more accurately any polynomial-time predicates. In recent literature, an elegant concept of <i>minimum-knowledge transfer</i> protocol was introduced in <a href="#citation1"><span class="reference" data-citation="1">[1]</span></a> (and generalized in <a href="#citation2"><span class="reference" data-citation="2">[2]</span></a>) to capture the notion of no unintended information disclosure. It is easy to define privacy constraints for our problems in terms of this concept. We can show that the protocols used to prove the theorems also satisfy the minimum knowledge transfer requirements.
						</p>
						<span class="rp_theorem_header" id="theorem4">
							Theorem 4
						</span>
						<p class="rp_original rp_theorem">
							For any interactive computational problem \(\langle h_n,(f_n,g_n)\rangle\), there exists a minimum knowledge transfer protocol \(M\) that achieves validity and fairness.
						</p>
						<p class="rp_original">
							The proofs of the theorems are length, and will be given in the complete paper.
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color8">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="citation1">GMR</li>
					<li id="citation2">GHY</li>
					<li id="citation3">R</li>
					<li id="citation4">FRMW</li>
					<li id="citation5">B1</li>
					<li id="citation6">C</li>
					<li id="citation7">SRA</li>
					<li id="citation8">GM</li>
					<li id="citation9">Y1</li>
					<li id="citation10">Y2</li>
					<li id="citation11">GMW</li>
					<li id="citation12">B2</li>
					<li id="citation13">LMR</li>
					<li id="citation14">VV</li>
					<li id="citation15">HS</li>
					<li id="citation16">ACGS</li>
					<li id="citation17">BS</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+24@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Copyright &copy; Nicolas Schank 2014, Brown University</p>
            </div>
        </div>
    </body>
</html>