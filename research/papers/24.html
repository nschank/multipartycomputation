<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>How to Generate and Exchange Secrets - Andrew Yao, 1986</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					case "approx":
						return "Two probabilities of recovery are equivalent if neither is noticeably harder than the other in any situation.";
					case "D=Tn":
						return "\\(D_n\\) is the probability distribution of \\(\\tau\\) in a uniquely decipherable, <span class=\"definable\">intractable puzzle ensemble</span>.";
					case "delta":
						return "The function \\(\\Delta_X(\\sigma)\\) takes in a run of a particular protocol \\(\\sigma\\) and outputs the history of that run from \\(X\\)'s point of view.";
					case "h_n":
						return "The inputs \\((i_A,i_B)\\) to our protocol are distributed within the probability distribution \\(h_n\\) over \\(\\{0,1\\}^*\\times\\{0,1\\}^*\\)";
					case "I_n":
						return "The probability of recovering some piece of information \\(A\\) using only the information \\(B\\) (which may have been produced through some randomness \\(\\mathcal{R}\\)) is denoted by \\(I_n^{(\\mathcal{R})}(A\\;|\\;B)\\). This is read as <i>the probability of recovering \\(A\\) given \\(B\\).</i>";
					case "leq":
						return "'is not more likely than'";
					case "L_n":
						return "The set of all possible values of \\(f_n(i_A,i_B)\\) when \\((i_A,i_B)\\) are distributed according to <span class=\"equation\" data-equation=\"h_n\">\\(h_N\\)</span>.";
					case "rfunction":
						return "We denote by \(r(d_n,X_n,Y_n,Q)\) the probability that a correct guess for \(d_n(x_n)\) will be produced by \(Q\) when given \(y_n\), where \((x_n,y_n)\) is distributed according to \((X_n,Y_n)\).";
					case "u_x":
						return "We denote by \\(u_X\\) the output that party \\(X\\) receives after the run of the protocol.";
					case "U_n":
						return "We denote by \\(U_n\\) the distribution of \\(u_A\\) under a run of the protocol in which B is cheating.";
					case "v_x":
						return "We denote by \\(v_X\\) the output that party \\(X\\) receives after the run of the cooperative protocol \\(N\\), which produces the original secret for \\(u_X\\) using information received during the run of the original protocol: <span class=\"equation\" data-equation=\"delta\">\\(\\Delta_X\\)</span>.";
					case "w":
						return "The outputs \\((u_A,u_B)\\) of the protocol are distributed according to the probability distribution \\(w_{n,i_A,i_B}\\) over \\(\\{0,1\\}^*\\times\\{0,1\\}^*\\)";
					default:
						return "No info on this equation yet.";
				}
			}

			function authorLink(ref)
			{
				switch (ref)
				{
					default:
						return "#";
				}
			}

			self_def["intractable puzzle ensemble"] = "A <span class=\"definable\">puzzle ensemble</span> with the additional constraint that no PPT algorithm can produce the secret \\(s\\) given \\(\\tau\\) that satisfies \\((n,s,\\tau)\\in L\\) with more than negligible probability.";
			self_def["polynomial ensemble"] = "A sequence of distributions \\((h_1,h_2,\\dots,h_n,\\dots)\\) is assumed to be a polynomial ensemble if there is a probabilistic <span class=\"definable\">Turing machine</span> which, on input \\(n\\), will generate in time polynomial in \\(n\\) a random string \\(x\\) with a distribution <span class=\"definable\">indistinguishable</span> computationally from \\(h_n\\).";
			self_def["puzzle ensemble"] = "A puzzle ensemble \\((L,F)\\) consists of some language \\(L\\) in <span class=\"definable\">BPP</span> and a <span class=\"definable\">polynomial ensemble</span> \\(F\\) of distributions over \\(\\{0,1\\}^*\\times\\{0,1\\}^*\\). Further, a random \\((s,\\tau)\\) within \\(F_n\\) must satisfy \\((n,s,\\tau)\\in L\\) with only a <span class=\"definable\">negligible</span> probability of failure.";
			//-->
        </script>
    </head>
    <body>
		\(
			\require{cancel}
		\)
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth"><a id="_A"></a>
                    <div class="rp_linkbox"><a href="pdf/24.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">How to Generate and Exchange Secrets</span>
                    <span class="rp_info">1986
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <a class="rp_author" href="../authors/Andrew C. Yao.html">Andrew C. Yao</a></span>
						
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a>
								<ol>
									<li><a href="#a_intro">Introduction</a></li>
									<li><a href="#a_goals">Goals and Results</a></li>
									<li><a href="#a_defs">Definitions</a></li>
									<li><a href="#a_theorems">Theorems</a></li>
									<li><a href="#a_ref">Referencing This Paper</a></li>
								</ol>
							</li>
                            <li><a href="#_B">Annotated Paper</a></li>
                        </ol>
                    </div>
					
                    <div class="rp_snippet">
						An important snippet of the paper
					</div>
						
                    <section id="a_intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Paper Title</b> is...
						</p>
					</section>
					<section id="a_goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							Some goals that they had.
						</p>
						<p class="rp_analysis">
							Don't forget some results, too!
						</p>
					</section>
					<section id="a_defs">
						<h2>Definitions</h2>
						<a href="#def1"><span class="rp_definition_header">Definition 1 - Recovery Algorithm</span></a>
						<p class="rp_definition">
							A <i>recovery algorithm</i> \(R\) for A is a probabilistic polynomial-time algorithm which takes \((n,\Delta_A)\) as input, and outputs a string \(v\).
						</p>
					</section>
					<section id="a_theorems">
						<h2>Theorems</h2>
						<p class="rp_original">Some general definitions used by several theorems</p>
						<a href="#theorem1"><span class="rp_theorem_header">Theorem 1</span></a>
						<p class="rp_original rp_theorem">
							Let \(P\) be an <span class="definable">intractable puzzle ensemble</span> that is uniquely decipherable. There exists a protocol \(M=(M_A,M_B)\) for generating a secret from \(P\) that achieves <a href="#sec3.1">validity</a> and <a href="#sec3.2">fairness</a>.
						</p>
						<a href="#theorem2"><span class="rp_theorem_header">Theorem 2</span></a>
						<p class="rp_original rp_theorem">
							Let \(P_A\) and \(P_B\) be any two intractable ensembles. There exists a protocol \(M=(M_A,M_B)\) for exchanging secrets between \(P_A\) and \(P_B\) that achieves validity and fairness.
						</p>
						<a href="#theorem3"><span class="rp_theorem_header">Theorem 3</span></a>
						<p class="rp_original rp_theorem">
							For any interactive computational problem \(\langle\)<span class="equation" data-equation="h_n">\(h_n\)</span>\(,(f_n,g_n)\rangle\), there exists a protocol \(M\) that achieves validity, privacy, and fairness.
						</p>
						<a href="#theorem4"><span class="rp_theorem_header">Theorem 4</span></a>
						<p class="rp_original rp_theorem">
							For any interactive computational problem \(\langle h_n,(f_n,g_n)\rangle\), there exists a minimum knowledge transfer protocol \(M\) that achieves validity and fairness.
						</p>
					</section>
					<section id="a_ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							A reference for this paper
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5"><a id="_B"></a>
                <div class="main_window main_fullwidth">
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a></li>
                            <li>
                                <a href="#_B">Annotated Paper</a>
                                <ol>
                                    <li><a href="#sec1">Introduction</a></li>
									<li><a href="#sec2">Terminology</a></li>
									<li>
										<a href="#sec3">Generating a Secret</a>
										<ol>
											<li><a href="#sec3.1">Validity</a></li>
											<li><a href="#sec3.2">Fairness</a></li>
										</ol>
									</li>
									<li>
										<a href="#sec4">Exchange of Secrets</a>
									</li>
									<li>
										<a href="#sec5">General Computation</a>
										<ol>
											<li>
												<a href="#sec5.1">Model I</a>
											</li>
											<li>
												<a href="#sec5.2">Model II</a>
											</li>
										</ol>
									</li>
									<li><a href="#sec6">Connections</a></li>
                                </ol>
                            </li>
                        </ol>
                    </div>
					<section id="abstract">
						<h2>Abstract</h2>
						<p class="rp_original">
							In this paper we introduce a new tool for controlling the knowledge transfer process in cryptographic protocol design. It is applied to solve a general class of problems which include most of the two-party cryptographic problems in the literature. Specifically, we show how two parties A and B can interactively generate a random integer \(N = pq\) such that its secret, i.e., the prime factors \((p, q)\), is hidden from either party individually but is recoverable jointly if desired. This can be utilized to give a protocol for two parties with private values \(i\) and \(j\) to compute any polynomially computable functions \(f(i,j)\) and \(g(i,j)\) with minimal knowledge transfer and a strong fairness property. As a special case, A and B can exchange a pair of secrets \(s_A\), \(s_B\), e.g. the factorization of an integer and a Hamiltonian circuit in a graph, in such a way that \(s_A\) becomes computable by B when and only when \(s_B\) becomes computable by A. All these results are proved assuming only that the problem of factoring large integers is computationally intractable.
						</p>
					</section>
                    <section id="sec1">
						<h2>1. Introduction</h2>
                        <p class="rp_original">
							A <i>protocol</i> \(M=(M_A,M_B)\) is a pair of communicating probabilistic <span class="definable" data-define="Turing machine">Turing machines</span> each with a special "send-receive" tape. Given inputs of the form \((n,i_A)\) and \((n,i_B)\), the two machines will alternately send and receive message strings using the send-receive tapes; each machine will perform computation as a standard Turing machine after receiving a message string, including the computation of the next message to be sent. Eventually both machines halt within a number of steps bounded by some polynomial in \(n\), leaving strings <span class="equation" data-equation="u_x">\(u_A\)</span> and <span class="equation" data-equation="u_x">\(u_B\)</span> on the output tapes. For a detailed description, see for example <span class="reference" data-citation="1"><a href="#citation1">[1]</a></span><span class="reference" data-citation="2"><a href="#citation2">[2]</a></span>; in our case we allow each machine to have their own private input tape. For any run \(\sigma\) of the protocol, let <span class="equation" data-equation="delta">\(\Delta_A(\sigma)\)</span> denote the <i>history</i> of the run from A's view, i.e. a sequence of the instantaneous descriptions of \(M_A\); similarly <span class="equation" data-equation="delta">\(\Delta_B(\sigma)\)</span> denote the history of this run from B's view.
						</p>
						<p class="rp_original">
							The class of problems we are interested in are as follows. Given inputs \((n,i_A)\) and \((n,i_B)\), where \((i_A,i_B)\) is a random pair of strings distributed according to a probability distribution <span class="equation" data-equation="h_n">\(h_n\)</span> over \(\{0,1\}^*\times\{0,1\}^*\), we wish to design a protocol \(M=(M_A,M_B)\) such that the outputs \((\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\()\) are distributed according to a certain probability distribution <span class="equation" data-equation="w">\(w_{n,i_A,i_B}\)</span> over \(\{0,1\}^*\times\{0,1\}^*\). The sequence of distributions \((h_1,h_2,\dots,h_n,\dots)\) is assumed to be a <span class="definable">polynomial ensemble</span> in the sense that there is a probabilistic Turing machine which, given input \(n\), will generate in time polynomial in \(n\) a random string \(x\) with a distribution indistinguishable computationally from \(h_n\); similarly we assume that \(w_{n,i_A,i_B}\) is a polynomial ensemble in that a random sample point can be generated in time polynomial in \(n\), when the parameters \(n,i_A,i_B\) have been given. Let us call this a <i>(two-party) interactive computational problem</i> \(\langle h_n,w_n\rangle\). Of special interest is the case when the probability distribution \(w_{n,i_A,i_B}\) is nonzero only at one point, call it \((f_n(i_A,i_B),g_n(i_A,i_B))\), in which case we can regard the problem as the evaluation of a pair of functions \(f_n(i_A,i_B),g_n(i_A,i_B)\); write it as \(\langle h_n,(f_n,g_n)\rangle\).
						</p>
						<p class="rp_annotation">
							Instead of defining the sequence of <span class="equation" data-equation="h_n">\(h_n\)</span>'s as a polynomial ensemble, it may be simpler to simply state that, for any \(n\), a string \(x\) in the distribution \(h_n\) can be produced by a probabilistic polynomial-time Turing machine.
						</p>
						<p class="rp_original">
							In addition to the <i>validity</i> requirement above, we would like the protocol to have certain <i>privacy</i> and <i>fairness</i> properties. Roughly, "privacy" means that if A behaves according to the protocol, then B will have no more information about the values of \(i_A\),<span class="equation" data-equation="u_x">\(u_A\)</span> than in the situation where an oracle does the computation for B and just hands B a value <span class="equation" data-equation="u_x">\(u_B\)</span>. Classical examples where privacy is the main concern include <span class="definable">oblivious transfer</span><sup class="reference" data-citation="3"><a href="#citation3">[3]</a></sup><sup class="reference" data-citation="4"><a href="#citation4">[4]</a></sup>, <span class="definable" data-define="coin flip">coin tossing</span><sup class="reference" data-citation="5"><a href="#citation5">[5]</a></sup><sup class="reference" data-citation="6"><a href="#citation6">[6]</a></sup>, mental poker<sup class="reference" data-citation="7"><a href="#citation7">[7]</a></sup><sup class="reference" data-citation="8"><a href="#citation8">[8]</a></sup>. A general study of this problem is given by Yao<sup class="reference" data-citation="9"><a href="#citation9">[9]</a></sup><sup class="reference" data-citation="10"><a href="#citation10">[10]</a></sup>. A related problem is the <i>interactive proof system</i><sup class="reference" data-citation="1"><a href="#citation1">[1]</a></sup> in which player A wishes to convince player B that a string \(\tau\) is in a certain language L. Recently, Goldreich, Micali, and Wigderson<sup class="reference" data-citation="11"><a href="#citation11">[11]</a></sup> proved that, for players with polynomial-time computing power, an language in <span class="definable">NP</span> has a <i>minimum knowledge interactive proof</i>, assuming the existence of suitable <span class="definable" data-define="one-way function">one-way functions</span>. This latter problem is closely related to, in our formulation, the case of computing a pair of functions \(f_n(i_A,i_B),g_n(i_A,i_B)\), where \(i_A=(s,\tau), i_B=\tau, g_n(i_A,i_B)=1\) if and only if \(s\) is a short <i>proof</i> for \(t\in L\), and \(f_n(i_A,i_B)\equiv 1\).
						</p>
						<p class="rp_annotation">
							Let's give a more specific example for this final sentence. Let's say our language \(L\) is the language \(Isomorphic\), where, given two graphs \(G_1,G_2\), \((G_1,G_2)\in L\) if and only if \(G_1\) is <span class=("definable">isomorphic</span> to \(G_2\). \(\tau\) would be \((G_1,G_2)\) since it's what we hope to prove is in \(L\). \(s\) would be a proof for their isomorphism, which would be the one-to-one mapping from vertices in \(G_1\) to vertices in \(G_2\). \(g_n\) should be 1 if and only if A is able to produce such a mapping, which could only be so if \(s\in L\). \(f_n\) does not matter, since \(A\) does not mean to learn anything, so it can simply be any value, such as 1.
						</p>
						<p class="rp_original">
							The "fairness" requirement means that a cheater should not be able to obtain the desired output while denying the other party to find the proper output. The problem of exchanging secrets<sup class="reference" data-citation="12"><a href="#citation12">[12]</a></sup><sup class="reference" data-citation="13"><a href="#citation13">[13]</a></sup><sup class="reference" data-citation="14"><a href="#citation14">[14]</a></sup> has this requirement as its main concern.
						</p>
						<p class="rp_original">
							In this paper, we will give a protocol for performing the computation \(\langle\)<span class="equation" data-equation="h_n">\(h_n\)</span>,<span class="equation" data-equation="w">\(w_n\)</span>\(\rangle\) which achieves validity, privacy, and fairness as stated in <a href="#theorem3">Theorem 3</a>, under the assumption that factoring large integers is computationally intractable. Many of the existing results mentioned are special cases of this theorem. A particular interesting special case (stated as <a href="#theorem2">Theorem 2</a>) is that it allows  two parties to exchange <i>secrets</i>, such as the factorization of a publicized integer or the Hamiltonian circuit of a publicized large graph, in a way that the probability of successful cheating can be made arbitrarily small. It is somewhat surprising that the two secrets being exchanged could be of very different apparent complexity, and one would have thought that it is difficult to find an equitable ratio of bits to be maintained during the process of swapping the secrets. Previously Blum<sup class="reference" data-citation="12"><a href="#citation12">[12]</a></sup> gave a protocol for exchanging prime factors based on several assumptions (see Hastad and Shamir<sup class="reference" data-citation="15"><a href="#citation15">[15]</a></sup> for discussions); Luby, Micali, and Rackoff<sup class="reference" data-citation="13"><a href="#citation13">[13]</a></sup>, and Vazirani and Vazirani<sup class="reference" data-citation="14"><a href="#citation14">[14]</a></sup> gave protocols for exchanging secrets which are one bit long.
						</p>
						<p class="rp_original">
							The proof of <a href="#theorem3">Theorem 3</a> depends on the ability of two parties to generate a random integer \(N=p\cdot q\), with its <i>secret</i> \((p,q)\) hidden from each party, but recoverable at a later time by a joint effort. This result is of independent interest, and should serve as another useful tool for cryptographic protocol design. A general form of this result is given as <a href="#theorem1">Theorem 1</a>.
						</p>
						<p class="rp_original">
							Compared with <span class="reference" data-citation="9"><a href="#citation9">[9]</a></span><span class="reference" data-citation="10"><a href="#citation10">[10]</a></span>, which deals with the same general problem, the addition of the fairness property is the new motive which leads to the present work. We should mention that all the protocols considered in this paper for solving the interactive computational problems \(\langle h_n,w_n\rangle\) will be independent of \(h_n\), as is traditional in considering cryptographic protocols. The main results (Theorems <a href="#theorem1">1</a>,<a href="#theorem2">2</a>, and <a href="#theorem3">3</a>) are all proved under the following assumption. Let \(W_n\) be the set of all integers \(N\) of the form \(p\cdot q\) where \(p\equiv q\equiv 3\bmod{4}\) are prime numbers. 
						</p>
						<span class="rp_theorem_header" id="IAF">
							The Intractability Assumption of Factoring (IAF)
						</span>
						<p class="rp_original rp_theorem">
							Let \(k&gt;0\) be any fixed number. For any polynomial time probabilistic algorithm for factoring integers, the probability of success for a random input integer from \(W_n\) is less than \(\frac{1}{n^k}\) for all large \(n\).
						</p>
                    </section>
					<section id="sec2">
						<h2>2. Terminology</h2>
						<p class="rp_original">
							Let \(S=(S_1,S_2,\dots)\) and \(S'=(S_1',S_2',\dots)\) be <span class="definable" data-define="polynomial ensemble">polynomial ensembles</span>, where \(S_n=(X_n,Y_n)\) and \(S_n'=(X_n',Y_n')\) and each is a probability distribution over \(\{0,1\}^*\times\{0,1\}^*\). Furthermore, assume that the two ensembles \((X_1,X_2,\dots)\) and \((X_1',X_2',\dots)\) are <span class="definable">indistinguishable</span> for polynomial-time computations.
						</p>
						<p class="rp_original">
							Let \(D=(d_1,d_2,\dots)\) be a sequence of predicates \(d_n:\{0,1\}^*\rightarrow\{0,1\}\), where given \(d\) and \(n\), \(d_n(x)\) can be computed probabilistically in time polynomial in \(n\). Define a <i>guessing algorithm</i> \(Q_B\) to be a probabilistic algorithm which takes \((n,y)\) as input, where \(y\in\{0,1\}^*\), and outputs a 0 or 1 in time polynomial in \(n\).
						</p>
						<p class="rp_original">
							Consider the experiment of taking a random \((x_n,y_n)\) distributed according to \((X_n,Y_n)\). Suppose that one observes the value \(y_n\) and tries to guess what the value of \(d_n(x_n)\) is by using a guessing algorithm \(Q\); let us denote by \(r(d_n,X_n,Y_n,Q)\) the probability that a correct guess will be made. We use the notation \(o\)(poly-small) to denote any sequence \((b_1,b_2,\dots)\) that has the property \(b_n\in o(\frac{1}{n^k})\) for all fixed \(k\).
						</p>
						<p class="rp_annotation">
							\(o\)(poly-small) may be recognizable as the class of all <span class="definable">negligible</span> functions. This experiment might be recognized as similar to how a <span class="definable">hardcore bit</span> is defined except, since it is not being applied to <span class="definable" data-define="one-way function">one-way functions</span>, there are no defined bounds on the outcome of the experiment.
						</p>
						<p class="rp_original">
							We write <span class="equation" data-equation="I_n">\(I_n\)</span>\((X_n\;|\;Y_n)\;\)<span class="equation" data-equation="leq">\(\leq\)</span>\(\; \)<span class="equation" data-equation="I_n">\(I_n\)</span>\((X_n'\;|\;Y_n')\) if \(\forall D,Q \exists Q'\) such that \(r(d_n,X_n',Y_n',Q')-r(d_n,X_n,Y_n,Q)\geq o\)(poly-small).
						</p>
						<p class="rp_annotation">
							Given a set of predicates, for all guessing algorithms \(Q\) to be applied on \((X_n,Y_n)\) under those predicates, we can produce a new guessing algorithm \(Q'\) that is strictly not worse on \((X_n',Y_n')\) for the same predicates. It might be said that \((X_n',Y_n')\) is strictly not harder to guess on than \((X_n,Y_n)\), regardless of the predicates.
						</p>
						<p class="rp_original">
							We write <span class="equation" data-equation="I_n">\(I_n\)</span>\((X_n\;|\;Y_n)\;\)<span class="equation" data-equation="approx">\(\approx\)</span>\(\; \)<span class="equation" data-equation="I_n">\(I_n\)</span>\((X_n'\;|\;Y_n')\) if <span class="equation" data-equation="I_n">\(I_n\)</span>\((X_n\;|\;Y_n)\;\)<span class="equation" data-equation="leq">\(\leq\)</span>\(\; \)<span class="equation" data-equation="I_n">\(I_n\)</span>\((X_n'\;|\;Y_n')\) and <span class="equation" data-equation="I_n">\(I_n\)</span>\((X_n'\;|\;Y_n')\;\)<span class="equation" data-equation="leq">\(\leq\)</span>\(\; \)<span class="equation" data-equation="I_n">\(I_n\)</span>\((X_n\;|\;Y_n)\).
						</p>
						<p class="rp_annotation">
							We cannot produce a set of predicates for which it will be easier to guess on \((X_n,Y_n)\) than \((X_n',Y_n')\), and vice versa - so they are equally hard (or easy) to guess on.
						</p>
						<p class="rp_original">
							A <span class="definable">puzzle ensemble</span> \(P=(L,F)\) consists of a language \(L\in\) <span class="definable">BPP</span> and a <span class="definable" data-define="polynomial ensemble">polynomial-time ensemble</span> \(F=(F_1,F_2,\dots)\) where each \(f_n\) is a distribution over \(\{0,1\}^*\times\{0,1\}^*\); we require further than a random \((s,\tau)\) distributed according to \(f_n\) will satisfy \((n,s,\tau)\in L\) with probability 1-\(o\)(poly-small); we will call \(s\) a <i>secret</i> of the <i>text</i> \(\tau\). Let \(T_{P,n}\) denote the distribution of a random \(\tau\) taken from the second component of a random \((s,\tau)\) distributed as \(f_n\). We will call \(P\) <span class="definable" data-define="intractable puzzle ensemble">intractable</span> if, for every probabilistic polynomial-time algorithm \(S\), when given as input a pair \(\cancel{(s,\tau)} (n,\tau)\), where \(\tau\) is distributed according to \(T_{P,n}\), will fail with probability 1-\(o\)(poly-small) to produce an \(s\) satisfying \((n,s,\tau)\in L\).
						</p>
						<p class="rp_annotation">
							A puzzle ensemble is a language and a probability distribution over secrets and texts that promises to fail to produce a valid secret and text within the language only negligibly often. That puzzle ensemble is intractable if we cannot make an algorithm that can produce a secret given its text with more than negligible probability. Note the likely error in the original form above that would give \(S\) the answer to the question it is being asked, as opposed to the security parameter.
						</p>
						<p class="rp_original">
							For example, let \(L=\{(n;p,q,N) | N=p\cdot q; p,q\) are \(n\)-bit primes\(\}\), and \(f_n\) be the uniform distribution over the set \(W_n\). Under the <a href="#IAF">Intractability of Factorization Assumption</a>, the <i>factorization puzzle ensemble</i> \(P=(L,F)\) is an intractable puzzle ensemble.
						</p>
						<p class="rp_annotation">
							This is because, according to the assumption, given our text \(\tau=N\), we will only negligibly often be able to produce the secret \(s=(p,q)\) for sufficiently large \(n\).
						</p>
					</section>
					<section id="sec3">
						<h2>3. Generating a Secret</h2>
						<p class="rp_original">
							Let \(P=(L,F)\), where \(F=(F_1,F_2,\dots,F_n,\dots)\), be an <span class="definable">intractable puzzle ensemble</span>. We wish to design a protocol \(M=(M_A,M_B)\) which has the following properties for any given \(n\):
						</p>
						<ol class="rp_original">
							<li>\(M\) generates implicitly a pair \((s,\tau)\) distributed according to \(f_n\).</li>
							<li>The text \(\tau\) will be found out by \(M_A\) and \(M_B\) as their outputs.</li>
							<li>The secret \(s\), while computable by A and B jointly based on the information they have at the end of the execution of the protocol, is completely hidden from each party by itself, even if one of them cheats during the execution of the protocol.</li>
						</ol>
						<p class="rp_original">
							To simplify the presentation of the result, we restrict ourselves to puzzles that have unique secrets. Let us call a puzzle ensemble \(P=(L,F)\) <i>uniquely decipherable</i> if, for every \(n,\tau\), there is at most one \(s\) satisfying \((n,s,\tau)\in L\). For example, the factorization puzzle ensemble is uniquely decipherable. For a uniquely decipherable puzzle ensemble, we can write it as \(P=(\alpha,D)\), where \(\alpha=(\alpha_1,\alpha_2,\dots)\) and <span class="equation" data-equation="D=Tn">\(D=(D_1,D_2,\dots)\)</span> are given by \(\alpha_n(\tau)=s\) and \(D_n=T_{P,n}\).
						</p>
						<p class="rp_annotation">
							Though not explicitly stated, we can note here that \(\alpha_n\) is <span class="definable">injective</span>, which is what allows us to only explicitly define the probability distribution for \(\tau\) (as it must be identical for \(s\) by definition of injectivity).
						</p>
						<p class="rp_original">
							Let \(P=(\alpha,D)\) be a uniquely decipherable, intractable puzzle ensemble, where \(\alpha=(\alpha_1,\alpha_2,\dots)\) and <span class="equation" data-equation="D=Tn">\(D=(D_1,D_2,\dots)\)</span>. Formally, we define our requirements on a protocol \(M=(M_A,M_B)\) for generating a secret for \(P\) as follows. (A or B will sometimes output <span class="equation" data-equation="u_x">\(u_A\)</span> or <span class="equation" data-equation="u_x">\(u_B\)</span>=CHEATING; informally we say that A or B has detected that the other party is cheating.)
						</p>
						<section id="sec3.1">
							<h3>3.1. Validity</h3>
							<p class="rp_original">
								If both A and B follow the protocol, then
							</p>
							<ol class="rp_original" type="i">
								<li>
									With probability 1-\(o\)(poly-small), <span class="equation" data-equation="u_x">\(u_A\)</span>\(=\)<span class="equation" data-equation="u_x">\(u_B\)</span>, and their common value \(\tau\) is distributed according to a distribution indistinguishable (by polynomial-time computations) from <span class="equation" data-equation="D=Tn">\(D_n\)</span>.
								</li>
								<li>
									<span class="equation" data-equation="I_n">\(I_n^{(\mathcal{J})}\)</span>\((a_n(\tau)\;|\;\tau,\Delta_j)\;\)<span class="equation" data-equation="approx">\(\approx\)</span>\(\; \)<span class="equation" data-equation="I_n">\(I_n^{(\mathcal{L})}\)</span>\((a_n(\tau)\;|\;\tau)\) for \(j\in \{A,B\}\), where \(\mathcal{J}\) is the <span class="definable">stochastic</span> process induced by the execution of the protocol \(M=(M_A,M_B)\), and \(\mathcal{L}\) is the stochastic process of fetching \(\tau\) according to <span class="equation" data-equation="D=Tn">\(D_n\)</span>.
								</li>
							</ol>
							<p class="rp_annotation">
								The ability to guess \(a_n(\tau)\) is precisely as difficult whether done through the protocol (and therefore with extra information \(\Delta_j\), or done by simply taking \(\tau\) directly from <span class="equation" data-equation="D=Tn">\(D_n\)</span> (which, as discussed above by definition of an <span class="definable" data-define="intractable puzzle ensemble">intractable puzzle ensemble</span>, is extremely difficult).
							</p>
							<ol class="rp_original" type="i">
								<li value="3">
									\(\exists\) a protocol \(N=(N_A,N_B)\) which, given input \((\Delta_A,\Delta_B)\), computes outputs <span class="equation" data-equation="v_x">\(v_A,v_B\)</span>, with the property that \(v_A=v_B=a_n(\tau)\) with probability 1-\(o\)(poly-small).
								</li>
							</ol>
							<p class="rp_annotation">
								Given \(\Delta_A\) and \(\Delta_B\) together, a probabilistic polynomial-time algorithm can produce the secret \(s\) of \(\tau\) with only a <span class="definable">negligible</span> probability of failure.
							</p>
							<p class="rp_original">
								To discuss the validity concept when one party, say B, may misbehave. Let \(d_n\) be the probability for runs in which \(v_A\neq\)CHEATING, and let \(D_n'\) be the probability distribution for \(\tau\) when restricted to such runs. If \(d_n\) is <span class="definable">negligible</span>, then A will almost always catch B cheating, and no further requirement is needed. On the other hand, if \(d_n\in \Omega(\frac{1}{n^t})\) for some fixed \(t&gt;0\), then we require the following two constraints to be true:
							</p>
							<ol class="rp_original" type="i">
								<li value="4">
									\(P'=(\alpha,D')\) is a uniquely decipherable intractable puzzle ensemble, where \(D'=(D_1',D_2',\dots)\).
								</li>
								<li>
									<span class="equation" data-equation="I_n">\(I_n^{(\mathcal{J})}\)</span>\((a_n(\tau)\;|\;\tau,\Delta_B)\;\)<span class="equation" data-equation="approx">\(\approx\)</span> <span class="equation" data-equation="I_n">\(I_n^{(\mathcal{L})}\)</span>\((a_n(\tau)\;|\;\tau)\), where \(\mathcal{J}\) is the stochastic process induced by the execution of the protocol \(M=(M_A,M_B')\), and \(\mathcal{L}\) is the stochastic process of fetching \(\tau\) according to \(D_n'\).
								</li>
							</ol>
							<p class="rp_annotation">
								Basically, the distribution of \(\tau\) when B cheats successfully is still intractable, and \(a_n(\tau)\) is still just as difficult to produce from \((\tau,\Delta_B)\) as it was from a normally chosen \(\tau\). Obviously, the above applies when switching the roles of A and B as well.
							</p>
						</section>
						<p class="rp_original">
							To develop the concept of fairness, consider the execution of protocol \(M\) and then \(N\). If A follows the protocols, we require that the probability for B to obtain \(s\) while A cannot recover \(s\) to be small.
						</p>
						<section id="sec3.2">
							<h3>3.2. Fairness</h3>
							<ol class="rp_original" type="i">
								<li>
									[B may cheat.] Suppose protocols \(M=(M_A,M_B)\) and \(N=(N_A,N_B)\) are run with machine pairs \((M_A,M_B'),(N_A,N_B')\). There exists a polynomial-time probabilistic algorithm \(Y\) (dependent on \(M_B'\) and \(N_B'\), which takes a history pair for \(M\) and \(N\) as input, and outputs a string \(w\). We require that if A follows the protocols \(M\) and \(N\) and then runs \(Y\), the probability that <span class="equation" data-equation="u_x">\(u_A\)</span>\(=\tau\), \(v_B=a_n(\tau)\) while \(w\neq a_n(\tau)\) is \(o\)(poly-small).
								</li>
								<li>
									[A may cheat.] (Interchange the roles of A and B in (i).)
								</li>
							</ol>
							<span class="rp_theorem_header" id="theorem1">
								Theorem 1
							</span>
							<p class="rp_original rp_theorem">
								Let \(P\) be an <span class="definable">intractable puzzle ensemble</span> that is uniquely decipherable. There exists a protocol \(M=(M_A,M_B)\) for generating a secret from \(P\) that achieves <a href="#sec3.1">validity</a> and <a href="#sec3.2">fairness</a>.
							</p>
						</section>
					</section>
					<section id="sec4">
						<h2>4. Exchange of Secrets</h2>
						<p class="rp_original">
							Let \(P_A=(L_A,F_A)\) and \(P_B=(L_B,F_B)\) be two <span class="definable" data-define="intractable puzzle ensemble">intractable puzzle ensembles</span>. Let \((s_A,\tau_A),(s_B,\tau_B)\) be random puzzles distributed according to \(F_{A,n}\) and \(F_{B,n}\); give \((n,s_A,\tau_A,\tau_B)\) as input to A and \((n,s_B,\tau_A,\tau_B)\) to B. We wish to design a protocol \(M=(M_A,M_B)\) that will enable A and B to exchange their secrets \(s_A\) and \(s_B\) so that neither will be swindled. We state the criteria for the protocol below.
						</p>
						<span class="rp_sub_header">Validity</span>
						<p class="rp_original rp_sub">
							If both parties follow the protocol, then with probability \(1-o\)(poly-small), <span class="equation" data-equation="u_x">\(u_B\)</span>\(=s_A\) and <span class="equation" data-equation="u_x">\(u_A\)</span>\(=s_B\).
						</p>
						<span class="rp_sub_header">Fairness</span>
						<ol class="rp_original rp_sub" type="i">
							<li>
								[If B gets \(s_A\), then A can compute \(s_B\).]
								<p>
									If A follows the protocols and B does not (i.e., \(M_B'\neq M_B\)), then for any fixed \(k\), there exists a probabilistic polynomial-time algorithm S which takes \((n,\)<span class="equation" data-equation="delta">\(\Delta_A\)</span>\()\) as input and outputs a number \(v\) such that the following is true:
								</p>
								$$Pr\{(u_B=s_A)\wedge(v\neq s_B)\}\in O(\frac{1}{n^k}).$$
							</li>
							<li>
								[If A gets \(s_B\), then B can compute \(s_A\).] (Interchange A and B in (i).)
							</li>
						</ol>
						<span class="rp_theorem_header" id="theorem2">
							Theorem 2
						</span>
						<p class="rp_original rp_theorem">
							Let \(P_A\) and \(P_B\) be any two intractable ensembles. There exists a protocol \(M=(M_A,M_B)\) for exchanging secrets between \(P_A\) and \(P_B\) that achieves validity and fairness.
						</p>
					</section>
					<section id="sec5">
						<h2>5. General Computation</h2>
						<p class="rp_original">
							Consider an interactive computational problem \(\langle h_n,w_n\rangle\) as defined in <a href="#sec1">Section 1</a>. We will show that there exists a protocol for it that satisfies some strong privacy and fairness constraints. In this extended abstract, we restrict ourselves to the case when \(w_n\) represents a pair of functions \((f_n,g_n)\) to be evaluated, i.e. given inputs \(i_A,i_B\), A and B wish to compute \(f_n(i_A,i_B)\) and \(g_n(i_A,i_B)\). The results can be extended to the general case.
						</p>
						<p class="rp_original">
							We will consider two variants, which differ in their input-output format. Model I is the natural one, in which the inputs and outputs are as specified in the previous paragraph. However, since in general A does not have any control over the value of \(i_B\), a dishonest B can pretend that \(i_B\) is an arbitrary value \(y\). As a result, the fairness constraint can at most force B to compute the value of \(f_n(i_A,y)\) for <i>some</i> \(y\). In Model II, A will be given as input \((i_A,p_A,q_A,N_A,N_B,E_{N_B}(i_B))\) where \(N_A=p_A\cdot q_A\) is the product of two large primes, and \(N_B\) is another integer of two large prime factors used to encode B's parameter \(i_B\) as \(E_{N_B}(i_B)\); B has as input \((i_B,p_B,q_B,N_B,N_A,E_{N_A}(i_A))\). The integers \(N_A\) and \(N_B\) are generated from some distributions such that factoring these numbers are computationally intractable; \(E_N\) can be any probabilistic encryption scheme that is provably secure under the <a href="#IAF">Intractability Assumption of Factoring</a> (e.g. the ones in Alexi, Chor, Goldreich, and Schnorr<sup class="reference" data-citation="16"><a href="#citation16">[16]</a></sup> or Blum and Goldwasser<sup class="reference" data-citation="17"><a href="#citation17">[17]</a></sup>). In the output, A, B obtain \((\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(,v_A,w_A)\) and \(\cancel{(u_A,v_A,w_A)}\;(u_B,v_B,w_B)\). When both parties behave honestly, <span class="equation" data-equation="u_x">\(u_A\)</span>\(=f_n(i_A,i_B), v_A=(p_A',q_A',N_A'),\) and \(w_A=(N_B', E_{N_B'}(g_n(i_A,i_B)))\), where \(N_A'\) and \(N_B'\) are integers which are the products of two large prime factors; similarly for the output of B. Such formats arise quite naturally in concatenating protocols. The privacy and fairness constraints in this model are stronger than the first model.
						</p>
						<p class="rp_annotation">
							Notice the error corrected above.
						</p>
						<section id="sec5.1">
							<h3>5.1. Model I</h3>
							<p class="rp_original">
								We first define the constraints when both parties follow the protocol.
							</p>
							<span class="rp_sub_header">Validity</span>
							<p class="rp_original rp_sub">
								With probability 1-\(o\)(poly-small), <span class="equation" data-equation="u_x">\(u_A\)</span>\(=f_n(i_A,i_B)\) and <span class="equation" data-equation="u_x">\(u_B\)</span>\(=g_n(i_A,i_B)\).
							</p>
							<span class="rp_sub_header">Privacy</span>
							<ol class="rp_original rp_sub">
								<li>
									<span class="equation" data-equation="I_n">\(I_n^{(\mathcal{J})}\)</span>\((i_A,i_B,\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(\;|\;\)<span class="equation" data-equation="delta">\(\Delta_B\)</span>\(,i_B,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\()\;\)<span class="equation" data-equation="approx">\(\approx\)</span> <span class="equation" data-equation="I_n">\(I_n^{(\mathcal{L})}\)</span>\((i_A,i_B,\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(\;|\;i_B,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\()\) where \(\mathcal{J}\) is the <span class="definable">stochastic</span> process of running \(M\) with input from <span class="equation" data-equation="h_n">\(h\)</span>, and \(\mathcal{L}\) is the stochastic process of having \((i_A,i_B)\) distributed according to <span class="equation" data-equation="h_n">\(h\)</span> and <span class="equation" data-equation="u_x">\(u_A\)</span>\(=f_n(i_A,i_B),\)<span class="equation" data-equation="u_x">\(u_B\)</span>\(=g_n(i_A,i_B)\).
								</li>
								<li>
									(Interchange A and B in (i).)
								</li>
							</ol>
							<p class="rp_annotation">
								That is to say, running our protocol will not make it any easier to find the other person's input than it would have been if an oracle had given us the answer. This is our main connection to multiparty computation.
							</p>
							<p class="rp_original">
								We now define the constraints when A follows the protocol while B may cheat; that is, B executes the protocol with any \(M_B'\). Since \(M_B'\) is arbitrary, B can always generate an \(i_B'\) and acts as if this is the input value \(i_B\). As A can never detect this method of cheating, A has to cooperate and let B know the value of \(g_n(i_A,i_B')\). This enables B to control A's output <span class="equation" data-equation="u_x">\(u_A\)</span>, and to probe somewhat into the value of \(i_A\); this cannot be prevented if we want to preserve the validity condition for honest parties described above. We shall require that B cannot do more than that. Let us denote by \(\mathcal{Z}\) the set \(\{0,1\}^*\cup\{\)CHEATING\(\}\), and extend the function \(f_n\) by \(f_n(i_A,y)=\)CHEATING if \(y=\)CHEATING.
							</p>
							<p class="rp_original">
								Let \(M_B'\) be any communicating <span class="definable">Turing machine</span>, and let <span class="equation" data-equation="U_n">\(U_n\)</span> be the distribution corresponding to <span class="equation" data-equation="u_x">\(u_A\)</span> when \((M_A,M_B')\) are used to carry out the protocol.
							</p>
							<span class="rp_sub_header">Validity</span>
							<p class="rp_original rp_sub">
								There exists a probabilistic polynomial-time algorithm \(S\) that takes input \((n,i_B)\) and produces a random \(y\in \mathcal{Z}\) such that <span class="equation" data-equation="U_n">\(U_n\)</span> is indistinguishable from the distribution corresponding to \(f_n(i_A,y)\).
							</p>
							<p class="rp_original">
								Let \(\mathcal{J}\) be the <span class="definable">stochastic</span> process of running \((M_A,M_B')\) with input \((i_A,i_B)\) distributed according to <span class="equation" data-equation="h_n">\(h_n\)</span>. Let \(\mathcal{S}\) be the set of all probabilistic polynomial-time algorithms \(S\) that take input \((n,i_B)\) and produce random \(y\in \mathcal{Z}\). For any \(S\in\mathcal{S}\), let \(\mathcal{L}(S)\) be the stochastic process of generating \((i_A,i_B)\) according to \(h_n\), running \(S\) on input \((n,i_B)\) to produce a random \(y\), and defining <span class="equation" data-equation="u_x">\(u_A\)</span>\(=f_n(i_A,y),\)<span class="equation" data-equation="u_x">\(u_B\)</span>\(=g_n(i_A,y)\). Intuitively, B may use \(S\) to generate a random \(y\), and after that, acts as if \(y\) were the value of \(i_B\), and otherwise follows the protocol; \(\mathcal{L}(S)\) is clearly a less informative process for B in which A simply tells B the value of <span class="equation" data-equation="u_x">\(u_B\)</span>\(=g_n(i_A,y)\) without other communications taking place.
							</p>
							<span class="rp_sub_header">Privacy</span>
							<p class="rp_original rp_sub">
								For any \(M_B'\), there exists an \(S\in\mathcal{S}\) such that <span class="equation" data-equation="I_n">\(I_n^{(\mathcal{J})}\)</span>\((i_A,i_B,\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(\;|\;\)<span class="equation" data-equation="delta">\(\Delta_B\)</span>\(,i_B,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\()\;\)<span class="equation" data-equation="leq">\(\leq\)</span>\(\;\)<span class="equation" data-equation="I_n">\(I_n\)</span>\(^{(\mathcal{L}(S))}(i_A,i_B,\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(|i_B,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\()\).
							</p>
							<p class="rp_original">
								The fairness concept refers to obtaining the information that one is entitled to. Suppose B wishes to know the value of \(g_n(i_A,y)\) for some \(y\) other than \(i_B\). As we mentioned earlier, B can succeed by pretending \(i_B=y\) and otherwise follow the protocol; in the process A will obtain also the value of \(f_n(i_A,y)\). The privacy constraint stipulates that no information other than the value of \(g_n(i_A,y)\) is conveyed from A to B. The fairness constraint is concerned with whether it is possible for B to stop at some point, once B has the information about \(g_n(i_A,y)\), and deny the knowledge of \(f_n(i_A,y)\) to A. The following formulation is not the strongest possible version of this constraint, but it is sufficient for some applications such as exchanging secrets of sufficient length. Let \(L_n\) denote the set of all possible values of \(f_n(i_A,i_B)\) when \((i_A,i_B)\) is distributed according to <span class="equation" data-equation="h_n">\(h_n\)</span>.
							</p>
							<span class="rp_definition_header" id="def1">
								Definition 1 - Recovery Algorithm
							</span>
							<p class="rp_definition">
								A <i>recovery algorithm</i> \(R\) for A is a probabilistic polynomial-time algorithm which takes \((n,\Delta_A)\) as input, and outputs a string \(v\).
							</p>
							<p class="rp_annotation">
								That is to say, a recovery algorithm is any which attempts to determine \(f_n(i_A,i_B)\) given what A knows.
							</p>
							<p class="rp_original">
								Consider a pair \((i_A,i_B)\) distributed according to <span class="equation" data-equation="h_n">\(h_n\)</span>. Let \(G\) denote a probabilistic polynomial-time <span class="definable">Turing machine</span> that takes \(i_B\) as input and outputs \(z\); let \(\beta_n(G)\) denote the probability that \(z=g_n(i_A,i_B)\).
							</p>
							<p class="rp_annotation">
								So \(G\) tries to come up with \(g_n(i_A,i_B)\) given <u>only</u> \(i_B\).
							</p>
							<span class="rp_sub_header">Fairness</span>
							<p class="rp_original rp_sub">
								For any fixed \(k\), there exists a recovery algorithm \(R\) (dependent on \(M_B'\)) whose output \(v\) satisfies the following condition:
								$$Pr\{(u_B=g_n(i_A,i_B))\wedge (v\notin L_n)\}\leq \beta_n(G)+O(\frac{1}{n^k})$$
								for some \(G\).
							</p>
							<p class="rp_annotation">
								Saying it in words is helpful. For any fixed \(k\), we can find a recovery algorithm \(R\) and a \(G\) so that the probability that B correctly determined \(g_n(i_A,i_B)\) by the end, but that A could not find any possible value for \(f_n(i_A,i_B)\) by the end, is only <span class="definable" data-define="negligible">negligibly</span> higher than the probability that B could have just guessed \(g_n(i_A,i_B)\) in the first place.
							</p>
							<p class="rp_annotation">
								<span data-broken-link=true>However, why can't R just always pick a value within the range of \(f_n\)?</span>
							</p>
							<p class="rp_original">
								To complete the definitions, we interchange the roles of A and B in the above discussions, which gives the constraints of validity, privacy, and fairness when B follows the protocol and A is cheating.
							</p>
							<p class="rp_original">
								A protocol is said to achieve validity, privacy, and fairness, if all the above constraints are satisfied.
							</p>
							<span class="rp_theorem_header" id="theorem3">
								Theorem 3
							</span>
							<p class="rp_original rp_theorem">
								For any interactive computational problem \(\langle\)<span class="equation" data-equation="h_n">\(h_n\)</span>\(,(f_n,g_n)\rangle\), there exists a protocol \(M\) that achieves validity, privacy, and fairness.
							</p>
						</section>
						<p class="rp_original">
							In Model II, the constraints are simpler. The input-output formats are as explained at the <a href="#sec5">beginning of this section</a>.
						</p>
					</section>
					<section id="sec5.2">
						<h3>5.2. Model II</h3>
						<p class="rp_original">
							When both A and B follow the protocol, the following is required.
						</p>
						<span class="rp_sub_header">Validity</span>
						<p class="rp_original rp_sub">
							With probability 1-\(o\)(poly-small), <span class="equation" data-equation="u_x">\(u_A\)</span>\(=f_n(i_A,i_B),v_A=(p_A',q_A',N_A')\) and \(w_A=E_{N_B'}(g_n(i_A,i_B))\), where \(N_A'\) is the product of \(n\)-bit primes \(p_A'\) and \(q_A'\); the distribution of \(N_A'\) is such that it is intractable to factor. A dual constraint on B is also required.
						</p>
						<span class="rp_sub_header">Privacy</span>
						<ol class="rp_original rp_sub" type="i">
							<li>	
								<span class="equation" data-equation="I_n">\(I_n^{(\mathcal{J})}\)</span>\((i_A,i_B,\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(\;|\;\)<span class="equation" data-equation="delta">\(\Delta_B\)</span>\(,i_B,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\(,v_B,w_B)\;\)<span class="equation" data-equation="approx">\(\approx\)</span> <span class="equation" data-equation="I_n">\(I_n^{(\mathcal{L})}\)</span>\((i_A,i_B,\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(\;|\;i_B,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\()\) where \(\mathcal{J}\) is the <span class="definable">stochastic</span> process of running \(M\) with input from <span class="equation" data-equation="h_n">\(h\)</span>, and \(\mathcal{L}\) is the stochastic process of having \((i_A,i_B)\) distributed according to <span class="equation" data-equation="h_n">\(h\)</span> and <span class="equation" data-equation="u_x">\(u_A\)</span>\(=f_n(i_A,i_B),\)<span class="equation" data-equation="u_x">\(u_B\)</span>\(=g_n(i_A,i_B)\).
							</li>
							<li>(Interchange A and B in (i).)</li>
						</ol>
						<p class="rp_original">
							If A follows the protocol, but B may cheat and executes some \(M_B'\). Let \(d_n\) be the probability of runs in which \(v_A\neq\)CHEATING, and let \(U_{n,i_B}\) be the probability distribution for <span class="equation" data-equation="u_x">\(u_B\)</span> when restricted to such runs and with \(i_B\) being an input for B. If \(d_n\) is <span class="definable">negligible</span>, then A will almost always catch B cheating, and no further requirement is needed. On the other hand, if \(d_n\in\Omega(\frac{1}{n^t})\) for some fixed \(t&gt;0\), then we require the following constraints of Validity and Privacy.
						</p>
						<span class="rp_sub_header">Validity</span>
						<p class="rp_original rp_sub">
							With probability \(d_n-o\)(poly-small), <span class="equation" data-equation="u_x">\(u_A\)</span>\(=f_n(i_A,i_B), v_A=(p_A',q_A',N_A')\) and \(w_A'=E_{N_B'}(g_n(i_A,i_B))\), where \(N_A'\) is the product of \(n\)-bit primes \(p_A'\) and \(q_A'\); the distribution of \(N_A'\) is such that it is intractable to factor.
						</p>
						<span class="rp_sub_header">Privacy</span>
						<p class="rp_original rp_sub">
							<span class="equation" data-equation="I_n">\(I_n^{(\mathcal{J})}\)</span>\((i_A,i_B,\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(\;|\;\)<span class="equation" data-equation="delta">\(\Delta_B\)</span>\(,i_B,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\(,v_B,w_B)\;\)<span class="equation" data-equation="approx">\(\approx\)</span> <span class="equation" data-equation="I_n">\(I_n^{(\mathcal{L})}\)</span>\((i_A,i_B,\)<span class="equation" data-equation="u_x">\(u_A\)</span>\(\;|\;i_B,\)<span class="equation" data-equation="u_x">\(u_B\)</span>\()\) where \(\mathcal{J}\) is the <span class="definable">stochastic</span> process induced by the execution of the protocol \(M=(M_A,M_B')\), and \(\mathcal{L}\) is the stochastic process of being given the value of <span class="equation" data-equation="u_x">\(u_B\)</span> distributed according to \(U_{n,i_B}\).
						</p>
						<p class="rp_original">
							As in Model I, let \(G\) denote a probabilistic polynomial-time <span class="definable">Turing machine</span> that takes \(i_B\) as input and outputs \(z\); let \(\beta_n(G)\) denote the probability that \(z=g_n(i_A,i_B)\).
						</p>
						<span class="rp_sub_header">Fairness</span>
						<p class="rp_original rp_sub">
							For any fixed \(k\), there exists a recovery algorithm \(R\) (dependent on \(M_B'\)) whose output \(s\) satisfies the following condition:
							$$Pr\{(u_B=g_n(i_A,i_B))\wedge(s\neq f_n(i_A,i_B))\} \leq\beta_n(G)+O(\frac{1}{n^k})$$
							for some G.
						</p>
						<p class="rp_annotation">
							We can make a recovery algorithm good enough that the probability of B getting \(g_n\) but our recovery algorithm not working is negligible, unless B just guessed by using \(G\).
						</p>
						<p class="rp_original">
							When B follows the protocol and A may cheat, we have a set of requirements obtained from the above ones by switching the roles of A and B.
						</p>
						<p class="rp_original">
							<a href="#theorem3">Theorem 3</a> is also true for Model II.
						</p>
					</section>
					<section id="sec6">
						<h2>6. Connections</h2>
						<p class="rp_original">
							We have chosen a semantic definition of privacy, namely, that communications will not enable one to compute more accurately any polynomial-time predicates. In recent literature, an elegant concept of <i>minimum-knowledge transfer</i> protocol was introduced in <span class="reference" data-citation="1"><a href="#citation1">[1]</a></span> (and generalized in <span class="reference" data-citation="2"><a href="#citation2">[2]</a></span>) to capture the notion of no unintended information disclosure. It is easy to define privacy constraints for our problems in terms of this concept. We can show that the protocols used to prove the theorems also satisfy the minimum knowledge transfer requirements.
						</p>
						<span class="rp_theorem_header" id="theorem4">
							Theorem 4
						</span>
						<p class="rp_original rp_theorem">
							For any interactive computational problem \(\langle h_n,(f_n,g_n)\rangle\), there exists a minimum knowledge transfer protocol \(M\) that achieves validity and fairness.
						</p>
						<p class="rp_original">
							The proofs of the theorems are lengthy, and will be given in the complete paper.
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color8">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="citation1">S. Goldwasser, S. Micali, and C. Rackoff, "The knowledge complexity of interactive proof systems," <i>Proceedings of 17th Annual ACM Symposium on Theory of Computing</i>, 1985, 291-304.</li>
					<li id="citation2">Z. Galil, S. Habe, and M. Yung, "A private interactive test of a Boolean predicate and minimum-knowledge public-key cryptosystems," <i>PRoceedings of 26th Annual IEEE Symposium on Foundations of Computer Science</i>, 1985, 360-371.</li>
					<li id="citation3">M. Rabin, "How to exchange secrets," 1981, unpublished manuscript.</li>
					<li id="citation4">M. Fischer, S. Micali, C. Rackoff, and D. Wittenberg, "An oblivious transfer protocol," 1985, to appear.</li>
					<li id="citation5">M. Blum, "Coin flipping by phone," <i>COMPCON</i> (1982), 133-137.</li>
					<li id="citation6">R. Cleve, "Limits on the security of coin flips when half of the processors are faulty," <i>Proceedings of 18th Annual ACM Symposium on Theory of Computing</i>, 1986, 364-369.</li>
					<li id="citation7">A. Shamir, R. Rivest, and L. Adleman, "Mental Poker," MIT Technical Report, 1978.</li>
					<li id="citation8">S. Goldwasser and S. Micali, "Probabilistic encryption and how to play mental poker keeping secret all partial information," <i>Proceedings of 14th Annual ACM Symposium on Theory of Computing</i>, 1982, 365-377.</li>
					<li id="citation9"><a href="49.html">A. Yao, "Protocols for secure computations," (extended abstract) <i>Proceedings of 21st Annual IEEE Symposium on Foundations of Computer Science</i>, 1982.</a></li>
					<li id="citation10">A. Yao, "Protocols for secure computations," in preparation.</li>
					<li id="citation11">O. Goldreich, S. Micali, and A. Widgerson, "Proofs that yield nothing but their validity and a methodology of cryptographic protocol design," <i>Proceedings of 27th Annual IEEE Symposium on Foundations of Computer Science</i>, 1986.</li>
					<li id="citation12">M. Blum, "How to exchange (secret) keys," <i>ACM Transactions on Computer Systems</i> (1983), 175-193.</li>
					<li id="citation13">M. Luby, S. Micali, and C. Rackoff, "How to simultaneously exchange a secret bit by flipping a symmetrically-based coin," <i>Proceedings of 24th Annual IEEE Symposium on Foundations of Computer Science</i>, 1985, 11-22</li>
					<li id="citation14">U. Vazirani and V. Vazirani, "Trapdoor pseudo-random number generators, with applications to protocol design," <i>Proceedings of 24th Annual IEEE Symposium on Foundations of Computer Science</i>, 1985, 23-30.</li>
					<li id="citation15">J. Hastad and A. Shamir, "The cryptographic security of truncated linearly related variables," <i>PRoceedings of 17th Annual ACM Symposium on Theory of Computing</i>, 1985, 356-362.</li>
					<li id="citation16">W. Alexi, B. Chor, O. Goldreich, and C.P. Schnorr, "RSA/Rabin bits are 1/2+1/2poly(log n) secure," <i>Proceedings of 25th Annual IEEE Symposium on Foundations of Computer Science</i>, 1984, 449-457.</li>
					<li id="citation17">M. Blum and S. Goldwasser, "An efficient probabilistic PKCS as secure as factoring," <i>Proceedings of Crypto 84</i>, 1984.</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+24@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Copyright &copy; Nicolas Schank 2014, Brown University</p>
            </div>
        </div>
    </body>
</html>