<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>How to Generate and Exchange Secrets - Andrew Yao, 1986</title>
        <link rel="stylesheet" type="text/css" href="../../style/main.css">
        <link rel="stylesheet" type="text/css" href="../../style/equation.css">
        <link rel="stylesheet" type="text/css" href="../../style/ref.css">
        <link rel="stylesheet" type="text/css" href="../../style/glossary.css">
        <link rel="stylesheet" type="text/css" href="../../style/researchPaper.css">
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="../../script/blockShare.js"></script>
        <script type="text/javascript" src="../../script/equation.js"></script>
        <script type="text/javascript" src="../../script/ref.js"></script>
        <script type="text/javascript" src="../../script/glossary.js"></script>
        <script type="text/javascript" src="../../script/def.js"></script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript">
			<!--
            function fill(box)
			{
				switch (box)
				{
					case "delta":
						return "The function \\(\\Delta_X(\\sigma)\\) takes in a run of a particular protocol \\(\\sigma\\) and outputs the history of that run from \\(X\\)'s point of view.";
					case "rfunction":
						return "We denote by \(r(d_n,X_n,Y_n,Q)\) the probability that a correct guess for \(d_n(x_n)\) will be produced by \(Q\) when given \(y_n\), where \((x_n,y_n)\) is distributed according to \((X_n,Y_n)\).";
					
					default:
						return "No info on this equation yet.";
				}
			}

			function authorLink(ref)
			{
				switch (ref)
				{
					default:
						return "#";
				}
			}

			self_def["polynomial ensemble"] = "A sequence of distributions \\((h_1,h_2,\\dots,h_n,\\dots)\\) is assumed to be a polynomial ensemble if there is a probabilistic <span class=\"definable\">Turing machine</span> which, on input \\(n\\), will generate in time polynomial in \\(n\\) a random string \\(x\\) with a distribution <span class=\"definable\">indistinguishable</span> computationally from \\(h_n\\).";
			//-->
        </script>
    </head>
    <body>
        <div class="main_foreground">
            <div class="main_toplevel main_header">
                <h1>Multiparty Computation</h1>
            </div>
            <div class="main_toplevel main_navigation">
                <a href="../../index.html"><div class="main_navbox"><h2>home</h2></div></a>
                <a href="../../learn.html"><div class="main_navbox"><h2>learn</h2></div></a>
                <a href="../../research.html"><div class="main_navbox"><h2>research</h2></div></a>
                <a href="../../nextsteps.html"><div class="main_navbox"><h2>build</h2></div></a>
                <a href="../../resources.html"><div class="main_navbox"><h2>resources</h2></div></a>
                <a href="../../aboutus.html"><div class="main_navbox"><h2>about us</h2></div></a>
            </div>
            <div class="main_toplevel main_section main_color1">
                <div class="main_section_nav_container">
                    <div class="main_section_nav_box"><a href="../timeline.html">Timeline</a></div>
                    <div class="main_section_nav_box"><a href="../title.html">By Title</a></div>
                    <div class="main_section_nav_box"><a href="../authors.html">By Author</a></div>
                    <div class="main_section_nav_box"><a href="../tag.html">By Category</a></div>
                </div>
                <div class="main_window main_fullwidth"><a id="_A"></a>
                    <div class="rp_linkbox"><a href="pdf/24.pdf"><img src="../../img/PDF.png" class="rp_link" alt="view pdf" /></a></div>
					
                    <span class="rp_title">Paper Title</span>
                    <span class="rp_info">Year
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <a class="rp_author" href="../authors/authorpage.html">Author</a></span>
						
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a>
								<ol>
									<li><a href="#a_intro">Introduction</a></li>
									<li><a href="#a_goals">Goals and Results</a></li>
									<li><a href="#a_defs">Definitions</a></li>
									<li><a href="#a_theorems">Theorems</a></li>
									<li><a href="#a_protocols">Protocols</a></li>
									<li><a href="#a_ref">Referencing This Paper</a></li>
								</ol>
							</li>
                            <li><a href="#_B">Annotated Paper</a></li>
                        </ol>
                    </div>
					
                    <div class="rp_snippet">
						An important snippet of the paper
					</div>
						
                    <section id="a_intro">
						<h2>Introduction</h2>
						<p class="rp_analysis">
							<b>Paper Title</b> is...
						</p>
					</section>
					<section id="a_goals">
						<h2>Goals and Results</h2>
						<p class="rp_analysis">
							Some goals that they had.
						</p>
						<p class="rp_analysis">
							Don't forget some results, too!
						</p>
					</section>
					<section id="a_defs">
						<h2>Definitions</h2>
						<a href="#def1"><span class="rp_definition_header">Definition 1 - </span></a>
						<p class="rp_original rp_definition">
							A definition 
						</p>
					</section>
					<section id="a_theorems">
						<h2>Theorems</h2>
						<p class="rp_original">Some general definitions used by several theorems</p>
						<a href="#theorem1"><span class="rp_theorem_header">Theorem 1</span></a>
						<p class="rp_original rp_theorem">
							A theorem
						</p>
					</section>
					<section id="a_protocol">
						<h2>Protocols</h2>
						<h3><a href="#secxx">Some Protocol Defined</a></h3>
						<ul class="rp_analysis">
							<li><b>Number of parties: </b></li>
							<li><b>Function(s): </b></li>
							<li><b>Privacy constraints: </b></li>
							<li><b>Security constraints: </b></li>
							<li><b>Cheating: </b></li>
							<li><b>Bits exchanged: </b></li>
							<li><b>Runtime:</b></li>
						</ul>
					</section>
					<section id="a_ref">
						<h2>Referencing This Paper</h2>
						<p class="rp_analysis">To cite this paper, simply copy and paste the below into your citation:</p>
						<p class="rp_self_reference">
							A reference for this paper
						</p>
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color5"><a id="_B"></a>
                <div class="main_window main_fullwidth">
                    <div class="main_toc">
                        <h4 style="color:#333333">Table of Contents</h4>
                        <ol type="A">
                            <li><a href="#_A">Overview</a></li>
                            <li>
                                <a href="#_B">Annotated Paper</a>
                                <ol>
                                    <li><a href="#sec1">Introduction</a></li>
                                </ol>
                            </li>
                        </ol>
                    </div>
					<section id="abstract">
						<h2>Abstract</h2>
						<p class="rp_original">
							In this paper we introduce a new tool for controlling the knowledge transfer process in cryptographic protocol design. It is applied to solve a general class of problems which include most of the two-party cryptographic problems in the literature. Specifically, we show how two parties A and B can interactively generate a random integer \(N = pq\) such that its secret, i.e., the prime factors \((p, q)\), is hidden from either party individually but is recoverable jointly if desired. This can be utilized to give a protocol for two parties with private values \(i\) and \(j\) to compute any polynomially computable functions \(f(i,j)\) and \(g(i,j)\) with minimal knowledge transfer and a strong fairness property. As a special case, A and B can exchange a pair of secrets \(s_A\), \(s_B\), e.g. the factorization of an integer and a Hamiltonian circuit in a graph, in such a way that \(s_A\) becomes computable by B when and only when \(s_B\) becomes computable by A. All these results are proved assuming only that the problem of factoring large integers is computationally intractable.
						</p>
					</section>
                    <section id="sec1">
						<h2>Introduction</h2>
                        <p class="rp_original">
							A <i>protocol</i> \(M=(M_A,M_B)\) is a pair of communicating probabilistic <span class="definable" data-define="Turing machine">Turing machines</span> each with a special "send-receive" tape. Given inputs of the form \((n,i_A)\) and \((n,i_B)\), the two machines will alternately send and receive message strings using the send-receive tapes; each machine will perform computation as a standard Turing machine after receiving a message string, including the computation of the next message to be sent. Eventually both machines half within a number of steps bounded by some polynomial in \(n\), leaving strings \(u_A\) and \(u_B\) on the output tapes. For a detailed description, see for example <a href="#citation1"><span class="reference" data-citation="1">[1]</span></a><a href="#citation2"><span class="reference" data-citation="2">[2]</span></a>; in our case we allow each machine to have their own private input tape. For any run \(\sigma\) of the protocol, let <span class="equation" data-equation="delta">\(\Delta_A(\sigma)\)</span> denote the <i>history</i> of the run from A's view, i.e. a sequence of the instantaneous descriptions of \(M_A\); similarly <span class="equation" data-equation="delta">\(\Delta_B(\sigma)\)</span> denote the history of this run from B's view.
						</p>
						<p class="rp_original">
							The class of problems we are interested in are as follows. Given inputs \((n,i_A)\) and \((n,i_B)\), where \((i_A,i_B)\) is a random pair of strings distributed according to a probability distribution \(h_n\) over \(\{0,1\}^*\times\{0,1\}^*\), we wish to design a protocol \(\mathbb(M)=(M_A,M_B)\) such that the outputs \((u_A,u_B)\) are distributed according to a certain probability distribution \(w_{n,i_A,i_B}\) over \(\{0,1\}^*\times\{0,1\}^*\). The sequence of distributions \((h_1,h_2,\dots,h_n,\dots)\) is assumed to be a <i>polynomial ensemble</i> in the sense that there is a probabilistic Turing machine which, given input \(n\), will generate in time polynomial in \(n\) a random string \(x\) with a distribution indistinguishable computationally from \(h_n\); similarly we assume that \(w_{n,i_A,i_B}\) is a polynomial ensemble in that a random sample point can be generated in time polynomial in \(n\), when the parameters \(n,i_A,i_B\) have been given. Let us call this a <i>(two-party) interactive computational problem</i> \(\langle h_n,w_n\rangle\). OF special interest is the case when the probability distribution \(w_{n,i_A,i_B}\) is nonzero only at one point, call it \((f_n(i_A,i_B),g_n(i_A,i_B))\), in which case we can regard the problem as the evaluation of a pair of functions \(f_n(i_A,i_B),g_n(i_A,i_B)\); write it as \(\langle h_n,(f_n,g_n)\rangle\).
						</p>
						<p class="rp_original">
							In addition to the <i>validity</i> requirement above, we would like the protocol to have certain <i>privacy</i> and <i>fairness</i> properties. Roughly, "privacy" means that if A behaves according to the protocol, then B will have no more information about the values of \(i_A,u_A\) than in the situation where an oracle does the computation for B and just hands B a value \(u_B\). Classical examples where privacy is the main concern include <span class="definable">oblivious transfer</span><a href="#citation3"><sup class="reference" data-citation="3">[3]</sup></a><a href="#citation4"><sup class="reference" data-citation="4">[4]</sup></a>, <span class="definable" data-define="coin flip">coin tossing</span><a href="#citation5"><sup class="reference" data-citation="5">[5]</sup></a><a href="#citation6"><sup class="reference" data-citation="6">[6]</sup></a>, mental poker<a href="#citation7"><sup class="reference" data-citation="7">[7]</sup></a><a href="#citation8"><sup class="reference" data-citation="8">[8]</sup></a>. A general study of this problem is given by Yao<a href="#citation9"><sup class="reference" data-citation="9">[9]</sup></a><a href="#citation10"><sup class="reference" data-citation="10">[10]</sup></a>. A related problem is the <i>interactive proof system</i><a href="#citation1"><sup class="reference" data-citation="1">[1]</sup></a> in which player A wishes to convince player B that a string \(\tau\) is in a certain language L. Recently, Goldreich, Micali, and Wigderson<a href="#citation11"><sup class="reference" data-citation="11">[11]</sup></a> proved that, for players, with polynomial-time computing power, an language in <span class="definable">NP</span> has a <i>minimum knowledge interactive proof</i>, assuming the existence of suitable <span class="definable" data-define="one-way function">one-way functions</span>. This latter problem is closely related to, in our formulation, the case of computing a pair of functions \(f_n(i_A,i_B),g_n(i_A,i_B)\), where \(i_A=(s,\tau), i_B=\tau, g_n(i_A,i_B)=1\) if and only if \(s\) is a short <i>proof</i> for \(t\in L\), and \(f_n(i_A,i_B)\equiv 1\).
						</p>
						<p class="rp_original">
							The "fairness" requirement means that a cheater should not be able to obtain the desired output while denying the other party to find the proper output. The problem of exchanging secrets<a href="#citation12"><sup class="reference" data-citation="12">[12]</sup></a><a href="#citation13"><sup class="reference" data-citation="13">[13]</sup></a><a href="#citation14"><sup class="reference" data-citation="14">[14]</sup></a> has this requirement as its main concern.
						</p>
						<p class="rp_original">
							In this paper, we will give a protocol for performing the computation \(\langle g_n,w_n\rangle\) which avieves validity, privacy, and fairness as stated in <a href="#theorem3">Theorem 3</a>, under the assumption that factoring large integers is computationally intractable. Many of the existing results mentioned are special cases of this theorem. A particular interesting special case (stated as <a href="#theorem2">Theorem 2</a>) is that it allows  two parties to exchange <i>secrets</i>, such as the factorization of a publicized integer or the Hamiltonian circuit of a publicized large graph, in a way that the probability of successful cheating can be made arbitrarily small. It is somewhat surprising that the two secrets being exchanged could be of very different apparent complexity, and one would have thought that it is difficult to find an equitable ratio of bits to be maintained during the process of swapping the secrets. Previously Blum<a href="#citation12"><sup class="reference" data-citation="12">[12]</sup></a> gave a protocol for exchanging prime factors based on several assumptions (see Hastad and Shamir<a href="#citation15"><sup class="reference" data-citation="15">[15]</sup></a> for discussions); Luby, Micali, and Rackoff<a href="#citation13"><sup class="reference" data-citation="13">[13]</sup></a>, and Vazirani and Vazirani<a href="#citation14"><sup class="reference" data-citation="14">[14]</sup></a> gave protocols for exchanging secrets which are one bit long.
						</p>
						<p class="rp_original">
							The proof of <a href="#theorem3">Theorem 3</a> depends on the ability of two parties to generate a random integer \(N=p\cdot q\), with its <i>secret</i> \((p,q)\) hidden from each party, but recoverable at a later time by a joint effort. This result is of independent interest, and should serve as another useful tool for cryptographic protocol design. A general form of this result is given as <a href="#theorem1">Theorem 1</a>.
						</p>
						<p class="rp_original">
							Compared with <a href="#citation9"><span class="reference" data-citation="9">[9]</span></a><a href="#citation10"><span class="reference" data-citation="10">[10]</span></a>, which deals with the same general problem, the addition of the fairness property is the new motive which leads to the present work. We should mention that all the protocols considered in this paper for solving the interactive computational problems \(\langle h_n,w_n\rangle\) will be independent of \(h_n\), as is traditional in considering cryptographic protocols. The main results (Theorems <a href="#theorem1">1</a>,<a href="#theorem2">2</a>, and <a href="#theorem3">3</a>) are all proved under the following assumption. Let \(W_n\) be the set of all integers \(N\) of the form \(p\cdot q\) where \(p\equiv q\equiv 3\bmod{4}\) are prime numbers. 
						</p>
						<span class="rp_theorem_header" id="IAF">
							The Intractability Assumption of Factoring (IAF)
						</span>
						<p class="rp_original rp_theorem">
							Let \(k&gt;0\) be any fixed number. For any polynomial time probabilistic algorithm for factoring integers, the probability of success for a random input integer from \(W_n\) is less than \(\frac{1}{n^k}\) for all large \(n\).
						</p>
                    </section>
					<section id="sec2">
						<h2>Terminology</h2>
						<p class="rp_original">
							Let \(S=(S_1,S_2,\dots)\) and \(S'=(S_1',s_2',\dots)\) be <span class="definable" data-define="polynomial ensemble">polynomial ensembles</span>, where \(S_n=(X_n,Y_n)\) and \(S_n'=(X_n',Y_n')\) each is a probability distribution over \(\{0,1\}^*\times\{0,1\}^*\). Furthermore, assume that the two ensembles \((X_1,X_2,\dots)\) and \((X_1',X_2',\dots)\) are <span class="definable">indistinguishable</span> for polynomial-time computations.
						</p>
						<p class="rp_original">
							Let \(D=(d_1,d_2,\dots)\) be a sequence of predicates \(d_n:\{0,1\}^*\rightarrow\{0,1\}\), where given \(d\) and \(n\), \(d_n(x)\) can be computed probabilistically in time polynomial in \(n\). Define a <i>guessing algorithm</i> \(Q_B\) to be a probabilistic algorithm which takes \((n,y)\) as input, where \(y\in\{0,1\}^*\), and outputs a 0 or 1 in time polynomial in \(n\).
						</p>
						<p class="rp_original">
							Consider the experiment of taking a random \((x_n,y_n)\) distributed according to \((X_n,Y_n)\). Suppose that one observes the value \(y_N\) and tries to guess what the value of \(d_n(x_n)\) is by using a guessing algorithm \(Q\); let us denote by \(r(d_n,X_n,Y_n,Q)\) the probability that a correct guess will be made. We use the notation \(o\)(poly-small) to denote any sequence \((b_1,b_2,\dots)\) that has the property \(b_n\in o(\frac{1}{n^k})\) for all fixed \(k\).
						</p>
						<p class="rp_original">
							We write \(I_n(X_n | Y_n)\leq I_n(X_n' | Y_n')\) if \(\forall D,Q \exists Q'\) such that \(r(d_n,X_n',Y_n',Q')-r(d_n,X_n,Y_n,Q)\geq o\)(poly-small).
						</p>
						<p class="rp_original">
							We write \(I_n(X_n | Y_n)\approx I_n(X_n'|Y_n')\) if \(I_n(X_n | Y_n)\leq I_n(X_n'|Y_n')\) and \(I_n(X_n'|Y_n')\leq I_n(X_n|Y_n)\).
						</p>
						<p class="rp_original">
							A <i>puzzle ensemble</i> \(P=(L,F)\) consists of a language \(L\inBPP\) and a <span class="definable" data-define="polynomial ensemble">polynomial-time ensemble</span> \(F=(F_1,F_2,\dots)\) where each \(F_n\) is a distribution over \(\{0,1\}^*\times\{0,1\}^*\); we require further than a random \((s,\tau)\) distributed according to \(F_n\) will satisfy \((n,s,\tau)\in L\) with probability 1-\(o\)(poly-small); we will call \(s\) a <i>secret</i> of the <i>text</i> \(\tau\). Let \(T_{P,n}\) denote the distribution of a random \(\tau\) taken from the second component of a random \((s,\tau)\) distributed as \(F_n\). We will call \(P\) <i>intractable</i> if, for every probabilistic polynomial-time algorithm \(S\), when given as input a pair \((s,\tau)\), where \(\tau\) is distributed according to \(T_{P,n}\), will fail with probability 1-\(o\)(poly-small) to produce an \(s\) satisfying \((n,s,\tau)\in L\).
						</p>
						<p class="rp_original">
							For example, let \(L=\{(n;p,q,N) | N=p\cdot q, p,q\) are \(n\)-bit primes\(\}\), and \(F_n\) be the uniform distribution over the set \(W_n\). Under the <a href="#IAF">Intractability of Factorization Assumption</a>, the <i>factorization puzzle ensemble</i> \(P=(L,F)\) is an intractable puzzle ensemble.
						</p>
					</section>
					<section id="sec3">
						<h2>Generating a Secret</h2>
						<p class="rp_original">
							Let \(P=(L,F)\), where \(F=(F_1,F_2,\dots,F_n,\dots)\), be an intractable puzzle ensemble. We wish to design a protocol \(M=(M_A,M_B)\) which has the following properties for any given \(n\):
						</p>
						<ol class="rp_original">
							<li>\(M\) generates implicitly a pair \((s,\tau)\) distributed according to \(F_n\)</li>
							<li>The text \(\tau\) will be found out by \(M_A\) and \(M_B\) as their outputs.</li>
							<li>The secret \(s\), while computable by A and B jointly based on the information they have at the end of the execution of the protocol, is completely hidden from each party by itself, even if one of them cheats during the execution of the protocol</li>
						</ol>
						<p class="rp_original">
							To simplify the presentation of the result, we restrict ourselves to puzzles that have unique secrets. Let us call a puzzle ensemble \(P=(L,F)\) <i>uniquely decipherable</i> if, for every \(n,\tau\), there is at most one \(s\) satisfying \((n,s,\tau)\in L\). For example, the factorization puzzle ensemble is uniquely decipherable. For a uniquely decipherable puzzle ensemble, we can write it as \(P=(\alpha,D)\), where \(\alpha=(\alpha_1,\alpha_2,\dots)\) and \(D=(D_1,D_2,\dots)\) are given by \(\alpha_n(\tau)=s\) and \(D_n=T_{P,n}\).
						</p>
						<p class="rp_original">
							Let \(P=(\alpha,D)\) be a uniquely decipherable, intractable puzzle ensemble, where \(\alpha=(\alpha_1,\alpha_2,\dots)\) and \(D=(D_1,D_2,\dots)\). Formally, we define our requirements on a protocol \(M=(M_A,M_B)\) for generating a secret for \(P\) as follows. (A or B will sometimes output \(u_A\) or \(u_B=\)CHEATING; informally we say that A or B has detected that the other party is cheating.)
						</p>
						<section id="sec3.1">
							<h3>Validity</h3>
							<p class="rp_original">
								If both A and B follow the protocol, then
							</p>
							<ul class="rp_original" type="i">
								<li>
									With probability 1-\(o\)(poly-small), \(u_A=u_B\), and their common value \(\tau\) is distributed according to a distribution indistinguishable (by polynomial-time computations) from \(D_n\);
								</li>
								<li>
									\(I_n^{(J)}(a_n(\tau)|\tau,\Delta_j)\equiv I_N^{(L)}(a_n(\tau)|\tau) for \(j\in \{A,B\}\), where \(J\) is the stochastic process induced by the execution of the protocol \(M=(M_A,M_B)\), and \(L\) is the stochastic process of fetching \(\tau\) according to \(D_n\).
								</li>
								<li>
									\(\exists\) a protocol \(N=(N_A,N_B)\) which, given input \((\Delta_A,\Delta_B)\), computes outputs \(v_A,v_B\), with the property that \(v_A=v_B=a_n(\tau)\) with probability 1-\(o\)(poly-small).
								</li>
							</ul>
						</section>
						
					</section>
                </div>
            </div>
            <div class="main_toplevel main_section main_color8">
                <h1>References</h1>
                <ol id="referencelist">
                    <li id="citation1">GMR</li>
					<li id="citation2">GHY</li>
					<li id="citation3">R</li>
					<li id="citation4">FRMW</li>
					<li id="citation5">B1</li>
					<li id="citation6">C</li>
					<li id="citation7">SRA</li>
					<li id="citation8">GM</li>
					<li id="citation9">Y1</li>
					<li id="citation10">Y2</li>
					<li id="citation11">GMW</li>
					<li id="citation12">B2</li>
					<li id="citation13">LMR</li>
					<li id="citation14">VV</li>
					<li id="citation15">HS</li>
                </ol>
            </div>
            <div class="main_toplevel main_section main_color9">
                <div class="rp_problems">
                    <p><a href="mailto:multipartycomputationorg+24@gmail.com">Problem with this page?</a></p>
                </div>
                <p>Copyright &copy; Nicolas Schank 2014, Brown University</p>
            </div>
        </div>
    </body>
</html>